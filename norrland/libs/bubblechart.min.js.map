{"version":3,"sources":["webpack:///bubblechart.min.js","webpack:///webpack/bootstrap a3ba207206a2ace5a77e?abce","webpack:///./src/index.js?9552","webpack:///./src/component.js?a623","webpack:///./src/panzoom.js?e037","webpack:///./src/trail.js?e0cc","webpack:///./~/css.escape/css.escape.js?3a6d","webpack:///./src/template.html?60fe","webpack:///(webpack)/buildin/global.js?3698"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_component","_component2","obj","default","VERSION_INFO","version","build","Vizabi","Tool","extend","init","placeholder","external_model","this","components","component","model","Component","_super","validate","ui","chart","lockNonSelected","splash","state","time","parse","start","formatDate","end","default_model","autoconfig","type","entities","excludeIDs","entities_colorlegend","entities_tags","includeOnlyIDs","marker_tags","space","label","use","which","hook_parent","marker","axis_x","index","axis_y","size","color","syncModels","size_label","scaleType","_important","extent","allow","names","marker_colorlegend","hook_rank","hook_geoshape","locale","superhighlightOnMinimapHover","whenHovering","showProjectionLineX","showProjectionLineY","higlightValueX","higlightValueY","labels","dragging","removeLabelBox","margin","left","top","trails","datawarning","doubtDomain","doubtRange","show_ticks","presentation","panWithArrow","adaptMinMaxZoom","cursorMode","zoomOnScrolling","buttons","dialogs","popup","sidebar","moreoptions","versionInfo","_interopRequireDefault","_trail","_trail2","_panzoom","_panzoom2","_Vizabi","utils","_Vizabi$helpers","helpers","Exporter","svgexport","Labels","axisSmart","DynamicBackground","_Vizabi$iconset","iconset","iconWarn","warn","iconQuestion","question","BubbleChart","config","context","_this2","_this","template","model_expects","model_binds","change:time.playing","evt","original","isTouchDevice","playing","someHighlighted","clearHighlighted","change:time.start","_readyOnce","filter","hook","dim","length","ready","_trails","create","then","run","change:time.end","change:time.record","record","_export","open","element","reset","change:ui.chart.trails","toggle","redrawDataPoints","change:ui.chart.lockNonSelected","change:marker","path","indexOf","yScale","xScale","updateSize","updateMarkerSizeLimits","draggingNow","approxEqual","_zoomedXYMinMax","zoomedMin","zoomedMax","playAfterZoom","pause","_panZoom","zoomToMaxMin","getZoomedMin","getZoomedMax","postponePause","change:marker.select","entityBubbles","source","_val","_previousVal","selectDataPoints","updateBubbleOpacity","_updateDoubtOpacity","change:marker.superHighlight","_blinkSuperHighlighted","change:marker.highlight","highlightDataPoints","titles","_formatSTitleValues","_updateSTitle","change:time.value","calculationQueue","push","toString","getFrame","frame","_frameIsValid","splice","frameChanged","change:ui.adaptMinMaxZoom","expandCanvas","change:marker.size.extent","redrawDataPointsOnlySize","change:marker.color","redrawDataPointsOnlyColors","change:marker.opacitySelectDim","change:marker.opacityRegular","change:ui.cursorMode","svg","chartSvg","classed","change:marker.space","someSelected","clearSelected","sScale","cScale","xAxis","yAxis","COLOR_BLACKISH","COLOR_WHITEISH","isCanvasPreviouslyExpanded","prefix","deleteClasses","_labels","CSS_PREFIX","LABELS_CONTAINER_CLASS","LINES_CONTAINER_CLASS","LINES_CONTAINER_SELECTOR_PREFIX","_rangeBump","arg","undo","bump","activeProfile","maxRadiusPx","isArray","z1","z2","readyOnce","scrollableAncestor","findScrollableAncestor","d3","select","graph","yAxisElContainer","yAxisEl","xAxisElContainer","xAxisEl","ySubTitleEl","xSubTitleEl","yTitleEl","xTitleEl","sTitleEl","cTitleEl","yearEl","year","yInfoEl","xInfoEl","dataWarningEl","projectionX","projectionY","lineEqualXY","trailsContainer","bubbleContainerCrop","zoomSelection","labelsContainerCrop","bubbleContainer","labelsContainer","linesContainer","zoomRect","eventArea","bubbleCrown","selectAll","attr","location","pathname","tooltipMobile","on","xMin","xMax","yMin","yMax","zoomer","dontFeedToState","rerun","event","metaKey","ctrlKey","root","dragRectangle","cursor","defaultPrevented","zoomByIncrement","TIMEDIM","getDimension","KEYS","unique","_getAllDimensions","exceptType","KEY","join","dataKeys","getDataKeysPerHook","labelNames","getLabelHookNames","updateUIStrings","wScale","scaleLinear","domain","range","keys","updateIndicators","updateTime","defer","updateEntities","zoomToMarkerMaxMin","resetZoomState","zoomedMinX","getScale","zoomedMaxX","zoomedMinY","zoomedMaxY","setScales","tickFormat","getTickFormatter","duration","_reorderEntities","_getSubtitle","title","shortTitle","subtitle","replace","slice","regexpResult","exec","trim","conceptPropsY","getLayoutProfile","getConceptprops","conceptPropsX","conceptPropsS","conceptPropsC","translator","getTFunction","strings","Y","X","S","C","title_short","name_short","unit","data","enter","append","yTitle","parent","findChildByName","markerID","alignX","isRTL","alignY","updateView","xTitle","sTitle","setIcon","text","style","Number","Boolean","description","sourceLink","pin","rect","getBBox","coord","makeAbsoluteContext","farthestViewportElement","x","y","height","toolRect","getBoundingClientRect","chartRect","node","setHook","show","setPos","hide","opacity","getKeys","map","pointer","assign","endTime","sortValue","getKey","sort","a","b","markers","setVisible","unselectBubblesWithNoData","getVisible","exit","remove","_bubblesInteract","mouseover","mouseout","click","onTap","stopPropagation","onLongTap","merge","_select","forEach","sizeA","sizeB","descending","ascending","trailStartTime","status","highlightMarker","showCloseCross","isSelected","selectMarker","time_1","delayAnimations","setText","svgWidth","px2num","svgHeight","marginScaleH","marginMin","ratio","arguments","undefined","marginScaleW","profiles","small","bottom","right","leftMarginRatio","padding","minRadiusPx","maxRadiusEm","infoElHeight","yAxisTitleBottomMargin","xAxisTitleBottomMargin","medium","large","hideSTitle","presentationProfileChanges","getActiveProfile","layoutProfile","containerWH","getVizWidthHeight","Math","max","hypotenuse","width","setCloseCrossHeight","setTooltipFontSize","parseInt","resize","rangePoints","scale","tickSizeInner","tickSizeOuter","tickPadding","tickSizeMinor","labelerOptions","toolMargin","limitMaxTickNumber","viewportLength","formatter","yTitleText","xTitleText","titleBBox","t","transform","hTranslate","translateX","vTranslate","translateY","_resizeDataWarning","set","_updateLineEqualXY","oneMeasure","min","concat","transition","dataWarningText","dataWarningWidth","remainingWidth","font","warnBB","minRadius","maxRadius","minArea","radiusToArea","maxArea","valuesNow","valuesLocked","each","selected","valueC","scaledC","find","f","valuesTrailStart","cache","scaledC0","updateLabelOnlyColor","valueS","scaledS","areaToRadius","scaledS0","updateLabelOnlyPosition","lockedFrame","_updateBubble","values","view","showhide","valueY","valueX","valueL","valueLST","hidden","ease","easeExp","easeLinear","interrupt","write","id","getUTCFullYear","fill","cx","cy","r","_updateLabel","labelX0","labelY0","labelText","_getLabelText","updateLabel","key","_setTooltip","tooltipText","labelValues","tooltipCache","invert","setTooltip","titleS","titleC","unitS","unitC","formatterS","formatterC","isDiscrete","getColorlegendMarker","getItems","sTitleContentON","cTitleContentON","sTitleText","sTitleWidth","remainigHeight","_setBubbleCrown","nonSelectedOpacityZero","glow","skipInnerFill","_axisProjections","radius","highlightValue","highlight","clone","entityOutOfView","hoverTrail","selectedData","target","skipCrownInnerFill","clonedSelectedData","_this3","isSuperHighlighted","OPACITY_HIGHLT_DIM","opacityHighlightDim","OPACITY_REGULAR","opacityRegular","OPACITY_SELECT_DIM","opacitySelectDim","isHighlighted","PanZoom","Class","drag","zoom","subject","dragSubject","go","stop","zoomFilter","scaleExtent","Infinity","ratioX","ratioY","sourceEvent","touches","targetTouches","mouse","self","origin","abs","e","compensateDragging","_zoomOnRectangle","_data","k","pan","isNaN","deltaY","wheelDelta","minZoomScale","zoomXOut","zoomYOut","zoomIdentity","translate","xPanOffset","yPanOffset","xRange","yRange","xRangeBumped","yRangeBumped","xRangeMinOffset","xRangeMaxOffset","yRangeMinOffset","yRangeMaxOffset","xRangeBounds","yRangeBounds","xRangeBoundsBumped","yRangeBoundsBumped","rangeBands","isDate","toFixed","zoomedXRange","zoomedYRange","optionsY","optionsX","transitionDuration","mmX","mmY","suggestedFrame","x1","y1","x2","y2","xBounds","yBounds","xBoundsBumped","yBoundsBumped","minX","maxX","minY","maxY","xDomain","yDomain","zoomedX1","zoomedY1","zoomedX2","zoomedY2","zoomTransform","minZoom","maxZoom","direction","log","LN2","floor","ceil","locus","pow","scaleBy","_css","_css2","Trail","_isCreated","actionsQueue","entityTrails","trailsData","trailsInProgress","activePromises","trailTransitions","delayedIterations","drawingQueue","_context","selection","Promise","resolve","reject","timePoints","getAllSteps","promises","_clearActions","selectedEntityData","insert","querySelector","trail","trailSegmentData","segment","getModelObject","trigger","all","segments","_addActions","selections","actions","promise","_getNextAction","shift","action","pop","executeSequential","response","_remove","parentNode","_resize","transparent","next","lineLength","sqrt","_recolor","strokeColor","getColorShade","colorID","shadeID","_opacityHandler","_findVisible","resolve1","reject1","limits","getEntityLimits","cached","segmentVisibility","visibilityChanged","_groups","_abortAnimation","_reveal","delay","generateTrailSegment","nextIndex","level","datum","nextSegment","previous","nextTime","nextFrame","addNewIntervals","addPointBetween","previousIndex","previousSegment","firstLineLength","secondLineLength","mediumIndex","getPointBetween","first","round","_generateKeys","div","maxValue","minValue","__data__","unshift","processPoints","processPoint","pointIndex","random","point","JSON","stringify","processPointsBetween","framesAreReady","generateTrails","trailKeys","global","factory","CSS","escape","cssEscape","TypeError","codeUnit","string","String","result","firstCodeUnit","charCodeAt","charAt","g","Function","eval","window"],"mappings":"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","file":"bubblechart.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 8);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n__webpack_require__(5);\n\nvar _component = __webpack_require__(1);\n\nvar _component2 = _interopRequireDefault(_component);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar VERSION_INFO = { version: \"1.0.25\", build: 1513414820356 };\n\nexports.default = Vizabi.Tool.extend(\"BubbleChart\", {\n\n  /**\n   * Initializes the tool (Bubble Chart Tool).\n   * Executed once before any template is rendered.\n   * @param {Object} placeholder Placeholder element for the tool\n   * @param {Object} external_model Model as given by the external page\n   */\n  init: function init(placeholder, external_model) {\n\n    this.name = \"bubblechart\";\n\n    //specifying components\n    this.components = [{\n      component: _component2.default,\n      placeholder: \".vzb-tool-viz\",\n      model: [\"state.time\", \"state.marker\", \"locale\", \"ui\"] //pass models to component\n    }, {\n      component: Vizabi.Component.get(\"timeslider\"),\n      placeholder: \".vzb-tool-timeslider\",\n      model: [\"state.time\", \"state.marker\", \"ui\"]\n    }, {\n      component: Vizabi.Component.get(\"dialogs\"),\n      placeholder: \".vzb-tool-dialogs\",\n      model: [\"state\", \"ui\", \"locale\"]\n    }, {\n      component: Vizabi.Component.get(\"buttonlist\"),\n      placeholder: \".vzb-tool-buttonlist\",\n      model: [\"state\", \"ui\", \"locale\"]\n    }, {\n      component: Vizabi.Component.get(\"treemenu\"),\n      placeholder: \".vzb-tool-treemenu\",\n      model: [\"state.marker\", \"state.marker_tags\", \"state.time\", \"locale\"]\n    }, {\n      component: Vizabi.Component.get(\"datawarning\"),\n      placeholder: \".vzb-tool-datawarning\",\n      model: [\"locale\"]\n    }, {\n      component: Vizabi.Component.get(\"datanotes\"),\n      placeholder: \".vzb-tool-datanotes\",\n      model: [\"state.marker\", \"locale\"]\n    }, {\n      component: Vizabi.Component.get(\"steppedspeedslider\"),\n      placeholder: \".vzb-tool-stepped-speed-slider\",\n      model: [\"state.time\", \"locale\"]\n    }];\n\n    this._super(placeholder, external_model);\n  },\n  validate: function validate(model) {\n    model = this.model || model;\n\n    this._super(model);\n\n    if (model.ui.chart.lockNonSelected && (!model.ui.splash || model.state.time.splash === false)) {\n      var time = model.state.time.parse(\"\" + model.ui.chart.lockNonSelected);\n      if (time < model.state.time.start) model.ui.chart.lockNonSelected = model.state.time.formatDate(model.state.time.start);\n      if (time > model.state.time.end) model.ui.chart.lockNonSelected = model.state.time.formatDate(model.state.time.end);\n    }\n  },\n\n\n  /**\n   * Determines the default model of this tool\n   */\n  default_model: {\n    state: {\n      time: {\n        \"autoconfig\": {\n          \"type\": \"time\"\n        }\n      },\n      entities: {\n        \"autoconfig\": {\n          \"type\": \"entity_domain\",\n          \"excludeIDs\": [\"tag\"]\n        }\n      },\n      entities_colorlegend: {\n        \"autoconfig\": {\n          \"type\": \"entity_domain\",\n          \"excludeIDs\": [\"tag\"]\n        }\n      },\n      entities_tags: {\n        \"autoconfig\": {\n          \"type\": \"entity_domain\",\n          \"includeOnlyIDs\": [\"tag\"]\n        }\n      },\n      marker_tags: {\n        space: [\"entities_tags\"],\n        label: {\n          use: \"property\",\n          which: \"name\"\n        },\n        hook_parent: {}\n      },\n      marker: {\n        space: [\"entities\", \"time\"],\n        axis_x: {\n          use: \"indicator\",\n          \"autoconfig\": {\n            index: 0,\n            type: \"measure\"\n          }\n        },\n        axis_y: {\n          use: \"indicator\",\n          \"autoconfig\": {\n            index: 1,\n            type: \"measure\"\n          }\n        },\n        label: {\n          use: \"property\",\n          \"autoconfig\": {\n            \"includeOnlyIDs\": [\"name\"],\n            \"type\": \"string\"\n          }\n        },\n        size: {\n          \"autoconfig\": {\n            index: 2,\n            type: \"measure\"\n          }\n        },\n        color: {\n          syncModels: [\"marker_colorlegend\"],\n          \"autoconfig\": {}\n        },\n        size_label: {\n          use: \"constant\",\n          which: \"_default\",\n          scaleType: \"ordinal\",\n          _important: false,\n          extent: [0, 0.33],\n          allow: {\n            names: [\"_default\"]\n          }\n        }\n      },\n      \"marker_colorlegend\": {\n        \"space\": [\"entities_colorlegend\"],\n        \"label\": {\n          \"use\": \"property\",\n          \"which\": \"name\"\n        },\n        \"hook_rank\": {\n          \"use\": \"property\",\n          \"which\": \"rank\"\n        },\n        \"hook_geoshape\": {\n          \"use\": \"property\",\n          \"which\": \"shape_lores_svg\"\n        }\n      }\n    },\n    locale: {},\n    ui: {\n      chart: {\n        superhighlightOnMinimapHover: true,\n        whenHovering: {\n          showProjectionLineX: true,\n          showProjectionLineY: true,\n          higlightValueX: true,\n          higlightValueY: true\n        },\n        labels: {\n          dragging: true,\n          removeLabelBox: false\n        },\n        margin: {\n          left: 0,\n          top: 0\n        },\n        trails: true,\n        lockNonSelected: 0\n      },\n      datawarning: {\n        doubtDomain: [],\n        doubtRange: []\n      },\n      show_ticks: true,\n      presentation: false,\n      panWithArrow: false,\n      adaptMinMaxZoom: false,\n      cursorMode: \"arrow\",\n      zoomOnScrolling: false,\n      buttons: [\"colors\", \"find\", \"zoom\", \"trails\", \"lock\", \"moreoptions\", \"fullscreen\", \"presentation\"],\n      dialogs: {\n        popup: [\"colors\", \"find\", \"size\", \"zoom\", \"moreoptions\"],\n        sidebar: [\"colors\", \"find\", \"size\", \"zoom\"],\n        moreoptions: [\"opacity\", \"speed\", \"axes\", \"size\", \"colors\", \"label\", \"zoom\", \"presentation\", \"about\"]\n      }\n    }\n  },\n\n  versionInfo: VERSION_INFO\n});\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _trail = __webpack_require__(3);\n\nvar _trail2 = _interopRequireDefault(_trail);\n\nvar _panzoom = __webpack_require__(2);\n\nvar _panzoom2 = _interopRequireDefault(_panzoom);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _Vizabi = Vizabi,\n    utils = _Vizabi.utils;\nvar _Vizabi$helpers = Vizabi.helpers,\n    Exporter = _Vizabi$helpers.svgexport,\n    Labels = _Vizabi$helpers.labels,\n    axisSmart = _Vizabi$helpers['d3.axisWithLabelPicker'],\n    DynamicBackground = _Vizabi$helpers['d3.dynamicBackground'];\nvar _Vizabi$iconset = Vizabi.iconset,\n    iconWarn = _Vizabi$iconset.warn,\n    iconQuestion = _Vizabi$iconset.question;\n\n\n// BUBBLE CHART COMPONENT\nvar BubbleChart = Vizabi.Component.extend(\"bubblechart\", {\n\n  /**\n   * Initializes the component (Bubble Chart).\n   * Executed once before any template is rendered.\n   * @param {Object} config The config passed to the component\n   * @param {Object} context The component's parent\n   */\n  init: function init(config, context) {\n    var _this2 = this;\n\n    var _this = this;\n    this.name = \"bubblechart\";\n    this.template = __webpack_require__(6);\n\n    //define expected models for this component\n    this.model_expects = [{\n      name: \"time\",\n      type: \"time\"\n    }, {\n      name: \"marker\",\n      type: \"marker\"\n    }, {\n      name: \"locale\",\n      type: \"locale\"\n    }, {\n      name: \"ui\",\n      type: \"ui\"\n    }];\n\n    this.model_binds = {\n      \"change:time.playing\": function changeTimePlaying(evt, original) {\n        if (utils.isTouchDevice() && _this.model.time.playing && _this.someHighlighted) {\n          _this.model.marker.clearHighlighted();\n        }\n      },\n      \"change:time.start\": function changeTimeStart(evt, original) {\n        if (!_this._readyOnce || _this.model.time.splash) return;\n        if ([\"color\", \"axis_x\", \"axis_y\"].filter(function (hook) {\n          return _this.model.marker[hook].which == _this.model.time.dim;\n        }).length) {\n          _this.ready();\n          return;\n        };\n        _this._trails.create().then(function () {\n          _this._trails.run([\"findVisible\", \"reveal\", \"opacityHandler\"]);\n        });\n      },\n      \"change:time.end\": function changeTimeEnd(evt, original) {\n        if (!_this._readyOnce || _this.model.time.splash) return;\n        if ([\"color\", \"axis_x\", \"axis_y\"].filter(function (hook) {\n          return _this.model.marker[hook].which == _this.model.time.dim;\n        }).length) {\n          _this.ready();\n          return;\n        };\n        _this._trails.create().then(function () {\n          _this._trails.run([\"findVisible\", \"reveal\", \"opacityHandler\"]);\n        });\n      },\n      \"change:time.record\": function changeTimeRecord() {\n        //console.log(\"change time record\");\n        if (_this.model.time.record) {\n          _this._export.open(this.element, this.name);\n        } else {\n          _this._export.reset();\n        }\n      },\n      \"change:ui.chart.trails\": function changeUiChartTrails(evt) {\n        //console.log(\"EVENT change:time:trails\");\n        if (!_this._readyOnce) return;\n        _this._trails.toggle(_this.model.ui.chart.trails);\n        _this.redrawDataPoints();\n      },\n      \"change:ui.chart.lockNonSelected\": function changeUiChartLockNonSelected(evt) {\n        if (!_this._readyOnce) return;\n        //console.log(\"EVENT change:time:lockNonSelected\");\n        _this.redrawDataPoints(500);\n      },\n      \"change:marker\": function changeMarker(evt, path) {\n        // bubble size change is processed separately\n        if (!_this._readyOnce) return;\n        if (path.indexOf(\"scaleType\") > -1) {\n          _this.ready();\n          return;\n        }\n\n        if (path.indexOf(\"marker.color\") !== -1) return;\n        if (path.indexOf(\"marker.size\") !== -1) return;\n        if (path.indexOf(\"marker.size_label\") !== -1) return;\n\n        if (path.indexOf(\"domainMin\") > -1 || path.indexOf(\"domainMax\") > -1) {\n          if (!_this.yScale || !_this.xScale) return; //abort if building of the scale is in progress\n          _this.updateSize();\n          _this.updateMarkerSizeLimits();\n          _this._trails.run(\"findVisible\");\n          _this.redrawDataPoints();\n          _this._trails.run(\"resize\", null, 500);\n        } else if (path.indexOf(\"zoomedMin\") > -1 || path.indexOf(\"zoomedMax\") > -1) {\n          if (_this.draggingNow) return;\n\n          //avoid zooming again if values didn't change.\n          //also prevents infinite loop on forced URL update from zoom.stop()\n          if (utils.approxEqual(_this._zoomedXYMinMax.axis_x.zoomedMin, _this.model.marker.axis_x.zoomedMin, 0.01) && utils.approxEqual(_this._zoomedXYMinMax.axis_x.zoomedMax, _this.model.marker.axis_x.zoomedMax, 0.01) && utils.approxEqual(_this._zoomedXYMinMax.axis_y.zoomedMin, _this.model.marker.axis_y.zoomedMin, 0.01) && utils.approxEqual(_this._zoomedXYMinMax.axis_y.zoomedMax, _this.model.marker.axis_y.zoomedMax, 0.01)) return;\n          var playAfterZoom = false;\n          if (_this.model.time.playing) {\n            playAfterZoom = true;\n            _this.model.time.pause(true);\n          }\n          _this._trails.run(\"abortAnimation\");\n          _this._panZoom.zoomToMaxMin(_this.model.marker.axis_x.getZoomedMin(), _this.model.marker.axis_x.getZoomedMax(), _this.model.marker.axis_y.getZoomedMin(), _this.model.marker.axis_y.getZoomedMax(), 500 /*duration*/, \"don't feed these zoom values back to state\");\n          if (playAfterZoom) {\n            _this.model.time.postponePause = false;\n          }\n        }\n\n        //console.log(\"EVENT change:marker\", evt);\n      },\n      \"change:marker.select\": function changeMarkerSelect(evt, path) {\n        if (!_this._readyOnce || !_this.entityBubbles) return;\n        //console.log(\"EVENT change:marker:select\");\n\n        //disable trails if too many items get selected at once\n        //otherwise it's too much waiting time\n        if ((evt.source._val || []).length - (evt.source._previousVal || []).length > 50) _this.model.ui.chart.trails = false;\n\n        _this.selectDataPoints();\n        _this.redrawDataPoints();\n        _this._trails.create().then(function () {\n          _this._trails.run([\"findVisible\", \"reveal\", \"opacityHandler\"]);\n        });\n        _this.updateBubbleOpacity();\n        _this._updateDoubtOpacity();\n      },\n      \"change:marker.superHighlight\": function changeMarkerSuperHighlight(evt, path) {\n        if (_this2._readyOnce) {\n          _this2._blinkSuperHighlighted();\n        }\n      },\n      \"change:marker.highlight\": function changeMarkerHighlight(evt, path) {\n        if (!_this._readyOnce) return;\n        //path have values if trail is highlighted\n        if (path != \"highlight\") {\n          if (path !== null) {\n            var titles = _this._formatSTitleValues(path.size, path.color);\n            _this._updateSTitle(titles[0], titles[1]);\n          } else {\n            _this._updateSTitle();\n          }\n          return;\n        }\n        //console.log(\"EVENT change:marker:highlight\");\n        _this.highlightDataPoints();\n      },\n      \"change:time.value\": function changeTimeValue() {\n        if (_this.model.time.splash || !_this._readyOnce || !_this.entityBubbles) return;\n        if (!_this.calculationQueue) {\n          // collect timestamp that we request\n          _this.calculationQueue = [_this.model.time.value.toString()];\n        } else {\n          _this.calculationQueue.push(_this.model.time.value.toString());\n        }\n        (function (time) {\n          // isolate timestamp\n          //_this._bubblesInteract().mouseout();\n          _this.model.marker.getFrame(time, function (frame, time) {\n            if (!_this._frameIsValid(frame)) return utils.warn(\"change:time.value: empty data received from marker.getFrame(). doing nothing\");\n            var index = _this.calculationQueue.indexOf(time.toString()); //\n            if (index == -1) {\n              // we was receive more recent frame before so we pass this frame\n              return;\n            }\n            _this.calculationQueue.splice(0, index + 1); // remove timestamps that added to queue before current timestamp\n            _this.frameChanged(frame, time);\n          });\n        })(_this.model.time.value);\n      },\n      \"change:ui.adaptMinMaxZoom\": function changeUiAdaptMinMaxZoom() {\n        //console.log(\"EVENT change:ui:adaptMinMaxZoom\");\n        if (_this.model.ui.adaptMinMaxZoom) {\n          _this._panZoom.expandCanvas(500);\n        } else {\n          _this._panZoom.reset();\n        }\n      },\n      \"change:marker.size.extent\": function changeMarkerSizeExtent(evt, path) {\n        //console.log(\"EVENT change:marker:size:max\");\n        if (!_this._readyOnce) return;\n        _this.updateMarkerSizeLimits();\n        _this.redrawDataPointsOnlySize();\n        _this._trails.run(\"resize\");\n      },\n      \"change:marker.color\": function changeMarkerColor(evt, path) {\n        if (!_this._readyOnce) return;\n        //console.log(\"EVENT change:marker:color:palette\");\n        _this.redrawDataPointsOnlyColors();\n        _this._trails.run(\"recolor\");\n      },\n      // 'change:marker.color.palette': function(evt, path) {\n      //   if(!_this._readyOnce) return;\n      //   //console.log(\"EVENT change:marker:color:palette\");\n      //   _this.redrawDataPointsOnlyColors();\n      //   _this._trails.run(\"recolor\");\n      // },\n      \"change:marker.opacitySelectDim\": function changeMarkerOpacitySelectDim() {\n        _this.updateBubbleOpacity();\n      },\n      \"change:marker.opacityRegular\": function changeMarkerOpacityRegular() {\n        _this.updateBubbleOpacity();\n        _this._trails.run(\"opacityHandler\");\n      },\n      \"change:ui.cursorMode\": function changeUiCursorMode() {\n        var svg = _this.chartSvg;\n        if (_this.model.ui.cursorMode === \"plus\") {\n          svg.classed(\"vzb-zoomin\", true);\n          svg.classed(\"vzb-zoomout\", false);\n          svg.classed(\"vzb-panhand\", false);\n        } else if (_this.model.ui.cursorMode === \"minus\") {\n          svg.classed(\"vzb-zoomin\", false);\n          svg.classed(\"vzb-zoomout\", true);\n          svg.classed(\"vzb-panhand\", false);\n        } else if (_this.model.ui.cursorMode === \"hand\") {\n          svg.classed(\"vzb-zoomin\", false);\n          svg.classed(\"vzb-zoomout\", false);\n          svg.classed(\"vzb-panhand\", true);\n        } else {\n          svg.classed(\"vzb-zoomin\", false);\n          svg.classed(\"vzb-zoomout\", false);\n          svg.classed(\"vzb-panhand\", false);\n        }\n      },\n      \"change:marker.space\": function changeMarkerSpace() {\n        if (_this.someHighlighted) {\n          _this.model.marker.clearHighlighted();\n        }\n        if (_this.someSelected) {\n          _this.model.marker.clearSelected();\n        }\n      },\n      \"ready\": function ready() {\n        // if(_this.model.marker.color.scaleType === 'time') {\n        //   _this.model.marker.color.scale = null;\n        //   utils.defer(function() {\n        //     _this.trigger('ready');\n        //   });\n        // }\n      }\n    };\n\n    this._super(config, context);\n\n    this.xScale = null;\n    this.yScale = null;\n    this.sScale = null;\n    this.cScale = null;\n\n    this.xAxis = axisSmart(\"bottom\");\n    this.yAxis = axisSmart(\"left\");\n\n    _this.COLOR_BLACKISH = \"#333\";\n    _this.COLOR_WHITEISH = \"#fdfdfd\";\n\n    this.isCanvasPreviouslyExpanded = false;\n    this.draggingNow = null;\n\n    this._trails = new _trail2.default(this);\n    this._panZoom = new _panzoom2.default(this);\n    this._export = new Exporter(this);\n    this._export.prefix(\"vzb-bc-\").deleteClasses([\"vzb-bc-bubbles-crop\", \"vzb-hidden\", \"vzb-bc-year\", \"vzb-bc-zoom-rect\", \"vzb-bc-projection-x\", \"vzb-bc-projection-y\", \"vzb-bc-axis-c-title\"]);\n    this._labels = new Labels(this);\n    this._labels.config({\n      CSS_PREFIX: \"vzb-bc\",\n      LABELS_CONTAINER_CLASS: \"vzb-bc-labels\",\n      LINES_CONTAINER_CLASS: \"vzb-bc-bubbles\",\n      LINES_CONTAINER_SELECTOR_PREFIX: \"bubble-\"\n    });\n  },\n  _rangeBump: function _rangeBump(arg, undo) {\n    var bump = this.activeProfile.maxRadiusPx / 2;\n    undo = undo ? -1 : 1;\n    if (utils.isArray(arg) && arg.length > 1) {\n      var z1 = arg[0];\n      var z2 = arg[arg.length - 1];\n\n      //the sign of bump depends on the direction of the scale\n      if (z1 < z2) {\n        z1 += bump * undo;\n        z2 -= bump * undo;\n        // if the scale gets inverted because of bump, set it to avg between z1 and z2\n        if (z1 > z2) z1 = z2 = (z1 + z2) / 2;\n      } else if (z1 > z2) {\n        z1 -= bump * undo;\n        z2 += bump * undo;\n        // if the scale gets inverted because of bump, set it to avg between z1 and z2\n        if (z1 < z2) z1 = z2 = (z1 + z2) / 2;\n      } else {\n        // rangeBump error: the input scale range has 0 length. that sucks but we keep cool\n      }\n      return [z1, z2];\n    }\n    utils.warn(\"rangeBump error: input is not an array or empty\");\n  },\n\n\n  /**\n   * Executes right after the template is in place, but the model is not yet ready\n   */\n  readyOnce: function readyOnce() {\n    var _this = this;\n    this._readyOnce = false;\n    this.scrollableAncestor = utils.findScrollableAncestor(this.element);\n    this.element = d3.select(this.element);\n\n    // reference elements\n    this.chartSvg = this.element.select(\"svg\");\n    this.graph = this.element.select(\".vzb-bc-graph\");\n    this.yAxisElContainer = this.graph.select(\".vzb-bc-axis-y\");\n    this.yAxisEl = this.yAxisElContainer.select(\"g\");\n\n    this.xAxisElContainer = this.graph.select(\".vzb-bc-axis-x\");\n    this.xAxisEl = this.xAxisElContainer.select(\"g\");\n\n    this.ySubTitleEl = this.graph.select(\".vzb-bc-axis-y-subtitle\");\n    this.xSubTitleEl = this.graph.select(\".vzb-bc-axis-x-subtitle\");\n    this.yTitleEl = this.graph.select(\".vzb-bc-axis-y-title\");\n    this.xTitleEl = this.graph.select(\".vzb-bc-axis-x-title\");\n    this.sTitleEl = this.graph.select(\".vzb-bc-axis-s-title\");\n    this.cTitleEl = this.graph.select(\".vzb-bc-axis-c-title\");\n    this.yearEl = this.graph.select(\".vzb-bc-year\");\n\n    this.year = new DynamicBackground(this.yearEl);\n\n    this.yInfoEl = this.graph.select(\".vzb-bc-axis-y-info\");\n    this.xInfoEl = this.graph.select(\".vzb-bc-axis-x-info\");\n    this.dataWarningEl = this.graph.select(\".vzb-data-warning\");\n\n    this.projectionX = this.graph.select(\".vzb-bc-projection-x\");\n    this.projectionY = this.graph.select(\".vzb-bc-projection-y\");\n    this.lineEqualXY = this.graph.select(\".vzb-bc-line-equal-xy\");\n\n    this.trailsContainer = this.graph.select(\".vzb-bc-trails\");\n    this.bubbleContainerCrop = this.graph.select(\".vzb-bc-bubbles-crop\");\n    this.zoomSelection = this.graph.select(\".vzb-zoom-selection\");\n    this.labelsContainerCrop = this.graph.select(\".vzb-bc-labels-crop\");\n    this.bubbleContainer = this.graph.select(\".vzb-bc-bubbles\");\n    this.labelsContainer = this.graph.select(\".vzb-bc-labels\");\n    this.linesContainer = this.graph.select(\".vzb-bc-lines\");\n    this.zoomRect = this.element.select(\".vzb-bc-zoom-rect\");\n    this.eventArea = this.element.select(\".vzb-bc-eventarea\");\n\n    this.entityBubbles = null;\n    this.bubbleCrown = this.element.select(\".vzb-bc-bubble-crown\");\n    //set filter\n    this.bubbleCrown.selectAll(\".vzb-crown-glow\").attr(\"filter\", \"url(\" + location.pathname + \"#vzb-glow-filter)\");\n    this.tooltipMobile = this.element.select(\".vzb-tooltip-mobile\");\n    //component events\n    this.on(\"resize\", function () {\n      //console.log(\"EVENT: resize\");\n      //return if updatesize exists with error\n      _this._trails.run(\"abortAnimation\");\n      if (_this.updateSize()) return;\n      _this.updateMarkerSizeLimits();\n      _this._labels.updateSize();\n      (function (xMin, xMax, yMin, yMax) {\n        _this._panZoom.zoomer.dontFeedToState = true;\n        _this._panZoom.rerun(); // includes redraw data points and trail resize\n        _this._panZoom.zoomToMaxMin(xMin, xMax, yMin, yMax, 0, true);\n      })(_this._zoomedXYMinMax.axis_x.zoomedMin, _this._zoomedXYMinMax.axis_x.zoomedMax, _this._zoomedXYMinMax.axis_y.zoomedMin, _this._zoomedXYMinMax.axis_y.zoomedMax);\n    });\n\n    //keyboard listeners\n    d3.select(\"body\").on(\"keydown\", function () {\n      if (_this.model.ui.cursorMode !== \"arrow\" && _this.model.ui.cursorMode !== \"hand\") return;\n      if (d3.event.metaKey || d3.event.ctrlKey) _this.element.select(\"svg\").classed(\"vzb-zoomin\", true);\n    }).on(\"keyup\", function () {\n      if (_this.model.ui.cursorMode !== \"arrow\" && _this.model.ui.cursorMode !== \"hand\") return;\n      if (!d3.event.metaKey && !d3.event.ctrlKey) _this.element.select(\"svg\").classed(\"vzb-zoomin\", false);\n    })\n    //this is for the case when user would press ctrl and move away from the browser tab or window\n    //keyup event would happen somewhere else and won't be captured, so zoomin class would get stuck\n    .on(\"mouseenter\", function () {\n      if (_this.model.ui.cursorMode !== \"arrow\" && _this.model.ui.cursorMode !== \"hand\") return;\n      if (!d3.event.metaKey && !d3.event.ctrlKey) _this.element.select(\"svg\").classed(\"vzb-zoomin\", false);\n    });\n\n    this.root.on(\"resetZoom\", function () {\n      _this._panZoom.reset(null, 500);\n    });\n\n    this._panZoom.zoomSelection(this.bubbleContainerCrop);\n    this.bubbleContainerCrop.call(this._panZoom.dragRectangle).call(this._panZoom.zoomer).on(\"dblclick.zoom\", null).on(\"mouseup\", function () {\n      _this.draggingNow = false;\n    }).on(\"click\", function () {\n      var cursor = _this.model.ui.cursorMode;\n      if (!d3.event.defaultPrevented && cursor !== \"arrow\" && cursor !== \"hand\") {\n        _this._panZoom.zoomByIncrement(cursor, 500);\n      }\n    });\n\n    this.TIMEDIM = this.model.time.getDimension();\n    this.KEYS = utils.unique(this.model.marker._getAllDimensions({ exceptType: \"time\" }));\n    this.KEY = this.KEYS.join(\",\");\n    this.dataKeys = this.model.marker.getDataKeysPerHook();\n    this.labelNames = this.model.marker.getLabelHookNames();\n\n    this.updateUIStrings();\n\n    this.wScale = d3.scaleLinear().domain(this.model.ui.datawarning.doubtDomain).range(this.model.ui.datawarning.doubtRange);\n\n    this._labels.readyOnce();\n\n    _this._readyOnce = true;\n  },\n  _frameIsValid: function _frameIsValid(frame) {\n    return !(!frame || Object.keys(frame.axis_y).length === 0 || Object.keys(frame.axis_x).length === 0 || Object.keys(frame.size).length === 0);\n  },\n  ready: function ready() {\n    var _this = this;\n    this.KEYS = utils.unique(this.model.marker._getAllDimensions({ exceptType: \"time\" }));\n    this.KEY = this.KEYS.join(\",\");\n    this.dataKeys = this.model.marker.getDataKeysPerHook();\n    this.labelNames = this.model.marker.getLabelHookNames();\n\n    this.updateUIStrings();\n    var endTime = this.model.time.end;\n    this.updateIndicators();\n    this.updateTime();\n    if (!_this.model.time.splash) {\n      _this._trails.create();\n    }\n    this.model.marker.getFrame(this.model.time.value, function (frame, time) {\n      // TODO: temporary fix for case when after data loading time changed on validation\n      if (time.toString() != _this.model.time.value.toString()) {\n        utils.defer(function () {\n          _this.ready();\n        });\n        return;\n      }\n      if (!_this._frameIsValid(frame)) return utils.warn(\"ready: empty data received from marker.getFrame(). doing nothing\");\n\n      _this.frame = frame;\n      _this.updateSize();\n      _this.updateMarkerSizeLimits();\n      _this.updateEntities();\n      _this._labels.ready();\n      _this.redrawDataPoints();\n      _this.selectDataPoints();\n      _this.updateBubbleOpacity();\n      _this._updateDoubtOpacity();\n      _this.zoomToMarkerMaxMin(); // includes redraw data points and trail resize\n      if (!_this.model.time.splash) {\n        _this._trails.run([\"findVisible\", \"reveal\", \"opacityHandler\"]);\n      }\n      if (_this.model.ui.adaptMinMaxZoom) _this._panZoom.expandCanvas();\n    });\n  },\n\n\n  /*\n   * Zoom to the min and max values given in the URL axes markers.\n   */\n  zoomToMarkerMaxMin: function zoomToMarkerMaxMin() {\n    /*\n     * Reset just the zoom values without triggering a zoom event. This ensures\n     * a clean zoom state for the subsequent zoom event.\n     */\n    this._panZoom.resetZoomState();\n\n    var xAxis = this.model.marker.axis_x;\n    var yAxis = this.model.marker.axis_y;\n\n    var xDomain = xAxis.getScale().domain();\n    var yDomain = yAxis.getScale().domain();\n\n    /*\n     * The axes may return null when there is no value given for the zoomed\n     * min and max values. In that case, fall back to the axes' domain values.\n     */\n    var zoomedMinX = xAxis.getZoomedMin();\n    var zoomedMaxX = xAxis.getZoomedMax();\n    var zoomedMinY = yAxis.getZoomedMin();\n    var zoomedMaxY = yAxis.getZoomedMax();\n\n    //by default this will apply no transition and feed values back to state\n    this._panZoom.zoomToMaxMin(zoomedMinX, zoomedMaxX, zoomedMinY, zoomedMaxY, 0, \"don't feed these zoom values back to state\");\n  },\n\n\n  /*\n   * UPDATE INDICATORS\n   */\n  updateIndicators: function updateIndicators() {\n    var _this = this;\n\n    //scales\n    this.yScale = this.model.marker.axis_y.getScale();\n    this.xScale = this.model.marker.axis_x.getScale();\n    this.sScale = this.model.marker.size.getScale();\n    this.cScale = this.model.marker.color.getScale();\n    this._labels.setScales(this.xScale, this.yScale);\n\n    this.yAxis.tickFormat(_this.model.marker.axis_y.getTickFormatter());\n    this.xAxis.tickFormat(_this.model.marker.axis_x.getTickFormatter());\n  },\n  frameChanged: function frameChanged(frame, time) {\n    //    if (time.toString() != this.model.time.value.toString()) return; // frame is outdated\n    this.frame = frame;\n    this.updateTime();\n\n    this._updateDoubtOpacity();\n    this._trails.run(\"findVisible\");\n    if (this.model.ui.adaptMinMaxZoom) {\n      this._panZoom.expandCanvas();\n    } else {\n      this.redrawDataPoints();\n    }\n    this._trails.run(\"reveal\", null, this.duration);\n    this.tooltipMobile.classed(\"vzb-hidden\", true);\n    this._reorderEntities();\n  },\n  _getSubtitle: function _getSubtitle(title, shortTitle) {\n    var subtitle = title.replace(shortTitle, \"\");\n    if (subtitle[0] === \",\") subtitle = subtitle.slice(1);\n    var regexpResult = /^\\((.*)\\)$|.*/.exec(subtitle.trim());\n    return regexpResult[1] || regexpResult[0] || \"\";\n  },\n  updateUIStrings: function updateUIStrings() {\n    var _this = this;\n    var layoutProfile = this.getLayoutProfile();\n\n    var conceptPropsY = _this.model.marker.axis_y.getConceptprops();\n    var conceptPropsX = _this.model.marker.axis_x.getConceptprops();\n    var conceptPropsS = _this.model.marker.size.getConceptprops();\n    var conceptPropsC = _this.model.marker.color.getConceptprops();\n    this.translator = this.model.locale.getTFunction();\n\n    this.strings = {\n      title: {\n        Y: conceptPropsY.name,\n        X: conceptPropsX.name,\n        S: conceptPropsS.name,\n        C: conceptPropsC.name\n      },\n      title_short: {\n        Y: conceptPropsY.name_short,\n        X: conceptPropsX.name_short,\n        S: conceptPropsS.name_short,\n        C: conceptPropsC.name_short\n      },\n      subtitle: {\n        Y: this._getSubtitle(conceptPropsY.name, conceptPropsY.name_short),\n        X: this._getSubtitle(conceptPropsX.name, conceptPropsX.name_short),\n        S: conceptPropsS.name_short,\n        C: conceptPropsC.name_short\n      },\n      unit: {\n        Y: conceptPropsY.unit || \"\",\n        X: conceptPropsX.unit || \"\",\n        S: conceptPropsS.unit || \"\",\n        C: conceptPropsC.unit || \"\"\n      }\n    };\n\n    var ySubTitle = this.ySubTitleEl.selectAll(\"text\").data([0]);\n    ySubTitle.enter().append(\"text\");\n    var xSubTitle = this.xSubTitleEl.selectAll(\"text\").data([0]);\n    xSubTitle.enter().append(\"text\");\n\n    var yTitle = this.yTitleEl.selectAll(\"text\").data([0]);\n    yTitle.enter().append(\"text\");\n    yTitle\n    //.attr(\"y\", \"-6px\")\n    .on(\"click\", function () {\n      _this.parent.findChildByName(\"gapminder-treemenu\").markerID(\"axis_y\").alignX(_this.model.locale.isRTL() ? \"right\" : \"left\").alignY(\"top\").updateView().toggle();\n    });\n\n    var xTitle = this.xTitleEl.selectAll(\"text\").data([0]);\n    xTitle.enter().append(\"text\");\n    xTitle.on(\"click\", function () {\n      _this.parent.findChildByName(\"gapminder-treemenu\").markerID(\"axis_x\").alignX(_this.model.locale.isRTL() ? \"right\" : \"left\").alignY(\"bottom\").updateView().toggle();\n    });\n\n    var sTitle = this.sTitleEl.selectAll(\"text\").data([0]);\n    sTitle.enter().append(\"text\");\n    sTitle.attr(\"text-anchor\", \"end\");\n\n    utils.setIcon(this.dataWarningEl, iconWarn).select(\"svg\").attr(\"width\", \"0px\").attr(\"height\", \"0px\");\n    this.dataWarningEl.append(\"text\").attr(\"text-anchor\", \"end\").text(this.translator(\"hints/dataWarning\"));\n\n    utils.setIcon(this.yInfoEl, iconQuestion).select(\"svg\").attr(\"width\", \"0px\").attr(\"height\", \"0px\").style('opacity', Number(Boolean(conceptPropsY.description || conceptPropsY.sourceLink)));\n\n    utils.setIcon(this.xInfoEl, iconQuestion).select(\"svg\").attr(\"width\", \"0px\").attr(\"height\", \"0px\").style('opacity', Number(Boolean(conceptPropsX.description || conceptPropsX.sourceLink)));\n\n    //TODO: move away from UI strings, maybe to ready or ready once\n    this.yInfoEl.on(\"click\", function () {\n      _this.parent.findChildByName(\"gapminder-datanotes\").pin();\n    });\n    this.yInfoEl.on(\"mouseover\", function () {\n      var rect = this.getBBox();\n      var coord = utils.makeAbsoluteContext(this, this.farthestViewportElement)(rect.x - 10, rect.y + rect.height + 10);\n      var toolRect = _this.root.element.getBoundingClientRect();\n      var chartRect = _this.element.node().getBoundingClientRect();\n      _this.parent.findChildByName(\"gapminder-datanotes\").setHook(\"axis_y\").show().setPos(coord.x + chartRect.left - toolRect.left, coord.y);\n    });\n    this.yInfoEl.on(\"mouseout\", function () {\n      _this.parent.findChildByName(\"gapminder-datanotes\").hide();\n    });\n    this.xInfoEl.on(\"click\", function () {\n      _this.parent.findChildByName(\"gapminder-datanotes\").pin();\n    });\n    this.xInfoEl.on(\"mouseover\", function () {\n      if (_this.model.time.dragging) return;\n      var rect = this.getBBox();\n      var coord = utils.makeAbsoluteContext(this, this.farthestViewportElement)(rect.x - 10, rect.y + rect.height + 10);\n      var toolRect = _this.root.element.getBoundingClientRect();\n      var chartRect = _this.element.node().getBoundingClientRect();\n      _this.parent.findChildByName(\"gapminder-datanotes\").setHook(\"axis_x\").show().setPos(coord.x + chartRect.left - toolRect.left, coord.y);\n    });\n    this.xInfoEl.on(\"mouseout\", function () {\n      if (_this.model.time.dragging) return;\n      _this.parent.findChildByName(\"gapminder-datanotes\").hide();\n    });\n    this.dataWarningEl.on(\"click\", function () {\n      _this.parent.findChildByName(\"gapminder-datawarning\").toggle();\n    }).on(\"mouseover\", function () {\n      _this._updateDoubtOpacity(1);\n    }).on(\"mouseout\", function () {\n      _this._updateDoubtOpacity();\n    });\n  },\n  _updateDoubtOpacity: function _updateDoubtOpacity(opacity) {\n    if (opacity == null) opacity = this.wScale(+this.model.time.formatDate(this.time));\n    if (this.someSelected) opacity = 1;\n    this.dataWarningEl.style(\"opacity\", opacity);\n  },\n\n\n  /*\n   * UPDATE ENTITIES:\n   * Ideally should only update when show parameters change or data changes\n   */\n  updateEntities: function updateEntities() {\n    var _this = this;\n    var dataKeys = this.dataKeys;\n    var KEYS = this.KEYS;\n    var KEY = this.KEY;\n    var TIMEDIM = this.TIMEDIM;\n\n    var getKeys = function getKeys(prefix) {\n      prefix = prefix || \"\";\n      return _this.model.marker.getKeys().map(function (d) {\n        var pointer = Object.assign({}, d);\n        //pointer[KEY] = d[KEY];\n        pointer[TIMEDIM] = endTime;\n        pointer.sortValue = _this.frame.size[utils.getKey(d, dataKeys.size)] || 0;\n        pointer[KEY] = prefix + utils.getKey(d, KEYS);\n        return pointer;\n      }).sort(function (a, b) {\n        return b.sortValue - a.sortValue;\n      });\n    };\n\n    // get array of GEOs, sorted by the size hook\n    // that makes larger bubbles go behind the smaller ones\n    var endTime = this.model.time.end;\n    var markers = getKeys.call(this);\n    this.model.marker.setVisible(markers);\n\n    //unselecting bubbles with no data is used for the scenario when\n    //some bubbles are selected and user would switch indicator.\n    //bubbles would disappear but selection would stay\n    if (!this.model.time.splash) {\n      this.unselectBubblesWithNoData(markers);\n    }\n    this.entityBubbles = this.bubbleContainer.selectAll(\"circle.vzb-bc-entity\").data(this.model.marker.getVisible(), function (d) {\n      return d[KEY];\n    }); // trails have not keys\n\n    //exit selection\n    this.entityBubbles.exit().remove();\n\n    //enter selection -- init circles\n    this.entityBubbles = this.entityBubbles.enter().append(\"circle\").attr(\"class\", function (d) {\n      return \"vzb-bc-entity \" + \"bubble-\" + d[KEY];\n    }).on(\"mouseover\", function (d, i) {\n      if (utils.isTouchDevice() || _this.model.ui.cursorMode !== \"arrow\" && _this.model.ui.cursorMode !== \"hand\") return;\n      _this._bubblesInteract().mouseover(d, i);\n    }).on(\"mouseout\", function (d, i) {\n      if (utils.isTouchDevice() || _this.model.ui.cursorMode !== \"arrow\" && _this.model.ui.cursorMode !== \"hand\") return;\n\n      _this._bubblesInteract().mouseout(d, i);\n    }).on(\"click\", function (d, i) {\n      if (utils.isTouchDevice() || _this.model.ui.cursorMode !== \"arrow\" && _this.model.ui.cursorMode !== \"hand\") return;\n\n      _this._bubblesInteract().click(d, i);\n    }).onTap(function (d, i) {\n      d3.event.stopPropagation();\n      _this._bubblesInteract().click(d, i);\n    }).onLongTap(function (d, i) {}).merge(this.entityBubbles);\n\n    this._reorderEntities();\n  },\n  unselectBubblesWithNoData: function unselectBubblesWithNoData(entities) {\n    var _this = this;\n    var KEYS = this.KEYS;\n    var KEY = this.KEY;\n    if (!this.model.marker.select.length) return;\n\n    var _select = [];\n    var keys = entities.map(function (d) {\n      return d[KEY];\n    });\n\n    this.model.marker.select.forEach(function (d) {\n      if (keys.indexOf(utils.getKey(d, KEYS)) !== -1) _select.push(d);\n    });\n\n    if (_select.length !== _this.model.marker.select.length) _this.model.marker.select = _select;\n  },\n  _reorderEntities: function _reorderEntities() {\n    var _this = this;\n    var dataKeys = this.dataKeys;\n    var KEY = this.KEY;\n    this.bubbleContainer.selectAll(\".vzb-bc-entity\").sort(function (a, b) {\n      var sizeA = _this.frame.size[utils.getKey(a, dataKeys.size)];\n      var sizeB = _this.frame.size[utils.getKey(b, dataKeys.size)];\n\n      if (typeof sizeA === \"undefined\" && typeof sizeB !== \"undefined\") return -1;\n      if (typeof sizeA !== \"undefined\" && typeof sizeB === \"undefined\") return 1;\n      if (sizeA != sizeB) return d3.descending(sizeA, sizeB);\n      if (a[KEY] != b[KEY]) return d3.ascending(a[KEY], b[KEY]);\n      if (typeof a.trailStartTime !== \"undefined\" || typeof b.trailStartTime !== \"undefined\") return typeof a.trailStartTime !== \"undefined\" ? -1 : 1; // only lines has trailStartTime\n      if (typeof a.status !== \"undefined\" || typeof b.status !== \"undefined\") return typeof a.status !== \"undefined\" ? -1 : 1; // only trails has attribute status\n      return d3.descending(sizeA, sizeB);\n    });\n  },\n  _bubblesInteract: function _bubblesInteract() {\n    var _this = this;\n    var KEY = this.KEY;\n    var TIMEDIM = this.TIMEDIM;\n\n    return {\n      mouseover: function mouseover(d, i) {\n        _this.model.marker.highlightMarker(d);\n\n        _this._labels.showCloseCross(d, true);\n      },\n      mouseout: function mouseout(d, i) {\n        _this.model.marker.clearHighlighted();\n\n        _this._labels.showCloseCross(d, false);\n      },\n      click: function click(d, i) {\n        if (_this.draggingNow) return;\n        var isSelected = _this.model.marker.isSelected(d);\n        _this.model.marker.selectMarker(d);\n        //return to highlighted state\n        if (!utils.isTouchDevice()) {\n          if (isSelected) _this.model.marker.highlightMarker(d);\n          _this.highlightDataPoints();\n        }\n      }\n    };\n  },\n\n\n  /*\n   * UPDATE TIME:\n   * Ideally should only update when time or data changes\n   */\n  updateTime: function updateTime() {\n    var _this = this;\n\n    this.time_1 = this.time == null ? this.model.time.value : this.time;\n    this.time = this.model.time.value;\n    this.duration = this.model.time.playing && this.time - this.time_1 > 0 ? this.model.time.delayAnimations : 0;\n    this.year.setText(this.model.time.formatDate(this.time, \"ui\"), this.duration);\n  },\n\n\n  /*\n   * RESIZE:\n   * Executed whenever the container is resized\n   */\n  updateSize: function updateSize() {\n    var chartSvg = this.chartSvg;\n\n    var svgWidth = utils.px2num(chartSvg.style(\"width\"));\n    var svgHeight = utils.px2num(chartSvg.style(\"height\"));\n    var marginScaleH = function marginScaleH(marginMin) {\n      var ratio = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return marginMin + svgHeight * ratio;\n    };\n    var marginScaleW = function marginScaleW(marginMin) {\n      var ratio = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return marginMin + svgWidth * ratio;\n    };\n\n    var profiles = {\n      small: {\n        margin: { top: 30, bottom: 35, left: 30, right: 10 },\n        leftMarginRatio: 1,\n        padding: 2,\n        minRadiusPx: 0.5,\n        maxRadiusEm: this.model.ui.chart.maxRadiusEm || 0.05,\n        infoElHeight: 16,\n        yAxisTitleBottomMargin: 6,\n        xAxisTitleBottomMargin: 4\n      },\n      medium: {\n        margin: { top: 15, bottom: 40, left: 40, right: 15 },\n        leftMarginRatio: 1.6,\n        padding: 2,\n        minRadiusPx: 1,\n        maxRadiusEm: this.model.ui.chart.maxRadiusEm || 0.05,\n        infoElHeight: 20,\n        yAxisTitleBottomMargin: 3,\n        xAxisTitleBottomMargin: 4\n      },\n      large: {\n        margin: { top: 15, bottom: marginScaleH(30, 0.03), left: marginScaleW(31, 0.015), right: 20 },\n        leftMarginRatio: 1.8,\n        padding: 2,\n        minRadiusPx: 1,\n        maxRadiusEm: this.model.ui.chart.maxRadiusEm || 0.05,\n        infoElHeight: 22,\n        yAxisTitleBottomMargin: 3, //marginScaleH(4, 0.01),\n        xAxisTitleBottomMargin: marginScaleH(0, 0.01),\n        hideSTitle: true\n      }\n    };\n\n    var presentationProfileChanges = {\n      medium: {\n        margin: { top: 20, bottom: 55, left: 50, right: 20 },\n        yAxisTitleBottomMargin: 3,\n        xAxisTitleBottomMargin: 4,\n        infoElHeight: 26\n      },\n      large: {\n        margin: { top: 30, bottom: marginScaleH(45, 0.03), left: marginScaleW(35, 0.025), right: 30 },\n        yAxisTitleBottomMargin: 3, //marginScaleH(4, 0.01),\n        xAxisTitleBottomMargin: marginScaleH(-10, 0.01),\n        infoElHeight: 32,\n        hideSTitle: true\n      }\n    };\n\n    var _this = this;\n\n    this.activeProfile = this.getActiveProfile(profiles, presentationProfileChanges);\n    var layoutProfile = this.getLayoutProfile();\n    var containerWH = this.root.getVizWidthHeight();\n    this.activeProfile.maxRadiusPx = Math.max(this.activeProfile.minRadiusPx, this.activeProfile.maxRadiusEm * utils.hypotenuse(containerWH.width, containerWH.height));\n\n    var margin = this.activeProfile.margin;\n    var infoElHeight = this.activeProfile.infoElHeight;\n\n    //labels\n    _this._labels.setCloseCrossHeight(_this.activeProfile.infoElHeight * 1.2);\n    _this._labels.setTooltipFontSize(_this.activeProfile.infoElHeight + \"px\");\n\n    //stage\n    this.height = parseInt(this.element.style(\"height\"), 10) - margin.top - margin.bottom || 0;\n    this.width = parseInt(this.element.style(\"width\"), 10) - margin.left * this.activeProfile.leftMarginRatio - margin.right || 0;\n\n    if (this.height <= 0 || this.width <= 0) {\n      this.height = 0;\n      this.width = 0;\n      utils.warn(\"Bubble chart updateSize(): vizabi container is too little or has display:none\");\n    }\n\n    //graph group is shifted according to margins (while svg element is at 100 by 100%)\n    this.graph.attr(\"transform\", \"translate(\" + margin.left * this.activeProfile.leftMarginRatio + \",\" + margin.top + \")\");\n\n    this.year.resize(this.width, this.height);\n    this.eventArea.attr(\"width\", this.width).attr(\"height\", Math.max(0, this.height));\n\n    //update scales to the new range\n    if (this.model.marker.axis_y.scaleType !== \"ordinal\") {\n      this.yScale.range(this._rangeBump([this.height, 0]));\n    } else {\n      this.yScale.rangePoints([this.height, 0], _this.activeProfile.padding).range();\n    }\n    if (this.model.marker.axis_x.scaleType !== \"ordinal\") {\n      this.xScale.range(this._rangeBump([0, this.width]));\n    } else {\n      this.xScale.rangePoints([0, this.width], _this.activeProfile.padding).range();\n    }\n\n    //apply scales to axes and redraw\n    this.yAxis.scale(this.yScale).tickSizeInner(-this.width).tickSizeOuter(0).tickPadding(6).tickSizeMinor(-this.width, 0).labelerOptions({\n      scaleType: this.model.marker.axis_y.scaleType,\n      toolMargin: margin,\n      limitMaxTickNumber: 6,\n      bump: this.activeProfile.maxRadiusPx / 2,\n      viewportLength: this.height,\n      formatter: this.model.marker.axis_y.getTickFormatter()\n    });\n\n    this.xAxis.scale(this.xScale).tickSizeInner(-this.height).tickSizeOuter(0).tickPadding(6).tickSizeMinor(-this.height, 0).labelerOptions({\n      scaleType: this.model.marker.axis_x.scaleType,\n      toolMargin: margin,\n      bump: this.activeProfile.maxRadiusPx / 2,\n      viewportLength: this.width,\n      formatter: this.model.marker.axis_x.getTickFormatter()\n    });\n\n    this.bubbleContainerCrop.attr(\"width\", this.width).attr(\"height\", Math.max(0, this.height));\n\n    this.labelsContainerCrop.attr(\"width\", this.width).attr(\"height\", Math.max(0, this.height));\n\n    this.xAxisElContainer.attr(\"width\", this.width + 1).attr(\"height\", this.activeProfile.margin.bottom + this.height).attr(\"y\", -1).attr(\"x\", -1);\n    this.xAxisEl.attr(\"transform\", \"translate(1,\" + (1 + this.height) + \")\");\n\n    this.yAxisElContainer.attr(\"width\", this.activeProfile.margin.left + this.width).attr(\"height\", Math.max(0, this.height)).attr(\"x\", -this.activeProfile.margin.left);\n    this.yAxisEl.attr(\"transform\", \"translate(\" + (this.activeProfile.margin.left - 1) + \",\" + 0 + \")\");\n\n    this.yAxisEl.call(this.yAxis);\n    this.xAxisEl.call(this.xAxis);\n\n    this.projectionX.attr(\"y1\", _this.yScale.range()[0] + this.activeProfile.maxRadiusPx / 2);\n    this.projectionY.attr(\"x2\", _this.xScale.range()[0] - this.activeProfile.maxRadiusPx / 2);\n\n    // reduce font size if the caption doesn't fit\n    this._updateSTitle();\n    this.sTitleEl.attr(\"transform\", \"translate(\" + this.width + \",\" + 20 + \") rotate(-90)\");\n\n    if (layoutProfile !== \"small\") {\n      this.ySubTitleEl.select(\"text\").attr(\"dy\", infoElHeight * 0.6).text(this.strings.subtitle.Y);\n      this.xSubTitleEl.select(\"text\").attr(\"dy\", -infoElHeight * 0.3).text(this.strings.subtitle.X);\n\n      this.yTitleEl.select(\"text\").text(this.strings.title_short.Y + \" \").append(\"tspan\").style(\"font-size\", infoElHeight * 0.7 + \"px\").text(\"▼\");\n      this.xTitleEl.select(\"text\").text(this.strings.title_short.X + \" \").append(\"tspan\").style(\"font-size\", infoElHeight * 0.7 + \"px\").text(\"▼\");\n    } else {\n      this.ySubTitleEl.select(\"text\").text(\"\");\n      this.xSubTitleEl.select(\"text\").text(\"\");\n\n      var yTitleText = this.yTitleEl.select(\"text\").text(this.strings.title.Y);\n      if (yTitleText.node().getBBox().width > this.width) yTitleText.text(this.strings.title_short.Y);\n\n      var xTitleText = this.xTitleEl.select(\"text\").text(this.strings.title.X);\n      if (xTitleText.node().getBBox().width > this.width - 100) xTitleText.text(this.strings.title_short.X);\n    }\n\n    var isRTL = this.model.locale.isRTL();\n    this.ySubTitleEl.style(\"font-size\", infoElHeight * 0.8 + \"px\").attr(\"transform\", \"translate(\" + 0 + \",\" + 0 + \") rotate(-90)\");\n    this.xSubTitleEl.style(\"font-size\", infoElHeight * 0.8 + \"px\").attr(\"transform\", \"translate(\" + this.width + \",\" + this.height + \")\");\n\n    this.yTitleEl.style(\"font-size\", infoElHeight + \"px\").attr(\"transform\", layoutProfile !== \"small\" ? \"translate(\" + (-margin.left - this.activeProfile.yAxisTitleBottomMargin) + \",\" + this.height * 0.5 + \") rotate(-90)\" : \"translate(\" + (isRTL ? this.width : 10 - this.activeProfile.margin.left) + \", -\" + this.activeProfile.yAxisTitleBottomMargin + \")\");\n\n    this.xTitleEl.style(\"font-size\", infoElHeight + \"px\").attr(\"transform\", layoutProfile !== \"small\" ? \"translate(\" + this.width * 0.5 + \",\" + (this.height + margin.bottom - this.activeProfile.xAxisTitleBottomMargin) + \")\" : \"translate(\" + (isRTL ? this.width : 0) + \",\" + (this.height + margin.bottom - this.activeProfile.xAxisTitleBottomMargin) + \")\");\n\n    if (this.yInfoEl.select(\"svg\").node()) {\n      var titleBBox = this.yTitleEl.node().getBBox();\n      var t = utils.transform(this.yTitleEl.node());\n      var hTranslate = isRTL ? titleBBox.x + t.translateX - infoElHeight * 1.4 : titleBBox.x + t.translateX + titleBBox.width + infoElHeight * 0.4;\n      var vTranslate = isRTL ? t.translateY + infoElHeight * 1.4 + titleBBox.width * 0.5 : t.translateY - infoElHeight * 0.4 - titleBBox.width * 0.5;\n\n      this.yInfoEl.select(\"svg\").attr(\"width\", infoElHeight + \"px\").attr(\"height\", infoElHeight + \"px\");\n      this.yInfoEl.attr(\"transform\", layoutProfile !== \"small\" ? \"translate(\" + (t.translateX - infoElHeight * 0.8) + \",\" + vTranslate + \") rotate(-90)\" : \"translate(\" + hTranslate + \",\" + (t.translateY - infoElHeight * 0.8) + \")\");\n    }\n\n    if (this.xInfoEl.select(\"svg\").node()) {\n      var _titleBBox = this.xTitleEl.node().getBBox();\n      var _t = utils.transform(this.xTitleEl.node());\n      var _hTranslate = isRTL ? _titleBBox.x + _t.translateX - infoElHeight * 1.4 : _titleBBox.x + _t.translateX + _titleBBox.width + infoElHeight * 0.4;\n\n      this.xInfoEl.select(\"svg\").attr(\"width\", infoElHeight + \"px\").attr(\"height\", infoElHeight + \"px\");\n      this.xInfoEl.attr(\"transform\", \"translate(\" + _hTranslate + \",\" + (_t.translateY - infoElHeight * 0.8) + \")\");\n    }\n\n    this._resizeDataWarning();\n\n    this.model.ui.chart.margin.set(\"left\", margin.left * this.activeProfile.leftMarginRatio, false, false);\n  },\n  _updateLineEqualXY: function _updateLineEqualXY(duration) {\n    var oneMeasure = this.model.marker.axis_x.which == this.model.marker.axis_y.which;\n    this.lineEqualXY.classed(\"vzb-invisible\", !oneMeasure);\n    if (!oneMeasure) return;\n\n    var min = d3.min(this.yScale.domain().concat(this.xScale.domain()));\n    var max = d3.max(this.yScale.domain().concat(this.xScale.domain()));\n\n    this.lineEqualXY.transition().duration(duration || 0).attr(\"y1\", this.yScale(min)).attr(\"y2\", this.yScale(max)).attr(\"x1\", this.xScale(min)).attr(\"x2\", this.xScale(max));\n  },\n  _resizeDataWarning: function _resizeDataWarning() {\n    // reset font size to remove jumpy measurement\n    var dataWarningText = this.dataWarningEl.select(\"text\").style(\"font-size\", null);\n\n    // reduce font size if the caption doesn't fit\n    var dataWarningWidth = dataWarningText.node().getBBox().width + dataWarningText.node().getBBox().height * 3;\n    var remainingWidth = this.width - this.xTitleEl.node().getBBox().width - this.activeProfile.infoElHeight;\n    var font = parseInt(dataWarningText.style(\"font-size\")) * remainingWidth / dataWarningWidth;\n    dataWarningText.style(\"font-size\", dataWarningWidth > remainingWidth ? font + \"px\" : null);\n\n    // position the warning icon\n    var warnBB = dataWarningText.node().getBBox();\n    this.dataWarningEl.select(\"svg\").attr(\"width\", warnBB.height * 0.75).attr(\"height\", warnBB.height * 0.75).attr(\"x\", -warnBB.width - warnBB.height * 1.2).attr(\"y\", -warnBB.height * 0.65);\n\n    this.dataWarningEl.attr(\"transform\", \"translate(\" + (this.model.locale.isRTL() ? warnBB.width + warnBB.height : this.width) + \",\" + (this.height + this.activeProfile.margin.bottom - this.activeProfile.xAxisTitleBottomMargin) + \")\");\n  },\n  updateMarkerSizeLimits: function updateMarkerSizeLimits() {\n    var _this = this;\n    var extent = this.model.marker.size.extent || [0, 1];\n\n    if (!this.activeProfile) return utils.warn(\"updateMarkerSizeLimits() is called before ready(). This can happen if events get unfrozen and getFrame() still didn't return data\");\n\n    var minRadius = this.activeProfile.minRadiusPx;\n    var maxRadius = this.activeProfile.maxRadiusPx;\n\n    var minArea = utils.radiusToArea(Math.max(maxRadius * extent[0], minRadius));\n    var maxArea = utils.radiusToArea(Math.max(maxRadius * extent[1], minRadius));\n\n    var range = minArea === maxArea ? [minArea, maxArea] : d3.range(minArea, maxArea, (maxArea - minArea) / this.sScale.domain().length).concat(maxArea);\n\n    this.sScale.range(range);\n  },\n  redrawDataPointsOnlyColors: function redrawDataPointsOnlyColors() {\n    var _this = this;\n    if (!this.entityBubbles) return utils.warn(\"redrawDataPointsOnlyColors(): no entityBubbles defined. likely a premature call, fix it!\");\n\n    var valuesNow = void 0;\n    var dataKeys = this.dataKeys;\n    var KEYS = this.KEYS;\n    var KEY = this.KEY;\n\n    var time = this.model.time.value;\n\n    if (this.model.ui.chart.lockNonSelected && this.someSelected) {\n      time = this.model.time.parse(\"\" + this.model.ui.chart.lockNonSelected);\n    }\n    this.model.marker.getFrame(time, function (valuesLocked) {\n      if (!_this._frameIsValid(valuesLocked)) return utils.warn(\"redrawDataPointsOnlyColor: empty data received from marker.getFrame(). doing nothing\");\n\n      valuesNow = _this.frame;\n      _this.entityBubbles.each(function (d, index) {\n\n        var selected = _this.model.marker.isSelected(d);\n\n        var valueC = selected ? valuesNow.color[utils.getKey(d, dataKeys.color)] : valuesLocked.color[utils.getKey(d, dataKeys.color)];\n\n        var scaledC = valueC != null ? _this.cScale(valueC) : _this.COLOR_WHITEISH;\n\n        d3.select(this).style(\"fill\", scaledC);\n\n        //update lines of labels\n        if (selected) {\n\n          var select = utils.find(_this.model.marker.select, function (f) {\n            return utils.getKey(f, KEYS) == d[KEY];\n          });\n\n          var trailStartTime = _this.model.time.parse(\"\" + select.trailStartTime);\n\n          _this.model.marker.getFrame(trailStartTime, function (valuesTrailStart) {\n            if (!valuesTrailStart) return utils.warn(\"redrawDataPointsOnlyColor: empty data received from marker.getFrames(). doing nothing\");\n\n            var cache = {};\n            if (!_this.model.ui.chart.trails || trailStartTime - _this.time == 0) {\n              cache.scaledC0 = scaledC;\n            } else {\n              var _valueC = valuesTrailStart.color[utils.getKey(d, dataKeys.color)];\n              cache.scaledC0 = _valueC != null ? _this.cScale(_valueC) : _this.COLOR_WHITEISH;\n            }\n\n            _this._labels.updateLabelOnlyColor(d, index, cache);\n          });\n        }\n      });\n    });\n  },\n  redrawDataPointsOnlySize: function redrawDataPointsOnlySize() {\n    var _this = this;\n\n    var valuesNow = void 0;\n    var dataKeys = this.dataKeys;\n    var KEYS = this.KEYS;\n    var KEY = this.KEY;\n\n    var time = this.model.time.value;\n\n    if (this.model.ui.chart.lockNonSelected && this.someSelected) {\n      time = this.model.time.parse(\"\" + this.model.ui.chart.lockNonSelected);\n    }\n    this.model.marker.getFrame(time, function (valuesLocked) {\n      if (!_this._frameIsValid(valuesLocked)) return utils.warn(\"redrawDataPointsOnlySize: empty data received from marker.getFrame(). doing nothing\");\n\n      valuesNow = _this.frame;\n      _this.entityBubbles.each(function (d, index) {\n\n        var selected = _this.model.marker.isSelected(d);\n\n        var valueS = selected ? valuesNow.size[utils.getKey(d, dataKeys.size)] : valuesLocked.size[utils.getKey(d, dataKeys.size)];\n        if (valueS == null) return;\n\n        var scaledS = utils.areaToRadius(_this.sScale(valueS));\n        d3.select(this).attr(\"r\", scaledS);\n\n        //update lines of labels\n        if (selected) {\n\n          var select = utils.find(_this.model.marker.select, function (f) {\n            return utils.getKey(f, KEYS) == d[KEY];\n          });\n\n          var trailStartTime = _this.model.time.parse(\"\" + select.trailStartTime);\n\n          _this.model.marker.getFrame(trailStartTime, function (valuesTrailStart) {\n            if (!valuesTrailStart) return utils.warn(\"redrawDataPointsOnlySize: empty data received from marker.getFrames(). doing nothing\");\n\n            var cache = {};\n            if (!_this.model.ui.chart.trails || trailStartTime - _this.time == 0) {\n              cache.scaledS0 = scaledS;\n            } else {\n              cache.scaledS0 = utils.areaToRadius(_this.sScale(valuesTrailStart.size[utils.getKey(d, dataKeys.size)]));\n            }\n\n            _this._labels.updateLabelOnlyPosition(d, index, cache);\n          });\n        }\n      });\n    });\n  },\n\n\n  /*\n   * REDRAW DATA POINTS:\n   * Here plotting happens\n   * debouncing to improve performance: events might trigger it more than 1x\n   */\n  redrawDataPoints: function redrawDataPoints(duration) {\n    var _this = this;\n    var KEY = this.KEY;\n    if (duration == null) duration = _this.duration;\n\n    if (this.model.ui.chart.lockNonSelected && this.someSelected) {\n      var time = this.model.time.parse(\"\" + this.model.ui.chart.lockNonSelected);\n\n      //get values for locked frames\n      this.model.marker.getFrame(time, function (lockedFrame) {\n        if (!lockedFrame) return utils.warn(\"redrawDataPoints: empty data received from marker.getFrames(). doing nothing\");\n\n        // each bubble\n        _this.entityBubbles.each(function (d, index) {\n          var frame = _this.model.marker.isSelected(d) ? _this.frame : lockedFrame;\n          _this._updateBubble(d, frame, index, d3.select(this), duration);\n        });\n      });\n    } else {\n      // each bubble\n      _this.entityBubbles.each(function (d, index) {\n        _this._updateBubble(d, _this.frame, index, d3.select(this), duration);\n      });\n    }\n\n    this._updateLineEqualXY(duration);\n  },\n\n\n  //redraw Data Points\n  _updateBubble: function _updateBubble(d, values, index, view, duration) {\n    var _this = this;\n    var dataKeys = this.dataKeys;\n\n    var showhide = false;\n\n    var valueY = values.axis_y[utils.getKey(d, dataKeys.axis_y)];\n    var valueX = values.axis_x[utils.getKey(d, dataKeys.axis_x)];\n    var valueS = values.size[utils.getKey(d, dataKeys.size)];\n    var valueL = values.label[utils.getKey(d, dataKeys.label)];\n    var valueC = values.color[utils.getKey(d, dataKeys.color)];\n    var valueLST = values.size_label[utils.getKey(d, dataKeys.size_label)];\n\n    // check if fetching data succeeded\n    if (!valueL && valueL !== 0 || !valueY && valueY !== 0 || !valueX && valueX !== 0 || !valueS && valueS !== 0) {\n      // if entity is missing data it should hide\n      if (!d.hidden) {\n        d.hidden = true;\n        showhide = true;\n      }\n\n      if (showhide) {\n        if (duration) {\n          var opacity = view.style(\"opacity\");\n          view.transition().duration(duration).ease(d3.easeExp).style(\"opacity\", 0).on(\"end\", function () {\n            //to avoid transition from null state add class with a delay\n            view.classed(\"vzb-invisible\", d.hidden);\n            view.style(\"opacity\", opacity);\n          });\n        } else {\n          //immediately hide the bubble\n          view.classed(\"vzb-invisible\", d.hidden);\n        }\n      }\n    } else {\n      if (d.hidden || view.classed(\"vzb-invisible\")) {\n        d.hidden = false;\n        showhide = true;\n      }\n\n      // if entity has all the data we update the visuals\n      var scaledS = utils.areaToRadius(_this.sScale(valueS));\n\n      view.style(\"fill\", valueC != null ? _this.cScale(valueC) : _this.COLOR_WHITEISH);\n\n      if (duration) {\n        if (showhide) {\n          var _opacity = view.style(\"opacity\");\n          view.classed(\"vzb-invisible\", d.hidden);\n          view.style(\"opacity\", 0).attr(\"cy\", _this.yScale(valueY)).attr(\"cx\", _this.xScale(valueX)).attr(\"r\", scaledS).transition().duration(duration).ease(d3.easeExp).style(\"opacity\", _opacity);\n        } else {\n          view.transition().duration(duration).ease(d3.easeLinear).attr(\"cy\", _this.yScale(valueY)).attr(\"cx\", _this.xScale(valueX)).attr(\"r\", scaledS);\n        }\n      } else {\n\n        //interrupt the ongoing transition and immediately do the visual updates\n        view.interrupt().attr(\"cy\", _this.yScale(valueY)).attr(\"cx\", _this.xScale(valueX)).attr(\"r\", scaledS).transition();\n\n        //show entity if it was hidden\n        if (showhide) view.classed(\"vzb-invisible\", d.hidden);\n      }\n\n      if (this.model.time.record) _this._export.write({\n        type: \"circle\",\n        id: d[KEY],\n        time: this.model.time.value.getUTCFullYear(),\n        fill: valueC != null ? _this.cScale(valueC) : _this.COLOR_WHITEISH,\n        cx: _this.xScale(valueX),\n        cy: _this.yScale(valueY),\n        r: scaledS\n      });\n    } // data exists\n    _this._updateLabel(d, index, values, valueX, valueY, valueS, valueC, valueL, valueLST, duration, showhide);\n  },\n  _updateLabel: function _updateLabel(d, index, values, valueX, valueY, valueS, valueC, valueL, valueLST, duration, showhide) {\n    var _this = this;\n    var KEYS = this.KEYS;\n    var KEY = this.KEY;\n\n    // only for selected markers\n    if (_this.model.marker.isSelected(d)) {\n\n      var cache = {};\n\n      var select = utils.find(_this.model.marker.select, function (f) {\n        return utils.getKey(f, KEYS) == d[KEY];\n      });\n\n      var time = _this.model.time.formatDate(_this.time);\n      if (!this.model.ui.chart.trails || select.trailStartTime == time || select.trailStartTime == null) {\n        if (this.model.ui.chart.trails && select.trailStartTime == null) select.trailStartTime = time; // need only when trailStartTime == null\n\n        cache.labelX0 = valueX;\n        cache.labelY0 = valueY;\n        cache.scaledC0 = valueC != null ? _this.cScale(valueC) : _this.COLOR_WHITEISH, cache.scaledS0 = valueS || valueS === 0 ? utils.areaToRadius(_this.sScale(valueS)) : null;\n      }\n\n      var trailStartTime = _this.model.time.parse(\"\" + select.trailStartTime);\n\n      var labelText = _this._getLabelText(values, this.labelNames, d, select.trailStartTime);\n\n      if (showhide && d.hidden && _this.model.ui.chart.trails && trailStartTime && trailStartTime < _this.time) showhide = false;\n      if (d.hidden && !_this.model.ui.chart.trails) showhide = true;\n\n      this._labels.updateLabel(d, index, cache, valueX, valueY, valueS, valueC, labelText, valueLST, duration, showhide);\n    }\n  },\n  _getLabelText: function _getLabelText(values, labelNames, d, time) {\n    var value = this.KEYS.map(function (key) {\n      return values[labelNames[key]] ? values[labelNames[key]][d[key]] : d[key];\n    }).join(\", \");\n    return value + (time || time === 0 ? \" \" + time : \"\");\n  },\n  _setTooltip: function _setTooltip(tooltipText, x, y, s, c, d) {\n    if (tooltipText) {\n      var labelValues = {};\n      if (d) {\n        var dataKeys = this.dataKeys;\n        var values = this.frame;\n        labelValues.valueY = values.axis_y[utils.getKey(d, dataKeys.axis_y)];\n        labelValues.valueX = values.axis_x[utils.getKey(d, dataKeys.axis_x)];\n        labelValues.valueS = values.size[utils.getKey(d, dataKeys.size)];\n        labelValues.valueC = values.color[utils.getKey(d, dataKeys.color)];\n        labelValues.valueLST = values.size_label[utils.getKey(d, dataKeys.size_label)];\n        labelValues.labelText = this._getLabelText(values, this.labelNames, d, this.model.time.formatDate(this.time));\n      }\n\n      var tooltipCache = {};\n      tooltipCache.labelX0 = this.xScale.invert(x);\n      tooltipCache.labelY0 = this.yScale.invert(y);\n      tooltipCache.scaledS0 = s;\n      tooltipCache.scaledC0 = null;\n\n      this._labels.setTooltip(d, tooltipText, tooltipCache, labelValues);\n    } else {\n      this._labels.setTooltip();\n    }\n  },\n  _formatSTitleValues: function _formatSTitleValues(titleS, titleC) {\n    var _this = this;\n    var unitS = this.strings.unit.S;\n    var unitC = this.strings.unit.C;\n\n    var formatterS = this.model.marker.size.getTickFormatter();\n    var formatterC = this.model.marker.color.getTickFormatter();\n\n    //resolve labels for colors via the color legend\n    if (this.model.marker.color.isDiscrete() && this.model.marker.color.use !== \"constant\" && titleC && this.model.marker.color.getColorlegendMarker()) {\n      titleC = this.model.marker.color.getColorlegendMarker().label.getItems()[titleC] || \"\";\n    }\n\n    return [formatterS(titleS) + \" \" + unitS, titleC || titleC === 0 ? formatterC(titleC) + \" \" + unitC : this.translator(\"hints/nodata\")];\n  },\n  _updateSTitle: function _updateSTitle(titleS, titleC) {\n\n    // vertical text about size and color\n    if (this.activeProfile.hideSTitle && this.model.ui.dialogs.sidebar.indexOf(\"colors\") > -1 && this.model.ui.dialogs.sidebar.indexOf(\"size\") > -1) {\n      this.sTitleEl.classed(\"vzb-invisible\", true);\n      return;\n    }\n    if (this.sTitleEl.classed(\"vzb-invisible\")) {\n      this.sTitleEl.classed(\"vzb-invisible\", false);\n    }\n    var sTitleContentON = this.model.marker.size.use !== \"constant\";\n    var cTitleContentON = this.model.marker.color.use !== \"constant\";\n    var sTitleText = this.sTitleEl.select(\"text\")\n    // reset font size to remove jumpy measurement\n    .style(\"font-size\", null).text((sTitleContentON ? this.translator(\"buttons/size\") + \": \" + (titleS ? titleS : this.strings.title.S) : \"\") + (sTitleContentON && cTitleContentON ? \", \" : \"\") + (cTitleContentON ? this.translator(\"buttons/colors\") + \": \" + (titleC ? titleC : this.strings.title.C) : \"\"));\n    var sTitleWidth = sTitleText.node().getBBox().width;\n    var remainigHeight = this.height - 30;\n    var font = parseInt(sTitleText.style(\"font-size\")) * remainigHeight / sTitleWidth;\n    sTitleText.style(\"font-size\", sTitleWidth > remainigHeight ? font + \"px\" : null);\n  },\n  selectDataPoints: function selectDataPoints() {\n    var _this = this;\n    var KEY = this.KEY;\n\n    if (utils.isTouchDevice()) {\n      _this.model.marker.clearHighlighted();\n      _this._labels.showCloseCross(null, false);\n    } else {\n      //hide tooltip\n      _this._setTooltip();\n      _this._setBubbleCrown();\n    }\n\n    _this.someSelected = _this.model.marker.select.length > 0;\n    _this.nonSelectedOpacityZero = false;\n  },\n  _setBubbleCrown: function _setBubbleCrown(x, y, r, glow, skipInnerFill) {\n    if (x != null) {\n      this.bubbleCrown.classed(\"vzb-hidden\", false);\n      this.bubbleCrown.select(\".vzb-crown\").attr(\"cx\", x).attr(\"cy\", y).attr(\"r\", r).attr(\"fill\", skipInnerFill ? \"none\" : glow);\n      this.bubbleCrown.selectAll(\".vzb-crown-glow\").attr(\"cx\", x).attr(\"cy\", y).attr(\"r\", r + 10).attr(\"stroke\", glow);\n    } else {\n      this.bubbleCrown.classed(\"vzb-hidden\", true);\n    }\n  },\n\n\n  /*\n   * Shows and hides axis projections\n   */\n  _axisProjections: function _axisProjections(d) {\n    var _this = this;\n    var TIMEDIM = this.TIMEDIM;\n    var dataKeys = this.dataKeys;\n\n    if (d != null) {\n\n      this.model.marker.getFrame(d[TIMEDIM], function (values) {\n        var valueY = values.axis_y[utils.getKey(d, dataKeys.axis_y)];\n        var valueX = values.axis_x[utils.getKey(d, dataKeys.axis_x)];\n        var valueS = values.size[utils.getKey(d, dataKeys.size)];\n        var radius = utils.areaToRadius(_this.sScale(valueS));\n\n        if (!valueY && valueY !== 0 || !valueX && valueX !== 0 || !valueS && valueS !== 0) return;\n\n        if (_this.model.ui.chart.whenHovering.showProjectionLineX && _this.xScale(valueX) > 0 && _this.xScale(valueX) < _this.width && _this.yScale(valueY) + radius < _this.height) {\n          _this.projectionX.style(\"opacity\", 1).attr(\"y2\", _this.yScale(valueY) + radius).attr(\"x1\", _this.xScale(valueX)).attr(\"x2\", _this.xScale(valueX));\n        }\n\n        if (_this.model.ui.chart.whenHovering.showProjectionLineY && _this.yScale(valueY) > 0 && _this.yScale(valueY) < _this.height && _this.xScale(valueX) - radius > 0) {\n          _this.projectionY.style(\"opacity\", 1).attr(\"y1\", _this.yScale(valueY)).attr(\"y2\", _this.yScale(valueY)).attr(\"x1\", _this.xScale(valueX) - radius);\n        }\n\n        if (_this.model.ui.chart.whenHovering.higlightValueX) _this.xAxisEl.call(_this.xAxis.highlightValue(valueX));\n\n        if (_this.model.ui.chart.whenHovering.higlightValueY) _this.yAxisEl.call(_this.yAxis.highlightValue(valueY));\n      });\n    } else {\n\n      this.projectionX.style(\"opacity\", 0);\n      this.projectionY.style(\"opacity\", 0);\n      this.xAxisEl.call(this.xAxis.highlightValue(\"none\"));\n      this.yAxisEl.call(this.yAxis.highlightValue(\"none\"));\n    }\n  },\n\n\n  /*\n   * Highlights all hovered bubbles\n   */\n  highlightDataPoints: function highlightDataPoints() {\n    var _this = this;\n    var TIMEDIM = this.TIMEDIM;\n    var dataKeys = this.dataKeys;\n    var KEYS = this.KEYS;\n    var KEY = this.KEY;\n\n    this.someHighlighted = this.model.marker.highlight.length > 0;\n\n    this.updateBubbleOpacity();\n\n    if (this.model.marker.highlight.length === 1) {\n      var d = utils.clone(this.model.marker.highlight[0]);\n      d[KEY] = utils.getKey(d, KEYS);\n\n      if (_this.model.ui.chart.lockNonSelected && _this.someSelected && !_this.model.marker.isSelected(d)) {\n        d[TIMEDIM] = _this.model.time.parse(\"\" + _this.model.ui.chart.lockNonSelected);\n      } else {\n        d[TIMEDIM] = _this.model.time.parse(\"\" + d.trailStartTime) || _this.time;\n      }\n\n      _this.model.marker.getFrame(d[TIMEDIM], function (values) {\n        if (!values) return;\n        var x = _this.xScale(values.axis_x[utils.getKey(d, dataKeys.axis_x)]);\n        var y = _this.yScale(values.axis_y[utils.getKey(d, dataKeys.axis_y)]);\n        var s = utils.areaToRadius(_this.sScale(values.size[utils.getKey(d, dataKeys.size)]));\n        var c = values.color[utils.getKey(d, dataKeys.color)] != null ? _this.cScale(values.color[utils.getKey(d, dataKeys.color)]) : _this.COLOR_WHITEISH;\n        var entityOutOfView = false;\n\n        var titles = _this._formatSTitleValues(values.size[utils.getKey(d, dataKeys.size)], values.color[utils.getKey(d, dataKeys.color)]);\n        _this._updateSTitle(titles[0], titles[1]);\n        if (x + s < 0 || x - s > _this.width || y + s < 0 || y - s > _this.height) {\n          entityOutOfView = true;\n        }\n\n        //show tooltip\n        var text = \"\";\n        var hoverTrail = false;\n        if (_this.model.marker.isSelected(d) && _this.model.ui.chart.trails) {\n          text = _this.model.time.formatDate(_this.time);\n          var _selectedData = utils.find(_this.model.marker.select, function (f) {\n            return utils.getKey(f, KEYS) == d[KEY];\n          });\n          hoverTrail = text !== _selectedData.trailStartTime && !d3.select(d3.event.target).classed(\"bubble-\" + d[KEY]);\n          text = text !== _selectedData.trailStartTime && _this.time === d[TIMEDIM] ? text : \"\";\n        } else {\n          text = _this.model.marker.isSelected(d) ? \"\" : _this._getLabelText(values, _this.labelNames, d);\n        }\n\n        _this._labels.highlight(null, false);\n        _this._labels.highlight(d, true);\n        if (_this.model.marker.isSelected(d)) {\n          var skipCrownInnerFill = !d.trailStartTime || d.trailStartTime == _this.model.time.formatDate(_this.time);\n          _this._setBubbleCrown(x, y, s, c, skipCrownInnerFill);\n        }\n\n        if (!entityOutOfView && !hoverTrail) {\n          _this._axisProjections(d);\n        }\n\n        //set tooltip and show axis projections\n        if (text && !entityOutOfView && !hoverTrail) {\n          _this._setTooltip(text, x, y, s + 3, c, d);\n        }\n\n        var selectedData = utils.find(_this.model.marker.select, function (f) {\n          return utils.getKey(f, KEYS) == d[KEY];\n        });\n        if (selectedData) {\n          var clonedSelectedData = utils.clone(selectedData);\n          //change opacity to OPACITY_HIGHLT = 1.0;\n          clonedSelectedData.opacity = 1.0;\n          _this._trails.run([\"opacityHandler\"], clonedSelectedData);\n        }\n      });\n    } else {\n      this._axisProjections();\n      this._trails.run([\"opacityHandler\"]);\n      //hide tooltip\n      _this._updateSTitle();\n      this._setTooltip();\n      this._setBubbleCrown();\n      this._labels.highlight(null, false);\n    }\n  },\n  _blinkSuperHighlighted: function _blinkSuperHighlighted() {\n    var _this3 = this;\n\n    this.entityBubbles.classed(\"vzb-super-highlighted\", function (d) {\n      return _this3.model.marker.isSuperHighlighted(d);\n    });\n  },\n  updateBubbleOpacity: function updateBubbleOpacity(duration) {\n    var _this = this;\n    //if(!duration)duration = 0;\n\n    var OPACITY_HIGHLT = 1.0;\n    var OPACITY_HIGHLT_DIM = this.model.marker.opacityHighlightDim;\n    var OPACITY_SELECT = 1.0;\n    var OPACITY_REGULAR = this.model.marker.opacityRegular;\n    var OPACITY_SELECT_DIM = this.model.marker.opacitySelectDim;\n\n    this.entityBubbles\n    //.transition().duration(duration)\n    .style(\"opacity\", function (d) {\n\n      if (_this.someHighlighted) {\n        //highlight or non-highlight\n        if (_this.model.marker.isHighlighted(d)) return OPACITY_HIGHLT;\n      }\n\n      if (_this.someSelected) {\n        //selected or non-selected\n        return _this.model.marker.isSelected(d) ? OPACITY_SELECT : OPACITY_SELECT_DIM;\n      }\n\n      if (_this.someHighlighted) return OPACITY_HIGHLT_DIM;\n\n      return OPACITY_REGULAR;\n    });\n\n    var nonSelectedOpacityZero = _this.model.marker.opacitySelectDim < 0.01;\n\n    // when pointer events need update...\n    if (nonSelectedOpacityZero != this.nonSelectedOpacityZero) {\n      this.entityBubbles.style(\"pointer-events\", function (d) {\n        return !_this.someSelected || !nonSelectedOpacityZero || _this.model.marker.isSelected(d) ? \"visible\" : \"none\";\n      });\n    }\n\n    this.nonSelectedOpacityZero = _this.model.marker.opacitySelectDim < 0.01;\n  }\n});\n\nexports.default = BubbleChart;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _Vizabi = Vizabi,\n    utils = _Vizabi.utils;\n\n\nvar PanZoom = Vizabi.Class.extend({\n  init: function init(context) {\n    this.context = context;\n\n    this.dragRectangle = d3.drag();\n    this.zoomer = d3.zoom();\n\n    // this.dragLock = false;\n\n    this.dragRectangle.subject(this.dragSubject()).on(\"start\", this.drag().start).on(\"drag\", this.drag().go).on(\"end\", this.drag().stop);\n\n    this.zoomer.filter(this.zoomFilter()).scaleExtent([0.0625, +Infinity]).on(\"start\", this.zoom().start).on(\"zoom\", this.zoom().go).on(\"end\", this.zoom().stop);\n\n    this.zoomer.ratioX = 1;\n    this.zoomer.ratioY = 1;\n\n    context._zoomedXYMinMax = {\n      axis_x: { zoomedMin: null, zoomedMax: null },\n      axis_y: { zoomedMin: null, zoomedMax: null }\n    };\n  },\n  dragSubject: function dragSubject() {\n    var _this = this.context;\n    var self = this;\n\n    return function (d) {\n      /*\n       * Do not drag if the Ctrl key, Meta key, or plus cursor mode is\n       * not enabled. Also do not drag if zoom-pinching on touchmove\n       * events.\n       */\n      if (!(d3.event.sourceEvent.ctrlKey || d3.event.sourceEvent.metaKey || _this.ui.cursorMode === \"plus\") || _this.ui.cursorMode === \"minus\" || (d3.event.sourceEvent.type === \"touchmove\" || d3.event.sourceEvent.type === \"touchstart\") && (d3.event.sourceEvent.touches.length > 1 || d3.event.sourceEvent.targetTouches.length > 1)) {\n        return null;\n      }\n\n      return {\n        x: d3.mouse(this)[0],\n        y: d3.mouse(this)[1]\n      };\n    };\n  },\n  drag: function drag() {\n    var _this = this.context;\n    var self = this;\n\n    return {\n      start: function start(d, i) {\n        /*\n         * Do not drag if the Ctrl key, Meta key, or plus cursor mode is\n         * not enabled. Also do not drag if zoom-pinching on touchmove\n         * events.\n         */\n        //   if(!(d3.event.sourceEvent.ctrlKey || d3.event.sourceEvent.metaKey ||\n        //          _this.ui.cursorMode === \"plus\") ||\n        //          (d3.event.sourceEvent.type === \"touchmove\" || d3.event.sourceEvent.type === \"touchstart\") &&\n        //          (d3.event.sourceEvent.touches.length > 1 || d3.event.sourceEvent.targetTouches.length > 1)) {\n        //         return;\n        //     }\n\n        // self.dragLock = true;\n        this.origin = {\n          x: d3.mouse(this)[0],\n          y: d3.mouse(this)[1]\n        };\n        _this.zoomRect.classed(\"vzb-invisible\", false);\n      },\n      go: function go(d, i) {\n        /*\n         * Cancel drag if drag lock is false, or when zoom-pinching via\n         * touchmove events.\n         */\n        // if (!self.dragLock || (d3.event.sourceEvent.type === \"touchmove\" || d3.event.sourceEvent.type === \"touchstart\") &&\n        //             (d3.event.sourceEvent.touches.length > 1 || d3.event.sourceEvent.targetTouches.length > 1)) {\n        //   self.dragLock = false;\n\n        //   _this.zoomRect\n        //     .attr(\"width\", 0)\n        //     .attr(\"height\", 0)\n        //     .classed(\"vzb-invisible\", true);\n\n        //   return;\n        // }\n\n        var origin = this.origin;\n        var mouse = {\n          x: d3.event.x,\n          y: d3.event.y\n        };\n\n        _this.zoomRect.attr(\"x\", Math.min(mouse.x, origin.x)).attr(\"y\", Math.min(mouse.y, origin.y)).attr(\"width\", Math.abs(mouse.x - origin.x)).attr(\"height\", Math.abs(mouse.y - origin.y));\n      },\n      stop: function stop(e) {\n        // if (!self.dragLock) return;\n        // self.dragLock = false;\n\n        _this.zoomRect.attr(\"width\", 0).attr(\"height\", 0).classed(\"vzb-invisible\", true);\n\n        this.target = {\n          x: d3.mouse(this)[0],\n          y: d3.mouse(this)[1]\n        };\n        if (Math.abs(this.origin.x - this.target.x) < 10 || Math.abs(this.origin.y - this.target.y) < 10) return;\n\n        /*\n         * Only compensate for dragging when the Ctrl key or Meta key\n         * are pressed, or if the cursorMode is not in plus mode.\n         */\n        var compensateDragging = d3.event.sourceEvent.ctrlKey || d3.event.sourceEvent.metaKey || _this.ui.cursorMode === \"plus\";\n\n        self._zoomOnRectangle(d3.select(this), this.origin.x, this.origin.y, this.target.x, this.target.y, compensateDragging, 500);\n      }\n    };\n  },\n  zoomFilter: function zoomFilter() {\n    var _this = this.context;\n    var self = this;\n\n    return function (d) {\n      var event = d3.event;\n\n      if (event.ctrlKey || event.metaKey) return false;\n\n      // Cancel drag lock when zoom-pinching via touchmove events.\n      if ((event.type === \"touchmove\" || event.type === \"touchstart\") && (event.touches.length > 1 || event.targetTouches.length > 1)) return true;\n\n      if ((event.type === \"wheel\" || event.type === \"mousewheel\") && _this.ui.zoomOnScrolling) {\n        // if (_this.scrollableAncestor) {\n        //   _this.scrollableAncestor.scrollTop -= (event.deltaY || -event.wheelDelta);\n        // }\n        // d3.event.scale = null;\n        //zoomer.scale(this.savedScale);\n        return true;\n      }\n\n      if ((event.type === \"mousedown\" || event.type === \"touchstart\") && _this.ui.cursorMode !== \"plus\" && _this.ui.cursorMode !== \"minus\" && (_this.ui.panWithArrow || _this.ui.cursorMode === \"hand\")) return true;\n\n      return false;\n    };\n  },\n  zoom: function zoom() {\n    var _this = this.context;\n    var zoomer = this.zoomer;\n    var self = this;\n\n    return {\n      start: function start() {\n        //this.savedScale = zoomer.scale;\n        if (_this.ui.cursorMode !== \"plus\" && _this.ui.cursorMode !== \"minus\") {\n          _this.chartSvg.classed(\"vzb-zooming\", true);\n        }\n\n        _this.model._data.marker.clearHighlighted();\n        _this._setTooltip();\n      },\n      go: function go() {\n\n        var sourceEvent = d3.event.sourceEvent;\n\n        //if (sourceEvent != null && (sourceEvent.ctrlKey || sourceEvent.metaKey)) return;\n\n        // Cancel drag lock when zoom-pinching via touchmove events.\n        // if (sourceEvent !== null &&\n        //             (sourceEvent.type === \"touchmove\" || sourceEvent.type === \"touchstart\") &&\n        //             (sourceEvent.touches.length > 1 || sourceEvent.targetTouches.length > 1)) {\n        //   self.dragLock = false;\n        // }\n\n        //if (self.dragLock) return;\n\n        //send the event to the page if fully zoomed our or page not scrolled into view\n        //\n        //                    if(d3.event.scale == 1)\n        //\n        //                    if(utils.getViewportPosition(_this.element.node()).y < 0 && d3.event.scale > 1) {\n        //                        _this.scrollableAncestor.scrollTop += d3.event.sourceEvent.deltaY;\n        //                        return;\n        //                    }\n        /*\n         * Do not zoom on the chart if the scroll event is a wheel\n         * scroll. Instead, redirect the scroll event to the scrollable\n         * ancestor\n         */\n        // if (sourceEvent != null && (sourceEvent.type === \"wheel\" || sourceEvent.type === \"mousewheel\") &&\n        //             !_this.ui.zoomOnScrolling) {\n        //   if (_this.scrollableAncestor) {\n        //     _this.scrollableAncestor.scrollTop += (sourceEvent.deltaY || -sourceEvent.wheelDelta);\n        //   }\n        //   d3.event.scale = null;\n        //             //zoomer.scale(this.savedScale);\n        //   this.quitZoom = true;\n        //   return;\n        // }\n        // this.quitZoom = false;\n\n        //_this.model._data.marker.clearHighlighted();\n        //_this._setTooltip();\n\n        //var transform = d3.zoomTransform(self.zoomSelection.node())\n        //  .translate(, )\n        //.scale(d3.event.transform.k);\n        var zoom = d3.event.transform.k;\n\n        var pan = [d3.event.transform.x, d3.event.transform.y]; //d3.event.translate;\n        var ratioY = zoomer.ratioY;\n        var ratioX = zoomer.ratioX;\n\n        _this.draggingNow = true;\n\n        //value protections and fallbacks\n        if (isNaN(zoom) || zoom == null) zoom = zoomer.scale;\n        if (isNaN(zoom) || zoom == null) zoom = 1;\n\n        //TODO: this is a patch to fix #221. A proper code review of zoom and zoomOnRectangle logic is needed\n        /*\n         * Mouse wheel and touchmove events set the zoom value\n         * independently of axis ratios. If the zoom event was triggered\n         * by a mouse wheel event scrolling down or touchmove event with\n         * more than 1 contact that sets zoom to 1, then set the axis\n         * ratios to 1 as well, which will fully zoom out.\n         */\n        if (zoom === 1 && sourceEvent !== null && ((sourceEvent.type === \"wheel\" || sourceEvent.type === \"mousewheel\") && (sourceEvent.deltaY || -sourceEvent.wheelDelta) > 0 || sourceEvent.type === \"touchmove\" && sourceEvent.touches.length > 1)) {\n          zoomer.ratioX = 1;\n          ratioX = 1;\n          zoomer.ratioY = 1;\n          ratioY = 1;\n        }\n\n        //                if(isNaN(pan[0]) || isNaN(pan[1]) || pan[0] == null || pan[1] == null) pan = zoomer.translate();\n        if (isNaN(pan[0]) || isNaN(pan[1]) || pan[0] == null || pan[1] == null) pan = [0, 0];\n\n        // limit the zooming, so that it never goes below min value of zoom for any of the axes\n        var minZoomScale = zoomer.scaleExtent()[0];\n        if (zoom * ratioY < minZoomScale) {\n          ratioY = minZoomScale / zoom;\n          zoomer.ratioY = ratioY;\n        }\n        if (zoom * ratioX < minZoomScale) {\n          ratioX = minZoomScale / zoom;\n          zoomer.ratioX = ratioX;\n        }\n\n        var zoomXOut = zoom * ratioX < 1;\n        var zoomYOut = zoom * ratioY < 1;\n\n        //limit the panning, so that we are never outside the possible range\n        if (!zoomXOut) {\n          if (pan[0] > 0) pan[0] = 0;\n          if (pan[0] < (1 - zoom * ratioX) * _this.width) pan[0] = (1 - zoom * ratioX) * _this.width;\n        } else {\n          if (pan[0] < 0) pan[0] = 0;\n          if (pan[0] > (1 - zoom * ratioX) * _this.width) pan[0] = (1 - zoom * ratioX) * _this.width;\n        }\n\n        if (!zoomYOut) {\n          if (pan[1] > 0) pan[1] = 0;\n          if (pan[1] < (1 - zoom * ratioY) * _this.height) pan[1] = (1 - zoom * ratioY) * _this.height;\n        } else {\n          if (pan[1] < 0) pan[1] = 0;\n          if (pan[1] > (1 - zoom * ratioY) * _this.height) pan[1] = (1 - zoom * ratioY) * _this.height;\n        }\n\n        //limit zoom translate\n        self.zoomSelection.property(\"__zoom\", d3.zoomIdentity.translate(pan[0], pan[1]).scale(zoom));\n\n        var xPanOffset = _this.width * zoom * ratioX;\n        var yPanOffset = _this.height * zoom * ratioY;\n\n        var xRange = [0 * zoom * ratioX + pan[0], xPanOffset + pan[0]];\n        var yRange = [yPanOffset + pan[1], 0 * zoom * ratioY + pan[1]];\n\n        var xRangeBumped = _this._rangeBump(xRange);\n        var yRangeBumped = _this._rangeBump(yRange);\n\n        /*\n         * Shift xRange and yRange by the difference between the bumped\n         * ranges, which is scaled by the zoom factor. This accounts for\n         * the range bump, which controls a gutter around the\n         * bubblechart, while correctly zooming.\n         */\n        var xRangeMinOffset = (xRangeBumped[0] - xRange[0]) * zoom * ratioX;\n        var xRangeMaxOffset = (xRangeBumped[1] - xRange[1]) * zoom * ratioX;\n\n        var yRangeMinOffset = (yRangeBumped[0] - yRange[0]) * zoom * ratioY;\n        var yRangeMaxOffset = (yRangeBumped[1] - yRange[1]) * zoom * ratioY;\n\n        xRange[0] += xRangeMinOffset;\n        xRange[1] += xRangeMaxOffset;\n\n        yRange[0] += yRangeMinOffset;\n        yRange[1] += yRangeMaxOffset;\n\n        // Calculate the maximum xRange and yRange available.\n        var xRangeBounds = [0, _this.width];\n        var yRangeBounds = [_this.height, 0];\n\n        var xRangeBoundsBumped = _this._rangeBump(xRangeBounds);\n        var yRangeBoundsBumped = _this._rangeBump(yRangeBounds);\n\n        /*\n         * Set the pan to account for the range bump by subtracting\n         * offsets and preventing panning past the range bump gutter.\n         */\n        if (!zoomXOut) {\n          if (xRange[0] > xRangeBoundsBumped[0]) pan[0] = xRangeBoundsBumped[0] - xRangeMinOffset;\n          if (xRange[1] < xRangeBoundsBumped[1]) pan[0] = xRangeBoundsBumped[1] - xRangeMaxOffset - xPanOffset;\n        } else {\n          if (xRange[0] < xRangeBoundsBumped[0]) pan[0] = xRangeBoundsBumped[0] - xRangeMinOffset;\n          if (xRange[1] > xRangeBoundsBumped[1]) pan[0] = xRangeBoundsBumped[1] - xRangeMaxOffset - xPanOffset;\n        }\n\n        if (!zoomYOut) {\n          if (yRange[0] < yRangeBoundsBumped[0]) pan[1] = yRangeBoundsBumped[0] - yRangeMinOffset - yPanOffset;\n          if (yRange[1] > yRangeBoundsBumped[1]) pan[1] = yRangeBoundsBumped[1] - yRangeMaxOffset;\n        } else {\n          if (yRange[0] > yRangeBoundsBumped[0]) pan[1] = yRangeBoundsBumped[0] - yRangeMinOffset - yPanOffset;\n          if (yRange[1] < yRangeBoundsBumped[1]) pan[1] = yRangeBoundsBumped[1] - yRangeMaxOffset;\n        }\n\n        //zoomer.translate = pan;\n        //self.zoomSelection.property(\"__zoom\", d3.zoomIdentity.translate(pan[0], pan[1]).scale(zoom));\n\n        /*\n         * Clamp the xRange and yRange by the amount that the bounds\n         * that are range bumped.\n         *\n         * Additionally, take the amount clamped on the end of the range\n         * and either subtract or add it to the range's other end. This\n         * prevents visible stretching of the range when only panning.\n         */\n        if (!zoomXOut) {\n          if (xRange[0] > xRangeBoundsBumped[0]) {\n            xRange[1] -= Math.abs(xRange[0] - xRangeBoundsBumped[0]);\n            xRange[0] = xRangeBoundsBumped[0];\n          }\n\n          if (xRange[1] < xRangeBoundsBumped[1]) {\n            xRange[0] += Math.abs(xRange[1] - xRangeBoundsBumped[1]);\n            xRange[1] = xRangeBoundsBumped[1];\n          }\n        } else {\n          if (xRange[0] < xRangeBoundsBumped[0]) {\n            xRange[1] += Math.abs(xRange[0] - xRangeBoundsBumped[0]);\n            xRange[0] = xRangeBoundsBumped[0];\n          }\n\n          if (xRange[1] > xRangeBoundsBumped[1]) {\n            xRange[0] -= Math.abs(xRange[1] - xRangeBoundsBumped[1]);\n            xRange[1] = xRangeBoundsBumped[1];\n          }\n        }\n\n        if (!zoomYOut) {\n          if (yRange[0] < yRangeBoundsBumped[0]) {\n            yRange[1] += Math.abs(yRange[0] - yRangeBoundsBumped[0]);\n            yRange[0] = yRangeBoundsBumped[0];\n          }\n\n          if (yRange[1] > yRangeBoundsBumped[1]) {\n            yRange[0] -= Math.abs(yRange[1] - yRangeBoundsBumped[1]);\n            yRange[1] = yRangeBoundsBumped[1];\n          }\n        } else {\n          if (yRange[0] > yRangeBoundsBumped[0]) {\n            yRange[1] -= Math.abs(yRange[0] - yRangeBoundsBumped[0]);\n            yRange[0] = yRangeBoundsBumped[0];\n          }\n\n          if (yRange[1] < yRangeBoundsBumped[1]) {\n            yRange[0] += Math.abs(yRange[1] - yRangeBoundsBumped[1]);\n            yRange[1] = yRangeBoundsBumped[1];\n          }\n        }\n\n        if (_this.model.marker.axis_x.scaleType === \"ordinal\") {\n          _this.xScale.rangeBands(xRange);\n        } else {\n          _this.xScale.range(xRange);\n        }\n\n        if (_this.model.marker.axis_y.scaleType === \"ordinal\") {\n          _this.yScale.rangeBands(yRange);\n        } else {\n          _this.yScale.range(yRange);\n        }\n\n        var formatter = function formatter(n) {\n          return utils.isDate(n) ? n : +n.toFixed(2);\n        };\n\n        var zoomedXRange = xRangeBoundsBumped;\n        var zoomedYRange = yRangeBoundsBumped;\n\n        /*\n         * Set the zoomed min/max to the correct value depending on if the\n         * min/max values lie within the range bound regions.\n         */\n        /*\n         if(!zoomXOut) {\n         zoomedXRange[0] = xRangeBounds[0] > xRange[0] ? xRangeBounds[0] : xRange[0];\n         zoomedXRange[1] = xRangeBounds[1] < xRange[1] ? xRangeBounds[1] : xRange[1];\n         }\n          if(!zoomYOut) {\n         zoomedYRange[0] = yRangeBounds[0] < yRange[0] ? yRangeBounds[0] : yRange[0];\n         zoomedYRange[1] = yRangeBounds[1] > yRange[1] ? yRangeBounds[1] : yRange[1];\n         }\n         */\n\n        _this._zoomedXYMinMax = {\n          axis_x: {\n            zoomedMin: formatter(_this.xScale.invert(zoomedXRange[0])),\n            zoomedMax: formatter(_this.xScale.invert(zoomedXRange[1]))\n          },\n          axis_y: {\n            zoomedMin: formatter(_this.yScale.invert(zoomedYRange[0])),\n            zoomedMax: formatter(_this.yScale.invert(zoomedYRange[1]))\n          }\n        };\n\n        if (!zoomer.dontFeedToState) _this.model.marker.set(_this._zoomedXYMinMax, null, false /*avoid storing it in URL*/);\n\n        var optionsY = _this.yAxis.labelerOptions();\n        var optionsX = _this.xAxis.labelerOptions();\n        optionsY.limitMaxTickNumber = zoom * ratioY < 1.5 ? 8 : zoom * ratioY * 8;\n        optionsX.limitMaxTickNumber = zoom * ratioX < 1.5 ? 8 : zoom * ratioX * 8;\n        optionsY.transitionDuration = zoomer.duration;\n        optionsX.transitionDuration = zoomer.duration;\n\n        _this.xAxisEl.call(_this.xAxis.labelerOptions(optionsX));\n        _this.yAxisEl.call(_this.yAxis.labelerOptions(optionsY));\n        _this.redrawDataPoints(zoomer.duration);\n        _this._trails.run(\"resize\", null, zoomer.duration);\n\n        zoomer.duration = 0;\n      },\n      stop: function stop() {\n        _this.chartSvg.classed(\"vzb-zooming\", false);\n\n        _this.draggingNow = false;\n\n        // if (this.quitZoom) return;\n\n        //Force the update of the URL and history, with the same values\n        if (!zoomer.dontFeedToState) _this.model.marker.set(_this._zoomedXYMinMax, true, true);\n        zoomer.dontFeedToState = null;\n      }\n    };\n  },\n  expandCanvas: function expandCanvas(duration) {\n    var _this = this.context;\n    if (!duration) duration = _this.duration;\n\n    //d3 extent returns min and max of the input array as [min, max]\n    var mmX = d3.extent(utils.values(_this.frame.axis_x));\n    var mmY = d3.extent(utils.values(_this.frame.axis_y));\n\n    //protection agains unreasonable min-max results -- abort function\n    if (!mmX[0] && mmX[0] !== 0 || !mmX[1] && mmX[1] !== 0 || !mmY[0] && mmY[0] !== 0 || !mmY[1] && mmY[1] !== 0) {\n      return utils.warn(\"panZoom.expandCanvas: X or Y min/max are broken. Aborting with no action\");\n    }\n    /*\n     * Use a range bumped scale to correctly accommodate the range bump\n     * gutter.\n     */\n    var suggestedFrame = {\n      x1: _this.xScale(mmX[0]),\n      y1: _this.yScale(mmY[0]),\n      x2: _this.xScale(mmX[1]),\n      y2: _this.yScale(mmY[1])\n    };\n    var xBounds = [0, _this.width];\n    var yBounds = [_this.height, 0];\n\n    // Get the current zoom frame based on the current dimensions.\n    var frame = {\n      x1: xBounds[0],\n      x2: xBounds[1],\n      y1: yBounds[0],\n      y2: yBounds[1]\n    };\n\n    var TOLERANCE = 0.0;\n\n    /*\n     * If there is no current zoom frame, or if any of the suggested frame\n     * points extend outside of the current zoom frame, then expand the\n     * canvas.\n     */\n    if (!_this.isCanvasPreviouslyExpanded || suggestedFrame.x1 < frame.x1 * (1 - TOLERANCE) || suggestedFrame.x2 > frame.x2 * (1 + TOLERANCE) || suggestedFrame.y2 < frame.y2 * (1 - TOLERANCE) || suggestedFrame.y1 > frame.y1 * (1 + TOLERANCE)) {\n      /*\n       * If there is already a zoom frame, then clamp the suggested frame\n       * points to only zoom out and expand the canvas.\n       *\n       * If any of x1, x2, y1, or y2 is within the current frame\n       * boundaries, then clamp them to the frame boundaries. If any of\n       * the above values will translate into a data value that is outside\n       * of the possible data range, then clamp them to the frame\n       * coordinate that corresponds to the maximum data value that can\n       * be displayed.\n       */\n      if (_this.isCanvasPreviouslyExpanded) {\n        /*\n         * Calculate bounds and bumped scale for calculating the data boundaries\n         * to which the suggested frame points need to be clamped.\n         */\n        var xBoundsBumped = _this._rangeBump(xBounds);\n        var yBoundsBumped = _this._rangeBump(yBounds);\n\n        if (suggestedFrame.x1 > xBoundsBumped[0]) suggestedFrame.x1 = xBoundsBumped[0];\n        if (suggestedFrame.x2 < xBoundsBumped[1]) suggestedFrame.x2 = xBoundsBumped[1];\n        if (suggestedFrame.y1 < yBoundsBumped[0]) suggestedFrame.y1 = yBoundsBumped[0];\n        if (suggestedFrame.y2 > yBoundsBumped[0]) suggestedFrame.y2 = yBoundsBumped[1];\n      }\n\n      _this.isCanvasPreviouslyExpanded = true;\n      this._zoomOnRectangle(_this.element, suggestedFrame.x1, suggestedFrame.y1, suggestedFrame.x2, suggestedFrame.y2, false, duration);\n    } else {\n      _this.redrawDataPoints(duration);\n    }\n  },\n  zoomToMaxMin: function zoomToMaxMin(zoomedMinX, zoomedMaxX, zoomedMinY, zoomedMaxY, duration, dontFeedToState) {\n    var _this = this.context;\n    var minX = zoomedMinX;\n    var maxX = zoomedMaxX;\n    var minY = zoomedMinY;\n    var maxY = zoomedMaxY;\n\n    var xDomain = _this.xScale.domain();\n    var yDomain = _this.yScale.domain();\n\n    /*\n     * Prevent zoomout if only one of zoom edges set outside domain\n     */\n    if (minX < xDomain[0] && maxX < xDomain[1]) minX = xDomain[0];\n    if (minX > xDomain[0] && maxX > xDomain[1]) maxX = xDomain[1];\n    if (minY < yDomain[0] && maxY < yDomain[1]) minY = yDomain[0];\n    if (minY > yDomain[0] && maxY > yDomain[1]) maxY = yDomain[1];\n\n    var xRange = [_this.xScale(minX), _this.xScale(maxX)];\n    var yRange = [_this.yScale(minY), _this.yScale(maxY)];\n\n    this._zoomOnRectangle(_this.element, xRange[0], yRange[0], xRange[1], yRange[1], false, duration, dontFeedToState);\n  },\n  _zoomOnRectangle: function _zoomOnRectangle(element, zoomedX1, zoomedY1, zoomedX2, zoomedY2, compensateDragging, duration, dontFeedToState) {\n    var _this = this.context;\n    var zoomer = this.zoomer;\n    var transform = d3.zoomTransform(this.zoomSelection.node());\n\n    var x1 = zoomedX1;\n    var y1 = zoomedY1;\n    var x2 = zoomedX2;\n    var y2 = zoomedY2;\n\n    /*\n     * When dragging to draw a rectangle, the translate vector has (x2 - x1)\n     * added to zoomer.translate()[0], and (y2 - 1) added to\n     * zoomer.translate()[1].\n     *\n     * We need to compensate for this addition when\n     * zooming with a rectangle, because zooming with a rectangle will\n     * update the translate vector with new values based on the rectangle\n     * dimensions.\n     */\n    if (compensateDragging) {\n      transform.translate(x1 - x2, y1 - y2);\n      // zoomer.translate([\n      //     zoomer.translate()[0] + x1 - x2,\n      //     zoomer.translate()[1] + y1 - y2\n      // ]);\n    }\n\n    var xRangeBounds = [0, _this.width];\n    var yRangeBounds = [_this.height, 0];\n\n    var xRangeBoundsBumped = _this._rangeBump(xRangeBounds);\n    var yRangeBoundsBumped = _this._rangeBump(yRangeBounds);\n\n    var minZoom = zoomer.scaleExtent()[0];\n    var maxZoom = zoomer.scaleExtent()[1];\n    var zoom = void 0,\n        ratioX = void 0,\n        ratioY = void 0;\n\n    if (x1 == x2 || y1 == y2 || xRangeBoundsBumped[0] == xRangeBoundsBumped[1] || yRangeBoundsBumped[0] == yRangeBoundsBumped[1]) {\n      return utils.warn(\"_zoomOnRectangle(): can not proceed because this may result in infinity zooms\");\n    }\n\n    if (Math.abs(x1 - x2) > Math.abs(y1 - y2)) {\n      zoom = Math.abs(yRangeBoundsBumped[0] - yRangeBoundsBumped[1]) / Math.abs(y1 - y2) * transform.k;\n\n      /*\n       * Clamp the zoom scalar to the maximum zoom allowed before\n       * calculating the next ratioX and ratioY.\n       */\n      if (zoom < minZoom) {\n        zoomer.ratioY *= zoom / transform.k;\n        zoom = minZoom;\n      }\n      if (zoom > maxZoom) zoom = maxZoom;\n\n      ratioX = Math.abs(xRangeBoundsBumped[0] - xRangeBoundsBumped[1]) / Math.abs(x1 - x2) * transform.k / zoom * zoomer.ratioX;\n      ratioY = zoomer.ratioY;\n    } else {\n      zoom = Math.abs(xRangeBoundsBumped[0] - xRangeBoundsBumped[1]) / Math.abs(x1 - x2) * transform.k;\n\n      /*\n       * Clamp the zoom scalar to the maximum zoom allowed before\n       * calculating the next ratioX and ratioY.\n       */\n      if (zoom < minZoom) {\n        zoomer.ratioX *= zoom / transform.k;\n        zoom = minZoom;\n      }\n      if (zoom > maxZoom) zoom = maxZoom;\n\n      ratioY = Math.abs(yRangeBoundsBumped[0] - yRangeBoundsBumped[1]) / Math.abs(y1 - y2) * transform.k / zoom * zoomer.ratioY;\n      ratioX = zoomer.ratioX;\n    }\n\n    var pan = [(transform.x - Math.min(x1, x2)) / transform.k / zoomer.ratioX * zoom * ratioX + (xRangeBoundsBumped[0] - xRangeBounds[0]), (transform.y - Math.min(y1, y2)) / transform.k / zoomer.ratioY * zoom * ratioY + (yRangeBoundsBumped[1] - yRangeBounds[1])];\n\n    zoomer.dontFeedToState = dontFeedToState;\n    //zoomer.scale(zoom);\n    zoomer.ratioY = ratioY || 1; //NaN defaults to 1\n    zoomer.ratioX = ratioX || 1; //NaN defaults to 1\n    //zoomer.translate(pan);\n    zoomer.duration = duration ? duration : 0;\n\n    //zoomer.event(element);\n    this.zoomSelection.call(zoomer.transform, d3.zoomIdentity.translate(pan[0], pan[1]).scale(zoom));\n  },\n\n\n  /*\n   * Incrementally zoom in or out and pan the view so that it never looses the point where click happened\n   * this function is a modified d3's own zoom behavior on double click\n   * for the original code see https://github.com/mbostock/d3/blob/master/src/behavior/zoom.js\n   * function dblclicked() and what it refers to\n   */\n  zoomByIncrement: function zoomByIncrement(direction, duration) {\n    var _this = this.context;\n    var transform = d3.zoomTransform(this.zoomSelection.node());\n\n    var ratio = transform.k;\n    var pan = [transform.x, transform.y];\n\n    var mouse = d3.mouse(this.zoomSelection.node());\n    var k = Math.log(ratio) / Math.LN2;\n\n    //change factor direction based on the input. default is no direction supplied\n    if (direction == \"plus\" || !direction) k = Math.floor(k) + 1;\n    if (direction == \"minus\") k = Math.ceil(k) - 1;\n\n    //decode panning\n    var locus = [(mouse[0] - pan[0]) / ratio, (mouse[1] - pan[1]) / ratio];\n\n    //recalculate zoom ratio\n    var scaleExtent = this.zoomer.scaleExtent();\n    if (ratio == scaleExtent[0]) {\n      this.zoomer.ratioY = 1;\n      this.zoomer.ratioX = 1;\n    }\n    ratio = Math.max(scaleExtent[0], Math.min(scaleExtent[1], Math.pow(2, k)));\n\n    //recalculate panning\n    locus = [locus[0] * ratio + pan[0], locus[1] * ratio + pan[1]];\n    pan[0] += mouse[0] - locus[0];\n    pan[1] += mouse[1] - locus[1];\n\n    //save changes to the zoom behavior and run the event\n    //this.zoomer.scale(ratio);\n    //this.zoomer.translate([pan[0], pan[1]]);\n    this.zoomer.duration = duration || 0;\n    //this.zoomer.event(_this.element);\n    this.zoomSelection.call(this.zoomer.transform, d3.zoomIdentity.translate(pan[0], pan[1]).scale(ratio));\n  },\n\n\n  /*\n   * Reset zoom values without triggering a zoom event.\n   */\n  resetZoomState: function resetZoomState(element) {\n    //this.zoomer.scaleTo(element, 1);\n    this.zoomer.ratioY = 1;\n    this.zoomer.ratioX = 1;\n    //this.zoomer.translate([0, 0]);\n    (element || this.zoomSelection).property(\"__zoom\", d3.zoomIdentity);\n  },\n  reset: function reset(element, duration) {\n    var _this = this.context;\n    _this.isCanvasPreviouslyExpanded = false;\n\n    //this.zoomer.scale(1);\n    this.zoomer.ratioY = 1;\n    this.zoomer.ratioX = 1;\n    //this.zoomer.translate([0, 0]);\n    this.zoomer.duration = duration || 0;\n    //this.zoomer.event(element || _this.element);\n    (element || this.zoomSelection).call(this.zoomer.transform, d3.zoomIdentity);\n  },\n  rerun: function rerun(element) {\n    var _this = this.context;\n    //this.zoomer.event(element || _this.element);\n    (element || this.zoomSelection).call(this.zoomer.scaleBy, 1);\n  },\n  zoomSelection: function zoomSelection(element) {\n    this.zoomSelection = element;\n  }\n});\n\nexports.default = PanZoom;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _css = __webpack_require__(4);\n\nvar _css2 = _interopRequireDefault(_css);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _Vizabi = Vizabi,\n    utils = _Vizabi.utils;\n\n\nvar Trail = Vizabi.Class.extend({\n  init: function init(context) {\n    this.context = context;\n    this._isCreated = null;\n    this.actionsQueue = {};\n    this.entityTrails = {};\n    this.trailsData = [];\n    this.trailsInProgress = {};\n    this.activePromises = {};\n    this.trailTransitions = {};\n    this.delayedIterations = {};\n    this.drawingQueue = {};\n  },\n  toggle: function toggle(arg) {\n    var _context = this.context;\n    if (arg) {\n\n      _context._trails.create().then(function () {\n        _context._trails.run([\"findVisible\", \"reveal\", \"opacityHandler\"]);\n      });\n    } else {\n      _context._trails.run(\"remove\");\n      _context.model.marker.select.forEach(function (d) {\n        delete d.trailStartTime;\n      });\n    }\n  },\n  create: function create(selection) {\n    var _context = this.context;\n    var _this = this;\n    var KEYS = _context.KEYS;\n    var KEY = _context.KEY;\n    var dataKeys = _context.dataKeys;\n    var TIMEDIM = _context.TIMEDIM;\n    this._isCreated = new Promise(function (resolve, reject) {\n      //quit if the function is called accidentally\n      if (!_context.model.ui.chart.trails) return;\n\n      var timePoints = _context.model.time.getAllSteps();\n\n      //work with marker.select (all selected entities), if no particular selection is specified\n      var promises = [];\n      selection = selection == null ? _context.model.marker.select : [selection];\n      _this._clearActions(selection);\n      _this.trailsData = _context.model.marker.select.map(function (d) {\n        var r = {\n          status: \"created\",\n          selectedEntityData: d\n        };\n        KEYS.forEach(function (key) {\n          return r[key] = d[key];\n        });\n        r[KEY] = utils.getKey(d, KEYS);\n        return r;\n      });\n      _this.trailTransitions = {};\n      var _trails = _context.bubbleContainer.selectAll(\"g.vzb-bc-entity.entity-trail\").data(_this.trailsData, function (d) {\n        return d[KEY];\n      });\n\n      _trails.exit().remove();\n      _trails.enter().insert(\"g\", function (d) {\n        return this.querySelector(\".bubble-\" + (0, _css2.default)(d[KEY]));\n      }).attr(\"class\", function (d) {\n        return \"vzb-bc-entity entity-trail trail-\" + d[KEY];\n      }).merge(_trails).each(function (d, index) {\n        // used for prevent move trail start time forward when we have empty values at end of time range\n        var trail = this;\n        promises.push(new Promise(function (resolve, reject) {\n          var trailSegmentData = timePoints.map(function (m) {\n            return {\n              t: m,\n              key: d[KEY]\n            };\n          });\n          var entityTrails = d3.select(trail).selectAll(\"g\").data(trailSegmentData).classed(\"vzb-invisible\", true);\n\n          entityTrails.exit().remove();\n\n          _this.entityTrails[d[KEY]] = entityTrails.enter().append(\"g\").attr(\"class\", \"vzb-bc-trailsegment vzb-invisible\").on(\"mouseover\", function (segment, index) {\n            if (utils.isTouchDevice()) return;\n\n            var pointer = {};\n            pointer[KEY] = segment.key;\n            pointer[TIMEDIM] = segment.t;\n\n            _context._axisProjections(pointer);\n            _context._labels.highlight(d, true);\n            var text = _context.model.time.formatDate(segment.t);\n            var selectedData = utils.find(_context.model.marker.select, function (f) {\n              return utils.getKey(f, KEYS) == d[KEY];\n            });\n            _context.model.marker.getFrame(pointer[TIMEDIM], function (values) {\n              var x = _context.xScale(values.axis_x[utils.getKey(d, dataKeys.axis_x)]);\n              var y = _context.yScale(values.axis_y[utils.getKey(d, dataKeys.axis_y)]);\n              var s = utils.areaToRadius(_context.sScale(values.size[utils.getKey(d, dataKeys.size)]));\n              var c = values.color[utils.getKey(d, dataKeys.color)] != null ? _context.cScale(values.color[utils.getKey(d, dataKeys.color)]) : _context.COLOR_WHITEISH;\n              if (text !== selectedData.trailStartTime) {\n                _context._setTooltip(text, x, y, s + 3, c);\n              }\n              _context._setBubbleCrown(x, y, s, c);\n              _context.model.marker.getModelObject(\"highlight\").trigger(\"change\", {\n                \"size\": values.size[utils.getKey(d, dataKeys.size)],\n                \"color\": values.color[utils.getKey(d, dataKeys.color)]\n              });\n            });\n            //change opacity to OPACITY_HIGHLT = 1.0;\n            d3.select(this).style(\"opacity\", 1.0);\n          }).on(\"mouseout\", function (segment, index) {\n            if (utils.isTouchDevice()) return;\n            _context._axisProjections();\n            _context._setTooltip();\n            _context._setBubbleCrown();\n            _context._labels.highlight(null, false);\n            _context.model.marker.getModelObject(\"highlight\").trigger(\"change\", null);\n            d3.select(this).style(\"opacity\", _context.model.marker.opacityRegular);\n          }).each(function (segment, index) {\n            var view = d3.select(this);\n            view.append(\"circle\");\n            view.append(\"line\");\n          }).merge(entityTrails);\n          resolve();\n        }));\n      });\n      if (promises.length > 0) {\n        Promise.all(promises).then(function (segments) {\n          resolve(true);\n        });\n      } else {\n        resolve(true);\n      }\n    });\n    return this._isCreated;\n  },\n\n\n  /**\n   * add actions for each selected entities\n   * @param selections\n   * @param actions\n   * @private\n   */\n  _addActions: function _addActions(selections, actions) {\n    var _context = this.context;\n    var _this = this;\n    var KEYS = _context.KEYS;\n\n    selections.forEach(function (d) {\n      var key = utils.getKey(d, KEYS);\n      if (!_this.actionsQueue[key]) _this.actionsQueue[key] = [];\n      _this.actionsQueue[key] = [].concat(_this.actionsQueue[key].filter(function (value) {\n        return actions.indexOf(value) == -1;\n      }), actions);\n    });\n  },\n  _clearActions: function _clearActions(selections) {\n    var _context = this.context;\n    var _this = this;\n    var KEYS = _context.KEYS;\n\n    selections.forEach(function (d) {\n      var key = utils.getKey(d, KEYS);\n      if (!_this.actionsQueue[key]) _this.actionsQueue[key] = [];\n      _this.actionsQueue[key] = [];\n      _this.drawingQueue[key] = {};\n      _this.delayedIterations[key] = {};\n      if (!_this.activePromises[key]) _this.activePromises[key] = [];\n      utils.forEach(_this.activePromises[key], function (promise, key) {\n        if (promise.status === \"pending\") promise.reject();\n      });\n      _this.trailsInProgress[key] = null;\n      _this.activePromises[key] = [];\n    });\n  },\n  _getNextAction: function _getNextAction(key) {\n    return this.actionsQueue[key].shift();\n  },\n  run: function run(actions, selection, duration) {\n    var _context = this.context;\n    var _this = this;\n    var KEY = _context.KEY;\n    if (!this._isCreated || _context.model.time.splash) return;\n    if (typeof actions === \"string\") actions = [actions];\n\n    this._isCreated.then(function () {\n      //quit if function is called accidentally\n      if ((!_context.model.ui.chart.trails || !_context.model.marker.select.length) && actions != \"remove\") return;\n\n      if (!duration) duration = 0;\n\n      //work with marker.select (all selected entities), if no particular selection is specified\n      selection = selection == null ? _context.model.marker.select : [selection];\n      for (var i = 0; i < actions.length; i++) {\n        if ([\"resize\", \"recolor\", \"remove\"].indexOf(actions[i]) != -1) {\n          (function () {\n            var action = actions.splice(i, 1).pop();\n            --i;\n            _this.trailsData.forEach(function (d) {\n              var trail = _this.entityTrails[d[KEY]];\n              _context._trails[\"_\" + action](trail, duration, d);\n            });\n          })();\n        }\n      }\n      if (actions.length == 0) {\n        return;\n      }\n      _this._addActions(selection, actions);\n      _this.trailsData.forEach(function (d) {\n        if (actions.indexOf(\"findVisible\") != -1) {\n          _this.drawingQueue[d[KEY]] = {};\n          _this.delayedIterations[d[KEY]] = {};\n        }\n        var trail = _this.entityTrails[d[KEY]];\n        //do all the actions over \"trail\"\n        var executeSequential = function executeSequential(index) {\n          // some function can be async, but we should run next when previous completed\n          var action = _this._getNextAction(d[KEY]);\n          if (action) {\n            _this.trailsInProgress[d[KEY]] = action;\n            var response = _context._trails[\"_\" + action](trail, duration, d);\n            if (response && response instanceof Promise) {\n              response.then(function () {\n                _this.trailsInProgress[d[KEY]] = null;\n                executeSequential(index + 1);\n              }, function () {\n                _this.trailsInProgress[d[KEY]] = null;\n              });\n            } else {\n              _this.trailsInProgress[d[KEY]] = null;\n              executeSequential(index + 1);\n            }\n          }\n        };\n        if (!_this.trailsInProgress[d[KEY]]) {\n          executeSequential(0);\n        }\n      });\n    });\n  },\n  _remove: function _remove(trail, duration, d) {\n    this.actionsQueue[d[this.context.KEY]] = [];\n    if (trail) {\n      // TODO: in some reason run twice\n      d3.select(this.entityTrails[d[this.context.KEY]].node().parentNode).remove();\n      this.entityTrails[d[this.context.KEY]] = null;\n    }\n  },\n  _resize: function _resize(trail, duration, d) {\n    var _context = this.context;\n    if (_context.model.time.splash) {\n      return;\n    }\n    //    this._isCreated.then(function() {\n    var updateLabel = false;\n\n    trail.each(function (segment, index) {\n\n      if (segment.valueY == null || segment.valueX == null || segment.valueS == null) return;\n\n      var view = d3.select(this);\n      if (duration) {\n        view.select(\"circle\").transition().duration(duration).ease(d3.easeLinear).attr(\"cy\", _context.yScale(segment.valueY)).attr(\"cx\", _context.xScale(segment.valueX)).attr(\"r\", utils.areaToRadius(_context.sScale(segment.valueS)));\n      } else {\n        view.select(\"circle\").interrupt().attr(\"cy\", _context.yScale(segment.valueY)).attr(\"cx\", _context.xScale(segment.valueX)).attr(\"r\", utils.areaToRadius(_context.sScale(segment.valueS))).transition();\n      }\n\n      if (!updateLabel && !segment.transparent) {\n        updateLabel = true;\n        _context._labels.updateLabelOnlyPosition(d, null, { \"scaledS0\": utils.areaToRadius(_context.sScale(segment.valueS)) });\n      }\n\n      if (!segment.next) return;\n      var next = segment.next;\n      if (next == null) return;\n      if (next.valueY == null || next.valueX == null) return;\n\n      var lineLength = Math.sqrt(Math.pow(_context.xScale(segment.valueX) - _context.xScale(next.valueX), 2) + Math.pow(_context.yScale(segment.valueY) - _context.yScale(next.valueY), 2));\n      if (duration) {\n        view.select(\"line\").transition().duration(duration).ease(d3.easeLinear).attr(\"x1\", _context.xScale(next.valueX)).attr(\"y1\", _context.yScale(next.valueY)).attr(\"x2\", _context.xScale(segment.valueX)).attr(\"y2\", _context.yScale(segment.valueY)).attr(\"stroke-dasharray\", lineLength).attr(\"stroke-dashoffset\", utils.areaToRadius(_context.sScale(segment.valueS)));\n      } else {\n        view.select(\"line\").interrupt().attr(\"x1\", _context.xScale(next.valueX)).attr(\"y1\", _context.yScale(next.valueY)).attr(\"x2\", _context.xScale(segment.valueX)).attr(\"y2\", _context.yScale(segment.valueY)).attr(\"stroke-dasharray\", lineLength).attr(\"stroke-dashoffset\", utils.areaToRadius(_context.sScale(segment.valueS))).transition();\n      }\n    });\n  },\n  _recolor: function _recolor(trail, duration, d) {\n    var _context = this.context;\n\n    trail.each(function (segment, index) {\n\n      var view = d3.select(this);\n\n      var strokeColor = _context.model.marker.color.which == \"geo.world_4region\" ?\n      //use predefined shades for color palette for \"geo.world_4region\" (hardcoded)\n      _context.model.marker.color.getColorShade({\n        colorID: segment.valueC,\n        shadeID: \"shade\"\n      }) :\n      //otherwise use color of the bubble with a fallback to bubble stroke color (blackish)\n      segment.valueC != null ? _context.cScale(segment.valueC) : _context.COLOR_BLACKISH;\n\n      view.select(\"circle\")\n      //.transition().duration(duration).ease(d3.easeLinear)\n      .style(\"fill\", segment.valueC != null ? _context.cScale(segment.valueC) : _context.COLOR_WHITEISH);\n      view.select(\"line\")\n      //.transition().duration(duration).ease(d3.easeLinear)\n      .style(\"stroke\", strokeColor);\n    });\n  },\n  _opacityHandler: function _opacityHandler(trail, duration, d) {\n    var _context = this.context;\n\n    trail.each(function (segment, index) {\n\n      var view = d3.select(this);\n\n      view\n      //.transition().duration(duration).ease(d3.easeLinear)\n      .style(\"opacity\", d.opacity || _context.model.marker.opacityRegular);\n    });\n  },\n  _findVisible: function _findVisible(trail, duration, d) {\n    var _context = this.context;\n    var _this = this;\n    var KEY = _context.KEY;\n    var dataKeys = _context.dataKeys;\n    return new Promise(function (resolve, reject) {\n      new Promise(function (resolve1, reject1) {\n        if (!d.limits) {\n          _context.model.marker.getEntityLimits(d[KEY]).then(function (limits) {\n            d.limits = limits;\n            resolve1();\n          });\n        } else {\n          resolve1();\n        }\n      }).then(function () {\n        if (!d.selectedEntityData.trailStartTime) {\n          d.selectedEntityData.trailStartTime = _context.model.time.formatDate(_context.time);\n        }\n        var trailStartTime = _context.model.time.parse(\"\" + d.selectedEntityData.trailStartTime);\n        if (_context.time - trailStartTime < 0 || d.limits.min - trailStartTime > 0) {\n          if (_context.time - trailStartTime < 0) {\n            // move trail start time with trail label back if need\n            d.selectedEntityData.trailStartTime = _context.model.time.formatDate(d3.max([_context.time, d.limits.min]));\n            trailStartTime = _context.model.time.parse(\"\" + d.selectedEntityData.trailStartTime);\n          } else {\n            // move trail start time with trail label to start time if need\n            d.selectedEntityData.trailStartTime = _context.model.time.formatDate(d.limits.min);\n            trailStartTime = _context.model.time.parse(\"\" + d.selectedEntityData.trailStartTime);\n          }\n          var cache = _context._labels.cached[d[KEY]];\n          var valueS = _context.frame.size[utils.getKey(d, dataKeys.size)];\n          var valueC = _context.frame.color[utils.getKey(d, dataKeys.color)];\n          cache.labelX0 = _context.frame.axis_x[utils.getKey(d, dataKeys.axis_x)];\n          cache.labelY0 = _context.frame.axis_y[utils.getKey(d, dataKeys.axis_y)];\n          cache.scaledS0 = valueS || valueS === 0 ? utils.areaToRadius(_context.sScale(valueS)) : null;\n          cache.scaledC0 = valueC != null ? _context.cScale(valueC) : _context.COLOR_WHITEISH;\n          _context._updateLabel(d, 0, _context.frame, cache.labelX0, cache.labelY0, valueS, valueC, _context.frame.label[utils.getKey(d, dataKeys.label)], _context.frame.size_label[utils.getKey(d, dataKeys.size_label)], 0, true);\n        }\n        trail.each(function (segment, index) {\n          // segment is transparent if it is after current time or before trail StartTime\n          var segmentVisibility = segment.transparent;\n          segment.transparent = d.selectedEntityData.trailStartTime == null || segment.t - _context.time > 0 || trailStartTime - segment.t > 0\n          //no trail segment should be visible if leading bubble is shifted backwards, beyond start time\n          || d.selectedEntityData.trailStartTime - _context.model.time.formatDate(_context.time) >= 0;\n          // always update nearest 2 points\n          if (segmentVisibility != segment.transparent || Math.abs(_context.model.time.formatDate(segment.t) - _context.model.time.formatDate(_context.time)) < 2) segment.visibilityChanged = true; // segment changed, so need to update it\n          if (segment.transparent) {\n            d3.select(trail._groups[0][index]).classed(\"vzb-invisible\", segment.transparent);\n          }\n        });\n        _this.drawingQueue[d[KEY]] = {};\n        _this.delayedIterations[d[KEY]] = {};\n        resolve();\n      });\n    });\n  },\n  _abortAnimation: function _abortAnimation() {\n    var _context = this.context;\n    var _this = this;\n    var KEY = _context.KEY;\n    _this.trailsData.forEach(function (d) {\n      if (_this.trailTransitions[d[KEY]]) {\n        _this.trailTransitions[d[KEY]].select(\"line\").interrupt().transition();\n      }\n    });\n  },\n  _reveal: function _reveal(trail, duration, d) {\n    var _context = this.context;\n    if (_context.model.time.playing) duration = _context.model.time.delay;\n    var _this = this;\n    var KEYS = _context.KEYS;\n    var KEY = _context.KEY;\n    var dataKeys = _context.dataKeys;\n    d.status = \"reveal\";\n    var trailStartTime = _context.model.time.parse(\"\" + d.selectedEntityData.trailStartTime);\n    var generateTrailSegment = function generateTrailSegment(trail, index, nextIndex, level) {\n      return new Promise(function (resolve, reject) {\n        var view = d3.select(trail._groups[0][index]);\n\n        var segment = view.datum();\n\n        //console.log(d[KEY] + \" transparent: \" + segment.transparent + \" vis_changed:\" + segment.visibilityChanged);\n        if (nextIndex - index == 1) {\n          if (segment.transparent) {\n            view.classed(\"vzb-invisible\", segment.transparent);\n            return resolve();\n          } else if (!segment.visibilityChanged) {\n            // pass segment if it is not changed\n            return resolve();\n          }\n        }\n        _context.model.marker.getFrame(segment.t, function (frame) {\n          if (d.status != \"reveal\") return resolve();\n          if (!frame) return resolve();\n          segment.valueY = frame.axis_y[utils.getKey(d, dataKeys.axis_y)];\n          segment.valueX = frame.axis_x[utils.getKey(d, dataKeys.axis_x)];\n          segment.valueS = frame.size[utils.getKey(d, dataKeys.size)];\n          segment.valueC = frame.color[utils.getKey(d, dataKeys.color)];\n\n          if (segment.valueY == null || segment.valueX == null || segment.valueS == null) {\n            return resolve();\n          }\n\n          // fix label position if it not in correct place\n          if (trailStartTime && trailStartTime.toString() == segment.t.toString()) {\n            var cache = _context._labels.cached[d[KEY]];\n            cache.labelX0 = segment.valueX;\n            cache.labelY0 = segment.valueY;\n            var valueS = segment.valueS;\n            cache.scaledS0 = valueS || valueS === 0 ? utils.areaToRadius(_context.sScale(valueS)) : null;\n            cache.scaledC0 = segment.valueC != null ? _context.cScale(segment.valueC) : _context.COLOR_WHITEISH;\n            _context._updateLabel(d, index, frame, segment.valueX, segment.valueY, segment.valueS, segment.valueC, frame.label[utils.getKey(d, dataKeys.label)], frame.size_label[utils.getKey(d, dataKeys.size_label)], 0, true);\n          }\n          view.select(\"circle\")\n          //.transition().duration(duration).ease(d3.easeLinear)\n          .attr(\"cy\", _context.yScale(segment.valueY)).attr(\"cx\", _context.xScale(segment.valueX)).attr(\"r\", utils.areaToRadius(_context.sScale(segment.valueS))).style(\"fill\", segment.valueC != null ? _context.cScale(segment.valueC) : _context.COLOR_WHITEISH);\n\n          view.select(\"line\").attr(\"x2\", _context.xScale(segment.valueX)).attr(\"y2\", _context.yScale(segment.valueY)).attr(\"x1\", _context.xScale(segment.valueX)).attr(\"y1\", _context.yScale(segment.valueY));\n\n          // last point should have data for line but it is invisible\n          if (_context.time - segment.t > 0) {\n            segment.visibilityChanged = false;\n            view.classed(\"vzb-invisible\", segment.transparent);\n          } else {\n            view.classed(\"vzb-invisible\", true);\n          }\n\n          if (!trail._groups[0][nextIndex] || _context.time.toString() == segment.t.toString()) {\n            return resolve();\n          }\n\n          var next = d3.select(trail._groups[0][nextIndex]);\n          var nextSegment = next.datum();\n          nextSegment.previous = segment;\n          segment.next = nextSegment;\n          var nextTime = nextSegment.t;\n          if (_context.time - nextSegment.t < 0) {\n            // time is not equal start of year\n            segment.visibilityChanged = true; // redraw needed next time because line not have full length\n            nextTime = _context.time;\n          }\n          _context.model.marker.getFrame(nextTime, function (nextFrame) {\n            if (d.status != \"reveal\") return resolve();\n            if (!nextFrame || segment.valueY == null || segment.valueX == null || segment.valueS == null) {\n              return resolve();\n            }\n\n            if (nextFrame.axis_x[utils.getKey(d, dataKeys.axis_x)] == null || nextFrame.axis_y[utils.getKey(d, dataKeys.axis_y)] == null) {\n              return resolve();\n            }\n\n            nextSegment.valueY = nextFrame.axis_y[utils.getKey(d, dataKeys.axis_y)];\n            nextSegment.valueX = nextFrame.axis_x[utils.getKey(d, dataKeys.axis_x)];\n            nextSegment.valueS = nextFrame.size[utils.getKey(d, dataKeys.size)];\n            nextSegment.valueC = nextFrame.color[utils.getKey(d, dataKeys.color)];\n\n            _this.trailTransitions[d[KEY]] = view;\n            var strokeColor = _context.model.marker.color.which == \"geo.world_4region\" ?\n            //use predefined shades for color palette for \"geo.world_4region\" (hardcoded)\n            _context.model.marker.color.getColorShade({\n              colorID: segment.valueC,\n              shadeID: \"shade\"\n            }) :\n            //otherwise use color of the bubble with a fallback to bubble stroke color (blackish)\n            segment.valueC != null ? _context.cScale(segment.valueC) : _context.COLOR_BLACKISH;\n\n            var lineLength = Math.sqrt(Math.pow(_context.xScale(segment.valueX) - _context.xScale(nextSegment.valueX), 2) + Math.pow(_context.yScale(segment.valueY) - _context.yScale(nextSegment.valueY), 2));\n            view.select(\"line\").attr(\"stroke-dasharray\", lineLength).attr(\"stroke-dashoffset\", utils.areaToRadius(_context.sScale(segment.valueS))).style(\"stroke\", strokeColor).transition().duration(duration).ease(d3.easeLinear).attr(\"x1\", _context.xScale(nextSegment.valueX)).attr(\"y1\", _context.yScale(nextSegment.valueY)).attr(\"x2\", _context.xScale(segment.valueX)).attr(\"y2\", _context.yScale(segment.valueY));\n            if (nextIndex - index > 1) {\n              addNewIntervals(index, nextIndex);\n              return resolve();\n            }\n            return resolve();\n          });\n        });\n      });\n    };\n    var addPointBetween = function addPointBetween(previousIndex, nextIndex, index) {\n      return new Promise(function (resolve, reject) {\n        var previous = d3.select(trail._groups[0][previousIndex]);\n        var next = d3.select(trail._groups[0][nextIndex]);\n        var view = d3.select(trail._groups[0][index]);\n        var previousSegment = previous.datum();\n        var nextSegment = next.datum();\n        var segment = view.datum();\n\n        if (!previousSegment.previous && !previousSegment.next || !nextSegment.previous && !nextSegment.next) {\n          // segment data cleared by create action\n          return resolve();\n        }\n\n        _context.model.marker.getFrame(segment.t, function (frame) {\n          if (d.status != \"reveal\") return resolve();\n          if (!frame || typeof frame.axis_x === \"undefined\" || frame.axis_x[utils.getKey(d, dataKeys.axis_x)] == null || typeof frame.axis_y === \"undefined\" || frame.axis_y[utils.getKey(d, dataKeys.axis_y)] == null) {\n            utils.warn(\"Frame for trail missed: \" + segment.t);\n            return resolve();\n          }\n          segment.valueY = frame.axis_y[utils.getKey(d, dataKeys.axis_y)];\n          segment.valueX = frame.axis_x[utils.getKey(d, dataKeys.axis_x)];\n          segment.valueS = frame.size[utils.getKey(d, dataKeys.size)];\n          segment.valueC = frame.color[utils.getKey(d, dataKeys.color)];\n\n          segment.previous = previousSegment;\n          segment.next = nextSegment;\n          previousSegment.next = segment;\n          nextSegment.previous = segment;\n\n          if (segment.valueY == null || segment.valueX == null || segment.valueS == null) {\n            utils.warn(\"Data for trail point missed: \" + segment.t);\n            return resolve();\n          }\n\n          var strokeColor = _context.model.marker.color.which == \"geo.world_4region\" ?\n          //use predefined shades for color palette for \"geo.world_4region\" (hardcoded)\n          _context.model.marker.color.getColorShade({\n            colorID: segment.valueC,\n            shadeID: \"shade\"\n          }) :\n          //otherwise use color of the bubble with a fallback to bubble stroke color (blackish)\n          segment.valueC != null ? _context.cScale(segment.valueC) : _context.COLOR_BLACKISH;\n\n          var firstLineLength = Math.sqrt(Math.pow(_context.xScale(previousSegment.valueX) - _context.xScale(segment.valueX), 2) + Math.pow(_context.yScale(previousSegment.valueY) - _context.yScale(segment.valueX), 2));\n\n          previous.select(\"line\").transition().duration(duration).ease(d3.easeLinear).attr(\"x1\", _context.xScale(segment.valueX)).attr(\"y1\", _context.yScale(segment.valueY)).attr(\"x2\", _context.xScale(previousSegment.valueX)).attr(\"y2\", _context.yScale(previousSegment.valueY)).attr(\"stroke-dasharray\", firstLineLength).attr(\"stroke-dashoffset\", utils.areaToRadius(_context.sScale(previousSegment.valueS))).style(\"stroke\", strokeColor);\n\n          view.classed(\"vzb-invisible\", segment.transparent);\n\n          if (!segment.transparent) {\n            view.select(\"circle\")\n            //.transition().duration(duration).ease(d3.easeLinear)\n            .attr(\"cy\", _context.yScale(segment.valueY)).attr(\"cx\", _context.xScale(segment.valueX)).attr(\"r\", utils.areaToRadius(_context.sScale(segment.valueS))).style(\"fill\", segment.valueC != null ? _context.cScale(segment.valueC) : _context.COLOR_WHITEISH);\n\n            var secondLineLength = Math.sqrt(Math.pow(_context.xScale(segment.valueX) - _context.xScale(nextSegment.valueX), 2) + Math.pow(_context.yScale(segment.valueY) - _context.yScale(nextSegment.valueY), 2));\n\n            view.select(\"line\").transition().duration(duration).ease(d3.easeLinear).attr(\"x1\", _context.xScale(nextSegment.valueX)).attr(\"y1\", _context.yScale(nextSegment.valueY)).attr(\"x2\", _context.xScale(segment.valueX)).attr(\"y2\", _context.yScale(segment.valueY)).attr(\"stroke-dasharray\", secondLineLength).attr(\"stroke-dashoffset\", utils.areaToRadius(_context.sScale(segment.valueS))).style(\"stroke\", strokeColor);\n          }\n          addNewIntervals(previousIndex, index, nextIndex);\n          resolve();\n        });\n      });\n    };\n    var addNewIntervals = function addNewIntervals(previousIndex, index, nextIndex) {\n      var mediumIndex = void 0;\n      if (index - previousIndex > 1) {\n        mediumIndex = getPointBetween(previousIndex, index);\n        _this.delayedIterations[d[KEY]][previousIndex] = {\n          first: previousIndex,\n          next: index,\n          medium: mediumIndex\n        };\n      }\n      if (nextIndex && nextIndex - index > 1) {\n        mediumIndex = getPointBetween(index, nextIndex);\n        _this.delayedIterations[d[KEY]][index] = {\n          first: index,\n          next: nextIndex,\n          medium: mediumIndex\n        };\n      }\n    };\n    var getPointBetween = function getPointBetween(previous, next) {\n      return Math.round(previous + (next - previous) / 2);\n    };\n\n    var _generateKeys = function _generateKeys(d, trail, div) {\n      var response = [];\n      var min = 0,\n          max = 0;\n      var maxValue = d3.min([d.limits.max, _context.time]);\n      var minValue = d3.max([d.limits.min, _context.model.time.parse(\"\" + d.selectedEntityData.trailStartTime)]);\n      utils.forEach(trail._groups[0], function (segment, index) {\n        var data = segment.__data__;\n        if (data.t - minValue == 0) {\n          min = index;\n        } else if (data.t - maxValue == 0) {\n          max = index;\n        } else {\n          if (data.t > minValue && data.t < maxValue) {\n            if (_context.model.time.formatDate(data.t) % div == 0 || data.next && data.previous) {\n              response.push(index);\n            }\n          }\n        }\n      });\n      response.unshift(min);\n      if (max > 0) {\n        response.push(max);\n      }\n      return response;\n    };\n\n    var processPoints = function processPoints() {\n      return new Promise(function (resolve, reject) {\n        var processPoint = function processPoint() {\n          var pointIndex = Object.keys(_this.drawingQueue[d[KEY]])[Math.floor(Math.random() * Object.keys(_this.drawingQueue[d[KEY]]).length)];\n          var point = JSON.parse(JSON.stringify(_this.drawingQueue[d[KEY]][pointIndex]));\n          delete _this.drawingQueue[d[KEY]][pointIndex];\n          addPointBetween(point.first, point.next, point.medium).then(function () {\n            if (Object.keys(_this.drawingQueue[d[KEY]]).length > 0) {\n              processPoint();\n            } else {\n              resolve();\n            }\n          });\n        };\n        if (Object.keys(_this.drawingQueue[d[KEY]]).length > 0) {\n          processPoint(_this.drawingQueue[d[KEY]]);\n        } else {\n          resolve();\n        }\n      });\n    };\n\n    return new Promise(function (resolve, reject) {\n      /**\n       * iteration for each point from first segment to last\n       * @param trail\n       * @param index\n       */\n      var generateTrails = function generateTrails(trail, index) {\n        if (index < 0 || index >= trail._groups[0].length) {\n          return resolve();\n        }\n        generateTrailSegment(trail, index, index + 1).then(function () {\n          generateTrails(trail, index + 1);\n        }, function () {\n          return resolve();\n        });\n      };\n\n      /**\n       * recursive iteration for drawing point between points calculated in previous step\n       */\n      var processPointsBetween = function processPointsBetween() {\n        processPoints().then(function () {\n          if (Object.keys(_this.delayedIterations[d[KEY]]).length == 0) {\n            return resolve();\n          }\n          _this.drawingQueue[d[KEY]] = _this.delayedIterations[d[KEY]];\n          _this.delayedIterations[d[KEY]] = {};\n          processPointsBetween();\n        }, function () {\n          return resolve();\n        });\n      };\n\n      if (_context.model.marker.framesAreReady()) {\n        generateTrails(trail, 0);\n      } else {\n        _this.delayedIterations[d[KEY]] = {};\n        _this.drawingQueue[d[KEY]] = {};\n        var trailKeys = _generateKeys(d, trail, 50);\n        var segments = [];\n        if (trailKeys.length <= 1) {\n          return resolve();\n        }\n\n        _this.delayedIterations[d[KEY]] = {};\n        for (var i = 0; i < trailKeys.length - 1; i++) {\n          segments.push(generateTrailSegment(trail, trailKeys[i], trailKeys[i + 1], 1));\n        }\n        Promise.all(segments).then(function () {\n          if (Object.keys(_this.delayedIterations[d[KEY]]).length == 0) {\n            resolve();\n          } else {\n            _this.drawingQueue[d[KEY]] = _this.delayedIterations[d[KEY]];\n            _this.delayedIterations[d[KEY]] = {};\n            processPointsBetween();\n          }\n        }, function () {\n          resolve();\n        });\n      }\n    });\n  }\n});\n\nexports.default = Trail;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {/*! https://mths.be/cssescape v1.5.1 by @mathias | MIT license */\n;(function(root, factory) {\n\t// https://github.com/umdjs/umd/blob/master/returnExports.js\n\tif (true) {\n\t\t// For Node.js.\n\t\tmodule.exports = factory(root);\n\t} else if (typeof define == 'function' && define.amd) {\n\t\t// For AMD. Register as an anonymous module.\n\t\tdefine([], factory.bind(root, root));\n\t} else {\n\t\t// For browser globals (not exposing the function separately).\n\t\tfactory(root);\n\t}\n}(typeof global != 'undefined' ? global : this, function(root) {\n\n\tif (root.CSS && root.CSS.escape) {\n\t\treturn root.CSS.escape;\n\t}\n\n\t// https://drafts.csswg.org/cssom/#serialize-an-identifier\n\tvar cssEscape = function(value) {\n\t\tif (arguments.length == 0) {\n\t\t\tthrow new TypeError('`CSS.escape` requires an argument.');\n\t\t}\n\t\tvar string = String(value);\n\t\tvar length = string.length;\n\t\tvar index = -1;\n\t\tvar codeUnit;\n\t\tvar result = '';\n\t\tvar firstCodeUnit = string.charCodeAt(0);\n\t\twhile (++index < length) {\n\t\t\tcodeUnit = string.charCodeAt(index);\n\t\t\t// Note: there’s no need to special-case astral symbols, surrogate\n\t\t\t// pairs, or lone surrogates.\n\n\t\t\t// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER\n\t\t\t// (U+FFFD).\n\t\t\tif (codeUnit == 0x0000) {\n\t\t\t\tresult += '\\uFFFD';\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\t// If the character is in the range [\\1-\\1F] (U+0001 to U+001F) or is\n\t\t\t\t// U+007F, […]\n\t\t\t\t(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||\n\t\t\t\t// If the character is the first character and is in the range [0-9]\n\t\t\t\t// (U+0030 to U+0039), […]\n\t\t\t\t(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||\n\t\t\t\t// If the character is the second character and is in the range [0-9]\n\t\t\t\t// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]\n\t\t\t\t(\n\t\t\t\t\tindex == 1 &&\n\t\t\t\t\tcodeUnit >= 0x0030 && codeUnit <= 0x0039 &&\n\t\t\t\t\tfirstCodeUnit == 0x002D\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\t// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point\n\t\t\t\tresult += '\\\\' + codeUnit.toString(16) + ' ';\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\t// If the character is the first character and is a `-` (U+002D), and\n\t\t\t\t// there is no second character, […]\n\t\t\t\tindex == 0 &&\n\t\t\t\tlength == 1 &&\n\t\t\t\tcodeUnit == 0x002D\n\t\t\t) {\n\t\t\t\tresult += '\\\\' + string.charAt(index);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If the character is not handled by one of the above rules and is\n\t\t\t// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or\n\t\t\t// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to\n\t\t\t// U+005A), or [a-z] (U+0061 to U+007A), […]\n\t\t\tif (\n\t\t\t\tcodeUnit >= 0x0080 ||\n\t\t\t\tcodeUnit == 0x002D ||\n\t\t\t\tcodeUnit == 0x005F ||\n\t\t\t\tcodeUnit >= 0x0030 && codeUnit <= 0x0039 ||\n\t\t\t\tcodeUnit >= 0x0041 && codeUnit <= 0x005A ||\n\t\t\t\tcodeUnit >= 0x0061 && codeUnit <= 0x007A\n\t\t\t) {\n\t\t\t\t// the character itself\n\t\t\t\tresult += string.charAt(index);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Otherwise, the escaped character.\n\t\t\t// https://drafts.csswg.org/cssom/#escape-a-character\n\t\t\tresult += '\\\\' + string.charAt(index);\n\n\t\t}\n\t\treturn result;\n\t};\n\n\tif (!root.CSS) {\n\t\troot.CSS = {};\n\t}\n\n\troot.CSS.escape = cssEscape;\n\treturn cssEscape;\n\n}));\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports) {\n\n// removed by extract-text-webpack-plugin\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports) {\n\nmodule.exports = \"<!-- Bubble Chart Component -->\\n<div class=\\\"vzb-bubblechart\\\">\\n    <svg class=\\\"vzb-bubblechart-svg vzb-export\\\">\\n        <g class=\\\"vzb-bc-graph\\\">\\n            <g class=\\\"vzb-bc-year\\\"></g>\\n\\n            <svg class=\\\"vzb-bc-axis-x\\\"><g></g></svg>\\n            <svg class=\\\"vzb-bc-axis-y\\\"><g></g></svg>\\n            <line class=\\\"vzb-bc-projection-x\\\"></line>\\n            <line class=\\\"vzb-bc-projection-y\\\"></line>\\n\\n            <svg class=\\\"vzb-bc-bubbles-crop\\\">\\n                <g class=\\\"vzb-zoom-selection\\\"></g>\\n                <line class=\\\"vzb-bc-line-equal-xy vzb-invisible\\\"></line>\\n                <rect class=\\\"vzb-bc-eventarea\\\"></rect>\\n                <g class=\\\"vzb-bc-trails\\\"></g>\\n                <g class=\\\"vzb-bc-bubbles\\\"></g>\\n                <g class=\\\"vzb-bc-lines\\\"></g>\\n                <g class=\\\"vzb-bc-bubble-crown vzb-hidden\\\">\\n                    <circle class=\\\"vzb-crown-glow\\\"></circle>\\n                    <circle class=\\\"vzb-crown\\\"></circle>\\n                </g>\\n            </svg>\\n\\n            <g class=\\\"vzb-bc-axis-y-subtitle\\\"></g>\\n            <g class=\\\"vzb-bc-axis-x-subtitle\\\"></g>\\n            <g class=\\\"vzb-bc-axis-y-title\\\"></g>\\n            <g class=\\\"vzb-bc-axis-x-title\\\"></g>\\n            <g class=\\\"vzb-bc-axis-s-title\\\"></g>\\n            <g class=\\\"vzb-bc-axis-c-title\\\"></g>\\n\\n            <g class=\\\"vzb-bc-axis-y-info vzb-noexport\\\"></g>\\n            <g class=\\\"vzb-bc-axis-x-info vzb-noexport\\\"></g>\\n\\n            <svg class=\\\"vzb-bc-labels-crop\\\">\\n                <g class=\\\"vzb-bc-labels\\\"></g>\\n            </svg>\\n\\n            <g class=\\\"vzb-data-warning vzb-noexport\\\">\\n                <svg></svg>\\n                <text></text>\\n            </g>\\n\\n            <rect class=\\\"vzb-bc-zoom-rect\\\"></rect>\\n        </g>\\n    </svg>\\n    <svg>\\n        <defs>\\n            <filter id=\\\"vzb-glow-filter\\\" x=\\\"-50%\\\" y=\\\"-50%\\\" width=\\\"200%\\\" height=\\\"200%\\\">\\n                <feGaussianBlur in=\\\"SourceGraphic\\\" stdDeviation=\\\"2\\\"></feGaussianBlur>\\n            </filter>\\n        </defs>\\n    </svg>\\n    <!-- This could possibly be another component -->\\n    <div class=\\\"vzb-tooltip vzb-hidden vzb-tooltip-mobile\\\"></div>\\n</div>\\n\";\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(0);\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// bubblechart.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 8);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap a3ba207206a2ace5a77e","import \"./styles.scss\";\nimport component from \"./component\";\n\nconst VERSION_INFO = { version: __VERSION, build: __BUILD };\n\nexport default Vizabi.Tool.extend(\"BubbleChart\", {\n\n  /**\n   * Initializes the tool (Bubble Chart Tool).\n   * Executed once before any template is rendered.\n   * @param {Object} placeholder Placeholder element for the tool\n   * @param {Object} external_model Model as given by the external page\n   */\n  init(placeholder, external_model) {\n\n    this.name = \"bubblechart\";\n\n    //specifying components\n    this.components = [{\n      component,\n      placeholder: \".vzb-tool-viz\",\n      model: [\"state.time\", \"state.marker\", \"locale\", \"ui\"] //pass models to component\n    }, {\n      component: Vizabi.Component.get(\"timeslider\"),\n      placeholder: \".vzb-tool-timeslider\",\n      model: [\"state.time\", \"state.marker\", \"ui\"]\n    }, {\n      component: Vizabi.Component.get(\"dialogs\"),\n      placeholder: \".vzb-tool-dialogs\",\n      model: [\"state\", \"ui\", \"locale\"]\n    }, {\n      component: Vizabi.Component.get(\"buttonlist\"),\n      placeholder: \".vzb-tool-buttonlist\",\n      model: [\"state\", \"ui\", \"locale\"]\n    }, {\n      component: Vizabi.Component.get(\"treemenu\"),\n      placeholder: \".vzb-tool-treemenu\",\n      model: [\"state.marker\", \"state.marker_tags\", \"state.time\", \"locale\"]\n    }, {\n      component: Vizabi.Component.get(\"datawarning\"),\n      placeholder: \".vzb-tool-datawarning\",\n      model: [\"locale\"]\n    }, {\n      component: Vizabi.Component.get(\"datanotes\"),\n      placeholder: \".vzb-tool-datanotes\",\n      model: [\"state.marker\", \"locale\"]\n    }, {\n      component: Vizabi.Component.get(\"steppedspeedslider\"),\n      placeholder: \".vzb-tool-stepped-speed-slider\",\n      model: [\"state.time\", \"locale\"]\n    }];\n\n    this._super(placeholder, external_model);\n\n  },\n\n  validate(model) {\n    model = this.model || model;\n\n    this._super(model);\n\n    if (model.ui.chart.lockNonSelected && (!model.ui.splash || model.state.time.splash === false)) {\n      const time = model.state.time.parse(\"\" + model.ui.chart.lockNonSelected);\n      if (time < model.state.time.start) model.ui.chart.lockNonSelected = model.state.time.formatDate(model.state.time.start);\n      if (time > model.state.time.end) model.ui.chart.lockNonSelected = model.state.time.formatDate(model.state.time.end);\n    }\n  },\n\n  /**\n   * Determines the default model of this tool\n   */\n  default_model: {\n    state: {\n      time: {\n        \"autoconfig\": {\n          \"type\": \"time\"\n        }\n      },\n      entities: {\n        \"autoconfig\": {\n          \"type\": \"entity_domain\",\n          \"excludeIDs\": [\"tag\"]\n        }\n      },\n      entities_colorlegend: {\n        \"autoconfig\": {\n          \"type\": \"entity_domain\",\n          \"excludeIDs\": [\"tag\"]\n        }\n      },\n      entities_tags: {\n        \"autoconfig\": {\n          \"type\": \"entity_domain\",\n          \"includeOnlyIDs\": [\"tag\"]\n        }\n      },\n      marker_tags: {\n        space: [\"entities_tags\"],\n        label: {\n          use: \"property\",\n          which: \"name\"\n        },\n        hook_parent: {}\n      },\n      marker: {\n        space: [\"entities\", \"time\"],\n        axis_x: {\n          use: \"indicator\",\n          \"autoconfig\": {\n            index: 0,\n            type: \"measure\"\n          }\n        },\n        axis_y: {\n          use: \"indicator\",\n          \"autoconfig\": {\n            index: 1,\n            type: \"measure\"\n          }\n        },\n        label: {\n          use: \"property\",\n          \"autoconfig\": {\n            \"includeOnlyIDs\": [\"name\"],\n            \"type\": \"string\"\n          }\n        },\n        size: {\n          \"autoconfig\": {\n              index: 2,\n              type: \"measure\"\n            }\n        },\n        color: {\n          syncModels: [\"marker_colorlegend\"],\n          \"autoconfig\": {}\n        },\n        size_label: {\n          use: \"constant\",\n          which: \"_default\",\n          scaleType: \"ordinal\",\n          _important: false,\n          extent: [0, 0.33],\n          allow: {\n            names: [\"_default\"]\n          }\n        },\n      },\n      \"marker_colorlegend\": {\n        \"space\": [\"entities_colorlegend\"],\n        \"label\": {\n          \"use\": \"property\",\n          \"which\": \"name\"\n        },\n        \"hook_rank\": {\n          \"use\": \"property\",\n          \"which\": \"rank\"\n        },\n        \"hook_geoshape\": {\n          \"use\": \"property\",\n          \"which\": \"shape_lores_svg\"\n        }\n      }\n    },\n    locale: {},\n    ui: {\n      chart: {\n        superhighlightOnMinimapHover: true,\n        whenHovering: {\n          showProjectionLineX: true,\n          showProjectionLineY: true,\n          higlightValueX: true,\n          higlightValueY: true\n        },\n        labels: {\n          dragging: true,\n          removeLabelBox: false\n        },\n        margin: {\n          left: 0,\n          top:0\n        },\n        trails: true,\n        lockNonSelected: 0\n      },\n      datawarning: {\n        doubtDomain: [],\n        doubtRange: []\n      },\n      show_ticks: true,\n      presentation: false,\n      panWithArrow: false,\n      adaptMinMaxZoom: false,\n      cursorMode: \"arrow\",\n      zoomOnScrolling: false,\n      buttons: [\"colors\", \"find\", \"zoom\", \"trails\", \"lock\", \"moreoptions\", \"fullscreen\", \"presentation\"],\n      dialogs: {\n        popup: [\"colors\", \"find\", \"size\", \"zoom\", \"moreoptions\"],\n        sidebar: [\"colors\", \"find\", \"size\", \"zoom\"],\n        moreoptions: [\"opacity\", \"speed\", \"axes\", \"size\", \"colors\", \"label\", \"zoom\", \"presentation\", \"about\"]\n      }\n    }\n  },\n\n  versionInfo: VERSION_INFO\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","const { utils } = Vizabi;\n\nconst {\n  svgexport: Exporter,\n  labels: Labels,\n  'd3.axisWithLabelPicker': axisSmart,\n  'd3.dynamicBackground': DynamicBackground\n} = Vizabi.helpers;\n\nconst {\n  warn: iconWarn,\n  question: iconQuestion\n} = Vizabi.iconset;\n\nimport Trail from './trail';\nimport PanZoom from './panzoom';\n\n\n// BUBBLE CHART COMPONENT\nconst BubbleChart = Vizabi.Component.extend(\"bubblechart\", {\n\n  /**\n   * Initializes the component (Bubble Chart).\n   * Executed once before any template is rendered.\n   * @param {Object} config The config passed to the component\n   * @param {Object} context The component's parent\n   */\n  init(config, context) {\n    const _this = this;\n    this.name = \"bubblechart\";\n    this.template = require(\"./template.html\");\n\n    //define expected models for this component\n    this.model_expects = [{\n      name: \"time\",\n      type: \"time\"\n    }, {\n      name: \"marker\",\n      type: \"marker\"\n    }, {\n      name: \"locale\",\n      type: \"locale\"\n    }, {\n      name: \"ui\",\n      type: \"ui\"\n    }];\n\n    this.model_binds = {\n      \"change:time.playing\": function(evt, original) {\n        if (utils.isTouchDevice() && _this.model.time.playing && _this.someHighlighted) {\n          _this.model.marker.clearHighlighted();\n        }\n      },\n      \"change:time.start\": function(evt, original) {\n        if (!_this._readyOnce || _this.model.time.splash) return;\n        if ([\"color\", \"axis_x\", \"axis_y\"].filter(hook => _this.model.marker[hook].which == _this.model.time.dim).length) {\n          _this.ready();\n          return;          \n        };\n        _this._trails.create().then(() => {\n          _this._trails.run([\"findVisible\", \"reveal\", \"opacityHandler\"]);\n        });\n      },\n      \"change:time.end\": function(evt, original) {\n        if (!_this._readyOnce || _this.model.time.splash) return;\n        if ([\"color\", \"axis_x\", \"axis_y\"].filter(hook => _this.model.marker[hook].which == _this.model.time.dim).length) {\n          _this.ready();\n          return;          \n        };\n        _this._trails.create().then(() => {\n          _this._trails.run([\"findVisible\", \"reveal\", \"opacityHandler\"]);\n        });\n      },\n      \"change:time.record\": function() {\n        //console.log(\"change time record\");\n        if (_this.model.time.record) {\n          _this._export.open(this.element, this.name);\n        } else {\n          _this._export.reset();\n        }\n      },\n      \"change:ui.chart.trails\": function(evt) {\n        //console.log(\"EVENT change:time:trails\");\n        if (!_this._readyOnce) return;\n        _this._trails.toggle(_this.model.ui.chart.trails);\n        _this.redrawDataPoints();\n      },\n      \"change:ui.chart.lockNonSelected\": function(evt) {\n        if (!_this._readyOnce) return;\n        //console.log(\"EVENT change:time:lockNonSelected\");\n        _this.redrawDataPoints(500);\n      },\n      \"change:marker\": function(evt, path) {\n        // bubble size change is processed separately\n        if (!_this._readyOnce) return;\n        if (path.indexOf(\"scaleType\") > -1) {\n          _this.ready();\n          return;\n        }\n\n        if (path.indexOf(\"marker.color\") !== -1) return;\n        if (path.indexOf(\"marker.size\") !== -1) return;\n        if (path.indexOf(\"marker.size_label\") !== -1) return;\n\n        if (path.indexOf(\"domainMin\") > -1 || path.indexOf(\"domainMax\") > -1) {\n          if (!_this.yScale || !_this.xScale) return; //abort if building of the scale is in progress\n          _this.updateSize();\n          _this.updateMarkerSizeLimits();\n          _this._trails.run(\"findVisible\");\n          _this.redrawDataPoints();\n          _this._trails.run(\"resize\", null, 500);\n        } else if (path.indexOf(\"zoomedMin\") > -1 || path.indexOf(\"zoomedMax\") > -1) {\n          if (_this.draggingNow) return;\n\n          //avoid zooming again if values didn't change.\n          //also prevents infinite loop on forced URL update from zoom.stop()\n          if (utils.approxEqual(_this._zoomedXYMinMax.axis_x.zoomedMin, _this.model.marker.axis_x.zoomedMin, 0.01)\n            && utils.approxEqual(_this._zoomedXYMinMax.axis_x.zoomedMax, _this.model.marker.axis_x.zoomedMax, 0.01)\n            && utils.approxEqual(_this._zoomedXYMinMax.axis_y.zoomedMin, _this.model.marker.axis_y.zoomedMin, 0.01)\n            && utils.approxEqual(_this._zoomedXYMinMax.axis_y.zoomedMax, _this.model.marker.axis_y.zoomedMax, 0.01)\n          ) return;\n          let playAfterZoom = false;\n          if (_this.model.time.playing) {\n            playAfterZoom = true;\n            _this.model.time.pause(true);\n          }\n          _this._trails.run(\"abortAnimation\");\n          _this._panZoom.zoomToMaxMin(\n            _this.model.marker.axis_x.getZoomedMin(),\n            _this.model.marker.axis_x.getZoomedMax(),\n            _this.model.marker.axis_y.getZoomedMin(),\n            _this.model.marker.axis_y.getZoomedMax(),\n            500 /*duration*/, \"don't feed these zoom values back to state\"\n          );\n          if (playAfterZoom) {\n            _this.model.time.postponePause = false;\n          }\n        }\n\n        //console.log(\"EVENT change:marker\", evt);\n      },\n      \"change:marker.select\": function(evt, path) {\n        if (!_this._readyOnce || !_this.entityBubbles) return;\n        //console.log(\"EVENT change:marker:select\");\n\n        //disable trails if too many items get selected at once\n        //otherwise it's too much waiting time\n        if ((evt.source._val || []).length - (evt.source._previousVal || []).length > 50) _this.model.ui.chart.trails = false;\n\n        _this.selectDataPoints();\n        _this.redrawDataPoints();\n        _this._trails.create().then(() => {\n          _this._trails.run([\"findVisible\", \"reveal\", \"opacityHandler\"]);\n        });\n        _this.updateBubbleOpacity();\n        _this._updateDoubtOpacity();\n      },\n      \"change:marker.superHighlight\": (evt, path) => {\n        if (this._readyOnce) {\n          this._blinkSuperHighlighted();\n        }\n      },\n      \"change:marker.highlight\": function(evt, path) {\n        if (!_this._readyOnce) return;\n        //path have values if trail is highlighted\n        if (path != \"highlight\") {\n          if (path !== null) {\n            const titles = _this._formatSTitleValues(path.size, path.color);\n            _this._updateSTitle(titles[0], titles[1]);\n          } else {\n            _this._updateSTitle();\n          }\n          return;\n        }\n        //console.log(\"EVENT change:marker:highlight\");\n        _this.highlightDataPoints();\n      },\n      \"change:time.value\": function() {\n        if (_this.model.time.splash || !_this._readyOnce || !_this.entityBubbles) return;\n        if (!_this.calculationQueue) { // collect timestamp that we request\n          _this.calculationQueue = [_this.model.time.value.toString()];\n        } else {\n          _this.calculationQueue.push(_this.model.time.value.toString());\n        }\n        (function(time) { // isolate timestamp\n          //_this._bubblesInteract().mouseout();\n          _this.model.marker.getFrame(time, (frame, time) => {\n            if (!_this._frameIsValid(frame)) return utils.warn(\"change:time.value: empty data received from marker.getFrame(). doing nothing\");\n            const index = _this.calculationQueue.indexOf(time.toString()); //\n            if (index == -1) { // we was receive more recent frame before so we pass this frame\n              return;\n            }\n            _this.calculationQueue.splice(0, index + 1); // remove timestamps that added to queue before current timestamp\n            _this.frameChanged(frame, time);\n          });\n\n        })(_this.model.time.value);\n      },\n      \"change:ui.adaptMinMaxZoom\": function() {\n        //console.log(\"EVENT change:ui:adaptMinMaxZoom\");\n        if (_this.model.ui.adaptMinMaxZoom) {\n          _this._panZoom.expandCanvas(500);\n        } else {\n          _this._panZoom.reset();\n        }\n      },\n      \"change:marker.size.extent\": function(evt, path) {\n        //console.log(\"EVENT change:marker:size:max\");\n        if (!_this._readyOnce) return;\n        _this.updateMarkerSizeLimits();\n        _this.redrawDataPointsOnlySize();\n        _this._trails.run(\"resize\");\n      },\n      \"change:marker.color\": function(evt, path) {\n        if (!_this._readyOnce) return;\n        //console.log(\"EVENT change:marker:color:palette\");\n        _this.redrawDataPointsOnlyColors();\n        _this._trails.run(\"recolor\");\n      },\n      // 'change:marker.color.palette': function(evt, path) {\n      //   if(!_this._readyOnce) return;\n      //   //console.log(\"EVENT change:marker:color:palette\");\n      //   _this.redrawDataPointsOnlyColors();\n      //   _this._trails.run(\"recolor\");\n      // },\n      \"change:marker.opacitySelectDim\": function() {\n        _this.updateBubbleOpacity();\n      },\n      \"change:marker.opacityRegular\": function() {\n        _this.updateBubbleOpacity();\n        _this._trails.run(\"opacityHandler\");\n      },\n      \"change:ui.cursorMode\": function() {\n        const svg = _this.chartSvg;\n        if (_this.model.ui.cursorMode === \"plus\") {\n          svg.classed(\"vzb-zoomin\", true);\n          svg.classed(\"vzb-zoomout\", false);\n          svg.classed(\"vzb-panhand\", false);\n        } else if (_this.model.ui.cursorMode === \"minus\") {\n          svg.classed(\"vzb-zoomin\", false);\n          svg.classed(\"vzb-zoomout\", true);\n          svg.classed(\"vzb-panhand\", false);\n        } else if (_this.model.ui.cursorMode === \"hand\") {\n          svg.classed(\"vzb-zoomin\", false);\n          svg.classed(\"vzb-zoomout\", false);\n          svg.classed(\"vzb-panhand\", true);\n        } else {\n          svg.classed(\"vzb-zoomin\", false);\n          svg.classed(\"vzb-zoomout\", false);\n          svg.classed(\"vzb-panhand\", false);\n        }\n      },\n      \"change:marker.space\": function() {\n        if (_this.someHighlighted) {\n          _this.model.marker.clearHighlighted();\n        }\n        if (_this.someSelected) {\n          _this.model.marker.clearSelected();\n        }\n      },\n      \"ready\": function() {\n        // if(_this.model.marker.color.scaleType === 'time') {\n        //   _this.model.marker.color.scale = null;\n        //   utils.defer(function() {\n        //     _this.trigger('ready');\n        //   });\n        // }\n      }\n    };\n\n    this._super(config, context);\n\n    this.xScale = null;\n    this.yScale = null;\n    this.sScale = null;\n    this.cScale = null;\n\n    this.xAxis = axisSmart(\"bottom\");\n    this.yAxis = axisSmart(\"left\");\n\n    _this.COLOR_BLACKISH = \"#333\";\n    _this.COLOR_WHITEISH = \"#fdfdfd\";\n\n    this.isCanvasPreviouslyExpanded = false;\n    this.draggingNow = null;\n\n    this._trails = new Trail(this);\n    this._panZoom = new PanZoom(this);\n    this._export = new Exporter(this);\n    this._export\n      .prefix(\"vzb-bc-\")\n      .deleteClasses([\"vzb-bc-bubbles-crop\", \"vzb-hidden\", \"vzb-bc-year\", \"vzb-bc-zoom-rect\",\n        \"vzb-bc-projection-x\", \"vzb-bc-projection-y\", \"vzb-bc-axis-c-title\"\n      ]);\n    this._labels = new Labels(this);\n    this._labels.config({\n      CSS_PREFIX: \"vzb-bc\",\n      LABELS_CONTAINER_CLASS: \"vzb-bc-labels\",\n      LINES_CONTAINER_CLASS: \"vzb-bc-bubbles\",\n      LINES_CONTAINER_SELECTOR_PREFIX: \"bubble-\"\n    });\n  },\n\n  _rangeBump(arg, undo) {\n    const bump = this.activeProfile.maxRadiusPx / 2;\n    undo = undo ? -1 : 1;\n    if (utils.isArray(arg) && arg.length > 1) {\n      let z1 = arg[0];\n      let z2 = arg[arg.length - 1];\n\n      //the sign of bump depends on the direction of the scale\n      if (z1 < z2) {\n        z1 += bump * undo;\n        z2 -= bump * undo;\n        // if the scale gets inverted because of bump, set it to avg between z1 and z2\n        if (z1 > z2) z1 = z2 = (z1 + z2) / 2;\n      } else if (z1 > z2) {\n        z1 -= bump * undo;\n        z2 += bump * undo;\n        // if the scale gets inverted because of bump, set it to avg between z1 and z2\n        if (z1 < z2) z1 = z2 = (z1 + z2) / 2;\n      } else {\n        // rangeBump error: the input scale range has 0 length. that sucks but we keep cool\n      }\n      return [z1, z2];\n    }\n    utils.warn(\"rangeBump error: input is not an array or empty\");\n  },\n\n\n  /**\n   * Executes right after the template is in place, but the model is not yet ready\n   */\n  readyOnce() {\n    const _this = this;\n    this._readyOnce = false;\n    this.scrollableAncestor = utils.findScrollableAncestor(this.element);\n    this.element = d3.select(this.element);\n\n    // reference elements\n    this.chartSvg = this.element.select(\"svg\");\n    this.graph = this.element.select(\".vzb-bc-graph\");\n    this.yAxisElContainer = this.graph.select(\".vzb-bc-axis-y\");\n    this.yAxisEl = this.yAxisElContainer.select(\"g\");\n\n    this.xAxisElContainer = this.graph.select(\".vzb-bc-axis-x\");\n    this.xAxisEl = this.xAxisElContainer.select(\"g\");\n\n    this.ySubTitleEl = this.graph.select(\".vzb-bc-axis-y-subtitle\");\n    this.xSubTitleEl = this.graph.select(\".vzb-bc-axis-x-subtitle\");\n    this.yTitleEl = this.graph.select(\".vzb-bc-axis-y-title\");\n    this.xTitleEl = this.graph.select(\".vzb-bc-axis-x-title\");\n    this.sTitleEl = this.graph.select(\".vzb-bc-axis-s-title\");\n    this.cTitleEl = this.graph.select(\".vzb-bc-axis-c-title\");\n    this.yearEl = this.graph.select(\".vzb-bc-year\");\n\n    this.year = new DynamicBackground(this.yearEl);\n\n    this.yInfoEl = this.graph.select(\".vzb-bc-axis-y-info\");\n    this.xInfoEl = this.graph.select(\".vzb-bc-axis-x-info\");\n    this.dataWarningEl = this.graph.select(\".vzb-data-warning\");\n\n    this.projectionX = this.graph.select(\".vzb-bc-projection-x\");\n    this.projectionY = this.graph.select(\".vzb-bc-projection-y\");\n    this.lineEqualXY = this.graph.select(\".vzb-bc-line-equal-xy\");\n\n    this.trailsContainer = this.graph.select(\".vzb-bc-trails\");\n    this.bubbleContainerCrop = this.graph.select(\".vzb-bc-bubbles-crop\");\n    this.zoomSelection = this.graph.select(\".vzb-zoom-selection\");\n    this.labelsContainerCrop = this.graph.select(\".vzb-bc-labels-crop\");\n    this.bubbleContainer = this.graph.select(\".vzb-bc-bubbles\");\n    this.labelsContainer = this.graph.select(\".vzb-bc-labels\");\n    this.linesContainer = this.graph.select(\".vzb-bc-lines\");\n    this.zoomRect = this.element.select(\".vzb-bc-zoom-rect\");\n    this.eventArea = this.element.select(\".vzb-bc-eventarea\");\n\n    this.entityBubbles = null;\n    this.bubbleCrown = this.element.select(\".vzb-bc-bubble-crown\");\n    //set filter\n    this.bubbleCrown.selectAll(\".vzb-crown-glow\")\n      .attr(\"filter\", \"url(\" + location.pathname + \"#vzb-glow-filter)\");\n    this.tooltipMobile = this.element.select(\".vzb-tooltip-mobile\");\n    //component events\n    this.on(\"resize\", () => {\n      //console.log(\"EVENT: resize\");\n      //return if updatesize exists with error\n      _this._trails.run(\"abortAnimation\");\n      if (_this.updateSize()) return;\n      _this.updateMarkerSizeLimits();\n      _this._labels.updateSize();\n      (function(xMin, xMax, yMin, yMax) {\n        _this._panZoom.zoomer.dontFeedToState = true;\n        _this._panZoom.rerun(); // includes redraw data points and trail resize\n        _this._panZoom.zoomToMaxMin(xMin, xMax, yMin, yMax, 0, true);\n      })(_this._zoomedXYMinMax.axis_x.zoomedMin,\n        _this._zoomedXYMinMax.axis_x.zoomedMax,\n        _this._zoomedXYMinMax.axis_y.zoomedMin,\n        _this._zoomedXYMinMax.axis_y.zoomedMax);\n    });\n\n    //keyboard listeners\n    d3.select(\"body\")\n      .on(\"keydown\", () => {\n        if (_this.model.ui.cursorMode !== \"arrow\" && _this.model.ui.cursorMode !== \"hand\") return;\n        if (d3.event.metaKey || d3.event.ctrlKey) _this.element.select(\"svg\").classed(\"vzb-zoomin\", true);\n      })\n      .on(\"keyup\", () => {\n        if (_this.model.ui.cursorMode !== \"arrow\" && _this.model.ui.cursorMode !== \"hand\") return;\n        if (!d3.event.metaKey && !d3.event.ctrlKey) _this.element.select(\"svg\").classed(\"vzb-zoomin\", false);\n      })\n      //this is for the case when user would press ctrl and move away from the browser tab or window\n      //keyup event would happen somewhere else and won't be captured, so zoomin class would get stuck\n      .on(\"mouseenter\", () => {\n        if (_this.model.ui.cursorMode !== \"arrow\" && _this.model.ui.cursorMode !== \"hand\") return;\n        if (!d3.event.metaKey && !d3.event.ctrlKey) _this.element.select(\"svg\").classed(\"vzb-zoomin\", false);\n      });\n\n    this.root.on(\"resetZoom\", () => {\n      _this._panZoom.reset(null, 500);\n    });\n\n    this._panZoom.zoomSelection(this.bubbleContainerCrop);\n    this.bubbleContainerCrop\n      .call(this._panZoom.dragRectangle)\n      .call(this._panZoom.zoomer)\n      .on(\"dblclick.zoom\", null)\n      .on(\"mouseup\", () => {\n        _this.draggingNow = false;\n      })\n      .on(\"click\", () => {\n        const cursor = _this.model.ui.cursorMode;\n        if (!d3.event.defaultPrevented && cursor !== \"arrow\" && cursor !== \"hand\") {\n          _this._panZoom.zoomByIncrement(cursor, 500);\n        }\n      });\n\n    this.TIMEDIM = this.model.time.getDimension();\n    this.KEYS = utils.unique(this.model.marker._getAllDimensions({ exceptType: \"time\" }));\n    this.KEY = this.KEYS.join(\",\");\n    this.dataKeys = this.model.marker.getDataKeysPerHook();\n    this.labelNames = this.model.marker.getLabelHookNames();\n\n    this.updateUIStrings();\n\n    this.wScale = d3.scaleLinear()\n      .domain(this.model.ui.datawarning.doubtDomain)\n      .range(this.model.ui.datawarning.doubtRange);\n\n    this._labels.readyOnce();\n\n    _this._readyOnce = true;\n  },\n\n  _frameIsValid(frame) {\n    return !(!frame\n    || Object.keys(frame.axis_y).length === 0\n    || Object.keys(frame.axis_x).length === 0\n    || Object.keys(frame.size).length === 0);\n  },\n\n  ready() {\n    const _this = this;\n    this.KEYS = utils.unique(this.model.marker._getAllDimensions({ exceptType: \"time\" }));\n    this.KEY = this.KEYS.join(\",\");\n    this.dataKeys = this.model.marker.getDataKeysPerHook();\n    this.labelNames = this.model.marker.getLabelHookNames();\n\n    this.updateUIStrings();\n    const endTime = this.model.time.end;\n    this.updateIndicators();\n    this.updateTime();\n    if (!_this.model.time.splash) {\n      _this._trails.create();\n    }\n    this.model.marker.getFrame(this.model.time.value, (frame, time) => {\n      // TODO: temporary fix for case when after data loading time changed on validation\n      if (time.toString() != _this.model.time.value.toString()) {\n        utils.defer(() => {\n          _this.ready();\n        });\n        return;\n      }\n      if (!_this._frameIsValid(frame)) return utils.warn(\"ready: empty data received from marker.getFrame(). doing nothing\");\n\n      _this.frame = frame;\n      _this.updateSize();\n      _this.updateMarkerSizeLimits();\n      _this.updateEntities();\n      _this._labels.ready();\n      _this.redrawDataPoints();\n      _this.selectDataPoints();\n      _this.updateBubbleOpacity();\n      _this._updateDoubtOpacity();\n      _this.zoomToMarkerMaxMin(); // includes redraw data points and trail resize\n      if (!_this.model.time.splash) {\n        _this._trails.run([\"findVisible\", \"reveal\", \"opacityHandler\"]);\n      }\n      if (_this.model.ui.adaptMinMaxZoom) _this._panZoom.expandCanvas();\n    });\n  },\n\n  /*\n   * Zoom to the min and max values given in the URL axes markers.\n   */\n  zoomToMarkerMaxMin() {\n    /*\n     * Reset just the zoom values without triggering a zoom event. This ensures\n     * a clean zoom state for the subsequent zoom event.\n     */\n    this._panZoom.resetZoomState();\n\n    const xAxis = this.model.marker.axis_x;\n    const yAxis = this.model.marker.axis_y;\n\n    const xDomain = xAxis.getScale().domain();\n    const yDomain = yAxis.getScale().domain();\n\n    /*\n     * The axes may return null when there is no value given for the zoomed\n     * min and max values. In that case, fall back to the axes' domain values.\n     */\n    const zoomedMinX = xAxis.getZoomedMin();\n    const zoomedMaxX = xAxis.getZoomedMax();\n    const zoomedMinY = yAxis.getZoomedMin();\n    const zoomedMaxY = yAxis.getZoomedMax();\n\n    //by default this will apply no transition and feed values back to state\n    this._panZoom.zoomToMaxMin(zoomedMinX, zoomedMaxX, zoomedMinY, zoomedMaxY, 0, \"don't feed these zoom values back to state\");\n  },\n\n  /*\n   * UPDATE INDICATORS\n   */\n  updateIndicators() {\n    const _this = this;\n\n    //scales\n    this.yScale = this.model.marker.axis_y.getScale();\n    this.xScale = this.model.marker.axis_x.getScale();\n    this.sScale = this.model.marker.size.getScale();\n    this.cScale = this.model.marker.color.getScale();\n    this._labels.setScales(this.xScale, this.yScale);\n\n    this.yAxis.tickFormat(_this.model.marker.axis_y.getTickFormatter());\n    this.xAxis.tickFormat(_this.model.marker.axis_x.getTickFormatter());\n  },\n\n  frameChanged(frame, time) {\n//    if (time.toString() != this.model.time.value.toString()) return; // frame is outdated\n    this.frame = frame;\n    this.updateTime();\n\n    this._updateDoubtOpacity();\n    this._trails.run(\"findVisible\");\n    if (this.model.ui.adaptMinMaxZoom) {\n      this._panZoom.expandCanvas();\n    } else {\n      this.redrawDataPoints();\n    }\n    this._trails.run(\"reveal\", null, this.duration);\n    this.tooltipMobile.classed(\"vzb-hidden\", true);\n    this._reorderEntities();\n  },\n\n  _getSubtitle(title, shortTitle) {\n    let subtitle = title.replace(shortTitle,\"\");\n    if (subtitle[0] === \",\") subtitle = subtitle.slice(1);\n    const regexpResult = /^\\((.*)\\)$|.*/.exec(subtitle.trim());\n    return regexpResult[1] || regexpResult[0] || \"\";\n  },\n\n  updateUIStrings() {\n    const _this = this;\n    const layoutProfile = this.getLayoutProfile();\n\n    const conceptPropsY = _this.model.marker.axis_y.getConceptprops();\n    const conceptPropsX = _this.model.marker.axis_x.getConceptprops();\n    const conceptPropsS = _this.model.marker.size.getConceptprops();\n    const conceptPropsC = _this.model.marker.color.getConceptprops();\n    this.translator = this.model.locale.getTFunction();\n\n    this.strings = {\n      title: {\n        Y: conceptPropsY.name,\n        X: conceptPropsX.name,\n        S: conceptPropsS.name,\n        C: conceptPropsC.name\n      },\n      title_short: {\n        Y: conceptPropsY.name_short,\n        X: conceptPropsX.name_short,\n        S: conceptPropsS.name_short,\n        C: conceptPropsC.name_short        \n      },\n      subtitle: {\n        Y: this._getSubtitle(conceptPropsY.name, conceptPropsY.name_short),\n        X: this._getSubtitle(conceptPropsX.name, conceptPropsX.name_short),\n        S: conceptPropsS.name_short,\n        C: conceptPropsC.name_short        \n      },\n      unit: {\n        Y: conceptPropsY.unit || \"\",\n        X: conceptPropsX.unit || \"\",\n        S: conceptPropsS.unit || \"\",\n        C: conceptPropsC.unit || \"\"\n      }\n    };\n\n    const ySubTitle = this.ySubTitleEl.selectAll(\"text\").data([0]);\n    ySubTitle.enter().append(\"text\");\n    const xSubTitle = this.xSubTitleEl.selectAll(\"text\").data([0]);\n    xSubTitle.enter().append(\"text\");\n\n    const yTitle = this.yTitleEl.selectAll(\"text\").data([0]);\n    yTitle.enter().append(\"text\");\n    yTitle\n    //.attr(\"y\", \"-6px\")\n      .on(\"click\", () => {\n        _this.parent\n          .findChildByName(\"gapminder-treemenu\")\n          .markerID(\"axis_y\")\n          .alignX(_this.model.locale.isRTL() ? \"right\" : \"left\")\n          .alignY(\"top\")\n          .updateView()\n          .toggle();\n      });\n\n    const xTitle = this.xTitleEl.selectAll(\"text\").data([0]);\n    xTitle.enter().append(\"text\");\n    xTitle\n      .on(\"click\", () => {\n        _this.parent\n          .findChildByName(\"gapminder-treemenu\")\n          .markerID(\"axis_x\")\n          .alignX(_this.model.locale.isRTL() ? \"right\" : \"left\")\n          .alignY(\"bottom\")\n          .updateView()\n          .toggle();\n      });\n\n    const sTitle = this.sTitleEl.selectAll(\"text\").data([0]);\n    sTitle.enter().append(\"text\");\n    sTitle\n      .attr(\"text-anchor\", \"end\");\n\n    utils.setIcon(this.dataWarningEl, iconWarn).select(\"svg\").attr(\"width\", \"0px\").attr(\"height\", \"0px\");\n    this.dataWarningEl.append(\"text\")\n      .attr(\"text-anchor\", \"end\")\n      .text(this.translator(\"hints/dataWarning\"));\n\n    utils.setIcon(this.yInfoEl, iconQuestion)\n      .select(\"svg\").attr(\"width\", \"0px\").attr(\"height\", \"0px\")\n      .style('opacity', Number(Boolean(conceptPropsY.description || conceptPropsY.sourceLink)));\n\n    utils.setIcon(this.xInfoEl, iconQuestion)\n      .select(\"svg\").attr(\"width\", \"0px\").attr(\"height\", \"0px\")\n      .style('opacity', Number(Boolean(conceptPropsX.description || conceptPropsX.sourceLink)));\n\n\n    //TODO: move away from UI strings, maybe to ready or ready once\n    this.yInfoEl.on(\"click\", () => {\n      _this.parent.findChildByName(\"gapminder-datanotes\").pin();\n    });\n    this.yInfoEl.on(\"mouseover\", function() {\n      const rect = this.getBBox();\n      const coord = utils.makeAbsoluteContext(this, this.farthestViewportElement)(rect.x - 10, rect.y + rect.height + 10);\n      const toolRect = _this.root.element.getBoundingClientRect();\n      const chartRect = _this.element.node().getBoundingClientRect();\n      _this.parent.findChildByName(\"gapminder-datanotes\").setHook(\"axis_y\").show().setPos(coord.x + chartRect.left - toolRect.left, coord.y);\n    });\n    this.yInfoEl.on(\"mouseout\", () => {\n      _this.parent.findChildByName(\"gapminder-datanotes\").hide();\n    });\n    this.xInfoEl.on(\"click\", () => {\n      _this.parent.findChildByName(\"gapminder-datanotes\").pin();\n    });\n    this.xInfoEl.on(\"mouseover\", function() {\n      if (_this.model.time.dragging) return;\n      const rect = this.getBBox();\n      const coord = utils.makeAbsoluteContext(this, this.farthestViewportElement)(rect.x - 10, rect.y + rect.height + 10);\n      const toolRect = _this.root.element.getBoundingClientRect();\n      const chartRect = _this.element.node().getBoundingClientRect();\n      _this.parent.findChildByName(\"gapminder-datanotes\").setHook(\"axis_x\").show().setPos(coord.x + chartRect.left - toolRect.left, coord.y);\n    });\n    this.xInfoEl.on(\"mouseout\", () => {\n      if (_this.model.time.dragging) return;\n      _this.parent.findChildByName(\"gapminder-datanotes\").hide();\n    });\n    this.dataWarningEl\n      .on(\"click\", () => {\n        _this.parent.findChildByName(\"gapminder-datawarning\").toggle();\n      })\n      .on(\"mouseover\", () => {\n        _this._updateDoubtOpacity(1);\n      })\n      .on(\"mouseout\", () => {\n        _this._updateDoubtOpacity();\n      });\n  },\n\n  _updateDoubtOpacity(opacity) {\n    if (opacity == null) opacity = this.wScale(+this.model.time.formatDate(this.time));\n    if (this.someSelected) opacity = 1;\n    this.dataWarningEl.style(\"opacity\", opacity);\n  },\n\n  /*\n   * UPDATE ENTITIES:\n   * Ideally should only update when show parameters change or data changes\n   */\n  updateEntities() {\n    const _this = this;\n    const dataKeys = this.dataKeys;\n    const KEYS = this.KEYS;\n    const KEY = this.KEY;\n    const TIMEDIM = this.TIMEDIM;\n\n    const getKeys = function(prefix) {\n      prefix = prefix || \"\";\n      return _this.model.marker.getKeys()\n        .map(d => {\n          const pointer = Object.assign({}, d);\n          //pointer[KEY] = d[KEY];\n          pointer[TIMEDIM] = endTime;\n          pointer.sortValue = _this.frame.size[utils.getKey(d, dataKeys.size)] || 0;\n          pointer[KEY] = prefix + utils.getKey(d, KEYS);\n          return pointer;\n        })\n        .sort((a, b) => b.sortValue - a.sortValue);\n    };\n\n    // get array of GEOs, sorted by the size hook\n    // that makes larger bubbles go behind the smaller ones\n    const endTime = this.model.time.end;\n    const markers = getKeys.call(this);\n    this.model.marker.setVisible(markers);\n\n    //unselecting bubbles with no data is used for the scenario when\n    //some bubbles are selected and user would switch indicator.\n    //bubbles would disappear but selection would stay\n    if (!this.model.time.splash) {\n      this.unselectBubblesWithNoData(markers);\n    }\n    this.entityBubbles = this.bubbleContainer.selectAll(\"circle.vzb-bc-entity\")\n      .data(this.model.marker.getVisible(), d => d[KEY]); // trails have not keys\n\n    //exit selection\n    this.entityBubbles.exit().remove();\n\n    //enter selection -- init circles\n    this.entityBubbles = this.entityBubbles.enter().append(\"circle\")\n      .attr(\"class\", d => \"vzb-bc-entity \" + \"bubble-\" + d[KEY])\n      .on(\"mouseover\", (d, i) => {\n        if (utils.isTouchDevice() || (_this.model.ui.cursorMode !== \"arrow\" && _this.model.ui.cursorMode !== \"hand\")) return;\n        _this._bubblesInteract().mouseover(d, i);\n      })\n      .on(\"mouseout\", (d, i) => {\n        if (utils.isTouchDevice() || (_this.model.ui.cursorMode !== \"arrow\" && _this.model.ui.cursorMode !== \"hand\")) return;\n\n        _this._bubblesInteract().mouseout(d, i);\n      })\n      .on(\"click\", (d, i) => {\n        if (utils.isTouchDevice() || (_this.model.ui.cursorMode !== \"arrow\" && _this.model.ui.cursorMode !== \"hand\")) return;\n\n        _this._bubblesInteract().click(d, i);\n      })\n      .onTap((d, i) => {\n        d3.event.stopPropagation();\n        _this._bubblesInteract().click(d, i);\n      })\n      .onLongTap((d, i) => {\n      })\n      .merge(this.entityBubbles);\n\n    this._reorderEntities();\n  },\n\n  unselectBubblesWithNoData(entities) {\n    const _this = this;\n    const KEYS = this.KEYS;\n    const KEY = this.KEY;\n    if (!this.model.marker.select.length) return;\n\n    const _select = [];\n    const keys = entities.map(d => d[KEY]);\n\n    this.model.marker.select.forEach(d => {\n      if (keys.indexOf(utils.getKey(d, KEYS)) !== -1) _select.push(d);\n    });\n\n    if (_select.length !== _this.model.marker.select.length) _this.model.marker.select = _select;\n  },\n\n  _reorderEntities() {\n    const _this = this;\n    const dataKeys = this.dataKeys;\n    const KEY = this.KEY;\n    this.bubbleContainer.selectAll(\".vzb-bc-entity\")\n      .sort((a, b) => {\n        const sizeA = _this.frame.size[utils.getKey(a, dataKeys.size)];\n        const sizeB = _this.frame.size[utils.getKey(b, dataKeys.size)];\n\n        if (typeof sizeA === \"undefined\" && typeof sizeB !== \"undefined\") return -1;\n        if (typeof sizeA !== \"undefined\" && typeof sizeB === \"undefined\") return 1;\n        if (sizeA != sizeB) return d3.descending(sizeA, sizeB);\n        if (a[KEY] != b[KEY]) return d3.ascending(a[KEY], b[KEY]);\n        if (typeof a.trailStartTime !== \"undefined\" || typeof b.trailStartTime !== \"undefined\") return typeof a.trailStartTime !== \"undefined\" ? -1 : 1; // only lines has trailStartTime\n        if (typeof a.status !== \"undefined\" || typeof b.status !== \"undefined\") return typeof a.status !== \"undefined\" ? -1 : 1; // only trails has attribute status\n        return d3.descending(sizeA, sizeB);\n      });\n  },\n\n  _bubblesInteract() {\n    const _this = this;\n    const KEY = this.KEY;\n    const TIMEDIM = this.TIMEDIM;\n\n    return {\n      mouseover(d, i) {\n        _this.model.marker.highlightMarker(d);\n\n        _this._labels.showCloseCross(d, true);\n      },\n\n      mouseout(d, i) {\n        _this.model.marker.clearHighlighted();\n\n        _this._labels.showCloseCross(d, false);\n      },\n\n      click(d, i) {\n        if (_this.draggingNow) return;\n        const isSelected = _this.model.marker.isSelected(d);\n        _this.model.marker.selectMarker(d);\n        //return to highlighted state\n        if (!utils.isTouchDevice()) {\n          if (isSelected) _this.model.marker.highlightMarker(d);\n          _this.highlightDataPoints();\n        }\n      }\n    };\n  },\n\n\n  /*\n   * UPDATE TIME:\n   * Ideally should only update when time or data changes\n   */\n  updateTime() {\n    const _this = this;\n\n    this.time_1 = this.time == null ? this.model.time.value : this.time;\n    this.time = this.model.time.value;\n    this.duration = this.model.time.playing && (this.time - this.time_1 > 0) ? this.model.time.delayAnimations : 0;\n    this.year.setText(this.model.time.formatDate(this.time, \"ui\"), this.duration);\n  },\n\n  /*\n   * RESIZE:\n   * Executed whenever the container is resized\n   */\n  updateSize() {\n\n    const { chartSvg } = this;\n    const svgWidth = utils.px2num(chartSvg.style(\"width\"));\n    const svgHeight = utils.px2num(chartSvg.style(\"height\"));\n    const marginScaleH = (marginMin, ratio = 0) => marginMin + svgHeight * ratio;\n    const marginScaleW = (marginMin, ratio = 0) => marginMin + svgWidth * ratio;\n\n    const profiles = {\n      small: {\n        margin: { top: 30, bottom: 35, left: 30, right: 10},\n        leftMarginRatio: 1,\n        padding: 2,\n        minRadiusPx: 0.5,\n        maxRadiusEm: this.model.ui.chart.maxRadiusEm || 0.05,\n        infoElHeight: 16,\n        yAxisTitleBottomMargin: 6,\n        xAxisTitleBottomMargin: 4\n      },\n      medium: {\n        margin: { top: 15, bottom: 40, left: 40, right: 15},\n        leftMarginRatio: 1.6,\n        padding: 2,\n        minRadiusPx: 1,\n        maxRadiusEm: this.model.ui.chart.maxRadiusEm || 0.05,\n        infoElHeight: 20,\n        yAxisTitleBottomMargin: 3,\n        xAxisTitleBottomMargin: 4\n      },\n      large: {\n        margin: { top: 15, bottom: marginScaleH(30, 0.03), left: marginScaleW(31, 0.015), right: 20},\n        leftMarginRatio: 1.8,\n        padding: 2,\n        minRadiusPx: 1,\n        maxRadiusEm: this.model.ui.chart.maxRadiusEm || 0.05,\n        infoElHeight: 22,\n        yAxisTitleBottomMargin: 3,//marginScaleH(4, 0.01),\n        xAxisTitleBottomMargin: marginScaleH(0, 0.01),\n        hideSTitle: true\n      }\n    };\n\n    const presentationProfileChanges = {\n      medium: {\n        margin: { top: 20, bottom: 55, left: 50, right: 20 },\n        yAxisTitleBottomMargin: 3,\n        xAxisTitleBottomMargin: 4,\n        infoElHeight: 26,\n      },\n      large: {\n        margin: { top: 30, bottom: marginScaleH(45, 0.03), left: marginScaleW(35, 0.025), right: 30 },\n        yAxisTitleBottomMargin: 3,//marginScaleH(4, 0.01),\n        xAxisTitleBottomMargin: marginScaleH(-10, 0.01),\n        infoElHeight: 32,\n        hideSTitle: true\n      }\n    };\n    \n    const _this = this;\n\n    this.activeProfile = this.getActiveProfile(profiles, presentationProfileChanges);\n    const layoutProfile = this.getLayoutProfile();\n    const containerWH = this.root.getVizWidthHeight();\n    this.activeProfile.maxRadiusPx = Math.max(\n      this.activeProfile.minRadiusPx,\n      this.activeProfile.maxRadiusEm * utils.hypotenuse(containerWH.width, containerWH.height)\n    );\n\n    const margin = this.activeProfile.margin;\n    const infoElHeight = this.activeProfile.infoElHeight;\n\n    //labels\n    _this._labels.setCloseCrossHeight(_this.activeProfile.infoElHeight * 1.2);\n    _this._labels.setTooltipFontSize(_this.activeProfile.infoElHeight + \"px\");\n    \n    //stage\n    this.height = (parseInt(this.element.style(\"height\"), 10) - margin.top - margin.bottom) || 0;\n    this.width = (parseInt(this.element.style(\"width\"), 10) - margin.left * this.activeProfile.leftMarginRatio - margin.right) || 0;\n\n    if (this.height <= 0 || this.width <= 0) {\n      this.height = 0;\n      this.width = 0;\n      utils.warn(\"Bubble chart updateSize(): vizabi container is too little or has display:none\");\n    }\n\n    //graph group is shifted according to margins (while svg element is at 100 by 100%)\n    this.graph\n      .attr(\"transform\", \"translate(\" + (margin.left * this.activeProfile.leftMarginRatio) + \",\" + margin.top + \")\");\n\n    this.year.resize(this.width, this.height);\n    this.eventArea\n      .attr(\"width\", this.width)\n      .attr(\"height\", Math.max(0, this.height));\n\n    //update scales to the new range\n    if (this.model.marker.axis_y.scaleType !== \"ordinal\") {\n      this.yScale.range(this._rangeBump([this.height, 0]));\n    } else {\n      this.yScale.rangePoints([this.height, 0], _this.activeProfile.padding).range();\n    }\n    if (this.model.marker.axis_x.scaleType !== \"ordinal\") {\n      this.xScale.range(this._rangeBump([0, this.width]));\n    } else {\n      this.xScale.rangePoints([0, this.width], _this.activeProfile.padding).range();\n    }\n\n    //apply scales to axes and redraw\n    this.yAxis.scale(this.yScale)\n      .tickSizeInner(-this.width)\n      .tickSizeOuter(0)\n      .tickPadding(6)\n      .tickSizeMinor(-this.width, 0)\n      .labelerOptions({\n        scaleType: this.model.marker.axis_y.scaleType,\n        toolMargin: margin,\n        limitMaxTickNumber: 6,\n        bump: this.activeProfile.maxRadiusPx / 2,\n        viewportLength: this.height,\n        formatter: this.model.marker.axis_y.getTickFormatter()\n      });\n\n    this.xAxis.scale(this.xScale)\n      .tickSizeInner(-this.height)\n      .tickSizeOuter(0)\n      .tickPadding(6)\n      .tickSizeMinor(-this.height, 0)\n      .labelerOptions({\n        scaleType: this.model.marker.axis_x.scaleType,\n        toolMargin: margin,\n        bump: this.activeProfile.maxRadiusPx / 2,\n        viewportLength: this.width,\n        formatter: this.model.marker.axis_x.getTickFormatter()\n      });\n\n\n    this.bubbleContainerCrop\n      .attr(\"width\", this.width)\n      .attr(\"height\", Math.max(0, this.height));\n\n    this.labelsContainerCrop\n      .attr(\"width\", this.width)\n      .attr(\"height\", Math.max(0, this.height));\n\n    this.xAxisElContainer\n      .attr(\"width\", this.width + 1)\n      .attr(\"height\", this.activeProfile.margin.bottom + this.height)\n      .attr(\"y\", -1)\n      .attr(\"x\", -1);\n    this.xAxisEl\n      .attr(\"transform\", \"translate(1,\" + (1 + this.height) + \")\");\n\n    this.yAxisElContainer\n      .attr(\"width\", this.activeProfile.margin.left + this.width)\n      .attr(\"height\", Math.max(0, this.height))\n      .attr(\"x\", -this.activeProfile.margin.left);\n    this.yAxisEl\n      .attr(\"transform\", \"translate(\" + (this.activeProfile.margin.left - 1) + \",\" + 0 + \")\");\n\n    this.yAxisEl.call(this.yAxis);\n    this.xAxisEl.call(this.xAxis);\n\n    this.projectionX.attr(\"y1\", _this.yScale.range()[0] + this.activeProfile.maxRadiusPx / 2);\n    this.projectionY.attr(\"x2\", _this.xScale.range()[0] - this.activeProfile.maxRadiusPx / 2);\n\n\n    // reduce font size if the caption doesn't fit\n    this._updateSTitle();\n    this.sTitleEl\n      .attr(\"transform\", \"translate(\" + this.width + \",\" + 20 + \") rotate(-90)\");\n\n    if (layoutProfile !== \"small\") {\n      this.ySubTitleEl.select(\"text\").attr(\"dy\", infoElHeight * 0.6).text(this.strings.subtitle.Y);\n      this.xSubTitleEl.select(\"text\").attr(\"dy\", -infoElHeight * 0.3).text(this.strings.subtitle.X);\n      \n      this.yTitleEl.select(\"text\").text(this.strings.title_short.Y + \" \")\n        .append(\"tspan\")\n        .style(\"font-size\", (infoElHeight * 0.7) + \"px\")\n        .text(\"▼\");\n      this.xTitleEl.select(\"text\").text(this.strings.title_short.X + \" \")\n        .append(\"tspan\")\n        .style(\"font-size\", (infoElHeight * 0.7) + \"px\")\n        .text(\"▼\");\n    } else {\n      this.ySubTitleEl.select(\"text\").text(\"\");\n      this.xSubTitleEl.select(\"text\").text(\"\");\n\n      const yTitleText = this.yTitleEl.select(\"text\").text(this.strings.title.Y);\n      if (yTitleText.node().getBBox().width > this.width) yTitleText.text(this.strings.title_short.Y);\n    \n      const xTitleText = this.xTitleEl.select(\"text\").text(this.strings.title.X);\n      if (xTitleText.node().getBBox().width > this.width - 100) xTitleText.text(this.strings.title_short.X);      \n    }\n\n    const isRTL = this.model.locale.isRTL();\n    this.ySubTitleEl\n      .style(\"font-size\", (infoElHeight * 0.8) + \"px\")\n      .attr(\"transform\", \"translate(\" + 0 + \",\" + 0 + \") rotate(-90)\");\n    this.xSubTitleEl\n      .style(\"font-size\", (infoElHeight * 0.8) + \"px\")\n      .attr(\"transform\", \"translate(\" + this.width + \",\" + this.height + \")\");\n  \n    this.yTitleEl\n      .style(\"font-size\", infoElHeight + \"px\")\n      .attr(\"transform\", layoutProfile !== \"small\" ?\n        \"translate(\" + (-margin.left - this.activeProfile.yAxisTitleBottomMargin)  + \",\" + (this.height * 0.5) + \") rotate(-90)\"\n        : \n        \"translate(\" + (isRTL ? this.width : 10 - this.activeProfile.margin.left) + \", -\" + this.activeProfile.yAxisTitleBottomMargin + \")\")\n\n    this.xTitleEl\n      .style(\"font-size\", infoElHeight + \"px\")\n      .attr(\"transform\", layoutProfile !== \"small\" ?\n        \"translate(\" + (this.width * 0.5) + \",\" + (this.height + margin.bottom - this.activeProfile.xAxisTitleBottomMargin) + \")\"\n        :\n        \"translate(\" + (isRTL ? this.width : 0) + \",\" + (this.height + margin.bottom - this.activeProfile.xAxisTitleBottomMargin) + \")\");\n\n    if (this.yInfoEl.select(\"svg\").node()) {\n      const titleBBox = this.yTitleEl.node().getBBox();\n      const t = utils.transform(this.yTitleEl.node());\n      const hTranslate = isRTL ? (titleBBox.x + t.translateX - infoElHeight * 1.4) : (titleBBox.x + t.translateX + titleBBox.width + infoElHeight * 0.4);\n      const vTranslate = isRTL ? (t.translateY + infoElHeight * 1.4 + titleBBox.width * 0.5) : (t.translateY - infoElHeight * 0.4 - titleBBox.width * 0.5);\n\n      this.yInfoEl.select(\"svg\")\n        .attr(\"width\", infoElHeight + \"px\")\n        .attr(\"height\", infoElHeight + \"px\");\n      this.yInfoEl.attr(\"transform\", layoutProfile !== \"small\" ?\n        \"translate(\" + (t.translateX - infoElHeight * 0.8) + \",\" + vTranslate + \") rotate(-90)\"\n        :\n        \"translate(\" + hTranslate + \",\" + (t.translateY - infoElHeight * 0.8) + \")\");\n    }\n\n    if (this.xInfoEl.select(\"svg\").node()) {\n      const titleBBox = this.xTitleEl.node().getBBox();\n      const t = utils.transform(this.xTitleEl.node());\n      const hTranslate = isRTL ? (titleBBox.x + t.translateX - infoElHeight * 1.4) : (titleBBox.x + t.translateX + titleBBox.width + infoElHeight * 0.4);\n\n      this.xInfoEl.select(\"svg\")\n        .attr(\"width\", infoElHeight + \"px\")\n        .attr(\"height\", infoElHeight + \"px\");\n      this.xInfoEl.attr(\"transform\", \"translate(\"\n        + hTranslate + \",\"\n        + (t.translateY - infoElHeight * 0.8) + \")\");\n    }\n\n    this._resizeDataWarning();\n\n    this.model.ui.chart.margin.set(\"left\", margin.left * this.activeProfile.leftMarginRatio, false, false);\n  },\n\n\n  _updateLineEqualXY(duration) {\n    const oneMeasure = this.model.marker.axis_x.which == this.model.marker.axis_y.which;\n    this.lineEqualXY.classed(\"vzb-invisible\", !oneMeasure);\n    if (!oneMeasure) return;\n\n    const min = d3.min(this.yScale.domain().concat(this.xScale.domain()));\n    const max = d3.max(this.yScale.domain().concat(this.xScale.domain()));\n\n    this.lineEqualXY\n      .transition()\n      .duration(duration || 0)\n      .attr(\"y1\", this.yScale(min))\n      .attr(\"y2\", this.yScale(max))\n      .attr(\"x1\", this.xScale(min))\n      .attr(\"x2\", this.xScale(max));\n  },\n\n  _resizeDataWarning() {\n    // reset font size to remove jumpy measurement\n    const dataWarningText = this.dataWarningEl.select(\"text\").style(\"font-size\", null);\n\n    // reduce font size if the caption doesn't fit\n    const dataWarningWidth = dataWarningText.node().getBBox().width + dataWarningText.node().getBBox().height * 3;\n    const remainingWidth = this.width - this.xTitleEl.node().getBBox().width - this.activeProfile.infoElHeight;\n    const font = parseInt(dataWarningText.style(\"font-size\")) * remainingWidth / dataWarningWidth;\n    dataWarningText.style(\"font-size\", dataWarningWidth > remainingWidth ? font + \"px\" : null);\n\n    // position the warning icon\n    const warnBB = dataWarningText.node().getBBox();\n    this.dataWarningEl.select(\"svg\")\n      .attr(\"width\", warnBB.height * 0.75)\n      .attr(\"height\", warnBB.height * 0.75)\n      .attr(\"x\", -warnBB.width - warnBB.height * 1.2)\n      .attr(\"y\", -warnBB.height * 0.65);\n\n    this.dataWarningEl\n      .attr(\"transform\", \"translate(\"\n        + (this.model.locale.isRTL() ? warnBB.width + warnBB.height : this.width) + \",\"\n        + (this.height + this.activeProfile.margin.bottom - this.activeProfile.xAxisTitleBottomMargin)\n        + \")\");\n  },\n\n  updateMarkerSizeLimits() {\n    const _this = this;\n    const extent = this.model.marker.size.extent || [0, 1];\n\n    if (!this.activeProfile) return utils.warn(\"updateMarkerSizeLimits() is called before ready(). This can happen if events get unfrozen and getFrame() still didn't return data\");\n\n    let minRadius = this.activeProfile.minRadiusPx;\n    let maxRadius = this.activeProfile.maxRadiusPx;\n\n    let minArea = utils.radiusToArea(Math.max(maxRadius * extent[0], minRadius));\n    let maxArea = utils.radiusToArea(Math.max(maxRadius * extent[1], minRadius));\n\n    let range = minArea === maxArea? [minArea, maxArea] :\n      d3.range(minArea, maxArea, (maxArea - minArea)/this.sScale.domain().length).concat(maxArea);\n\n    this.sScale.range(range);\n  },\n\n  redrawDataPointsOnlyColors() {\n    const _this = this;\n    if (!this.entityBubbles) return utils.warn(\"redrawDataPointsOnlyColors(): no entityBubbles defined. likely a premature call, fix it!\");\n\n    let valuesNow;\n    const dataKeys = this.dataKeys;\n    const KEYS = this.KEYS;\n    const KEY = this.KEY;\n    \n\n    let time = this.model.time.value;\n\n    if (this.model.ui.chart.lockNonSelected && this.someSelected) {\n      time = this.model.time.parse(\"\" + this.model.ui.chart.lockNonSelected);\n    }\n    this.model.marker.getFrame(time, valuesLocked => {\n      if (!_this._frameIsValid(valuesLocked)) return utils.warn(\"redrawDataPointsOnlyColor: empty data received from marker.getFrame(). doing nothing\");\n\n      valuesNow = _this.frame;\n      _this.entityBubbles.each(function(d, index) {\n\n        const selected = _this.model.marker.isSelected(d);\n\n        const valueC = selected ? valuesNow.color[utils.getKey(d, dataKeys.color)] : valuesLocked.color[utils.getKey(d, dataKeys.color)];\n\n        const scaledC = valueC != null ? _this.cScale(valueC) : _this.COLOR_WHITEISH;\n\n        d3.select(this).style(\"fill\", scaledC);\n\n        //update lines of labels\n        if (selected) {\n\n          const select = utils.find(_this.model.marker.select, f => utils.getKey(f, KEYS) == d[KEY]);\n\n          const trailStartTime = _this.model.time.parse(\"\" + select.trailStartTime);\n\n          _this.model.marker.getFrame(trailStartTime, valuesTrailStart => {\n            if (!valuesTrailStart) return utils.warn(\"redrawDataPointsOnlyColor: empty data received from marker.getFrames(). doing nothing\");\n\n            const cache = {};\n            if (!_this.model.ui.chart.trails || trailStartTime - _this.time == 0) {\n              cache.scaledC0 = scaledC;\n            } else {\n              const valueC = valuesTrailStart.color[utils.getKey(d, dataKeys.color)];\n              cache.scaledC0 = valueC != null ? _this.cScale(valueC) : _this.COLOR_WHITEISH;\n            }\n\n            _this._labels.updateLabelOnlyColor(d, index, cache);\n\n          });\n        }\n      });\n    });\n\n  },\n\n  redrawDataPointsOnlySize() {\n    const _this = this;\n\n    let valuesNow;\n    const dataKeys = this.dataKeys;\n    const KEYS = this.KEYS;\n    const KEY = this.KEY;\n    \n\n    let time = this.model.time.value;\n\n    if (this.model.ui.chart.lockNonSelected && this.someSelected) {\n      time = this.model.time.parse(\"\" + this.model.ui.chart.lockNonSelected);\n    }\n    this.model.marker.getFrame(time, valuesLocked => {\n      if (!_this._frameIsValid(valuesLocked)) return utils.warn(\"redrawDataPointsOnlySize: empty data received from marker.getFrame(). doing nothing\");\n\n      valuesNow = _this.frame;\n      _this.entityBubbles.each(function(d, index) {\n\n        const selected = _this.model.marker.isSelected(d);\n\n        const valueS = selected ? valuesNow.size[utils.getKey(d, dataKeys.size)] : valuesLocked.size[utils.getKey(d, dataKeys.size)];\n        if (valueS == null) return;\n\n        const scaledS = utils.areaToRadius(_this.sScale(valueS));\n        d3.select(this).attr(\"r\", scaledS);\n\n        //update lines of labels\n        if (selected) {\n\n          const select = utils.find(_this.model.marker.select, f => utils.getKey(f, KEYS) == d[KEY]);\n\n          const trailStartTime = _this.model.time.parse(\"\" + select.trailStartTime);\n\n          _this.model.marker.getFrame(trailStartTime, valuesTrailStart => {\n            if (!valuesTrailStart) return utils.warn(\"redrawDataPointsOnlySize: empty data received from marker.getFrames(). doing nothing\");\n\n            const cache = {};\n            if (!_this.model.ui.chart.trails || trailStartTime - _this.time == 0) {\n              cache.scaledS0 = scaledS;\n            } else {\n              cache.scaledS0 = utils.areaToRadius(_this.sScale(valuesTrailStart.size[utils.getKey(d, dataKeys.size)]));\n            }\n\n            _this._labels.updateLabelOnlyPosition(d, index, cache);\n\n          });\n        }\n      });\n    });\n  },\n\n  /*\n   * REDRAW DATA POINTS:\n   * Here plotting happens\n   * debouncing to improve performance: events might trigger it more than 1x\n   */\n  redrawDataPoints(duration) {\n    const _this = this;\n    const KEY = this.KEY;\n    if (duration == null) duration = _this.duration;\n\n    if (this.model.ui.chart.lockNonSelected && this.someSelected) {\n      const time = this.model.time.parse(\"\" + this.model.ui.chart.lockNonSelected);\n\n      //get values for locked frames\n      this.model.marker.getFrame(time, lockedFrame => {\n        if (!lockedFrame) return utils.warn(\"redrawDataPoints: empty data received from marker.getFrames(). doing nothing\");\n\n        // each bubble\n        _this.entityBubbles.each(function(d, index) {\n          const frame = _this.model.marker.isSelected(d) ? _this.frame : lockedFrame;\n          _this._updateBubble(d, frame, index, d3.select(this), duration);\n        });\n      });\n    } else {\n      // each bubble\n      _this.entityBubbles.each(function(d, index) {\n        _this._updateBubble(d, _this.frame, index, d3.select(this), duration);\n      });\n    }\n\n    this._updateLineEqualXY(duration);\n  },\n\n  //redraw Data Points\n  _updateBubble(d, values, index, view, duration) {\n    const _this = this;\n    const dataKeys = this.dataKeys;\n    \n    let showhide = false;\n\n    const valueY = values.axis_y[utils.getKey(d, dataKeys.axis_y)];\n    const valueX = values.axis_x[utils.getKey(d, dataKeys.axis_x)];\n    const valueS = values.size[utils.getKey(d, dataKeys.size)];\n    const valueL = values.label[utils.getKey(d, dataKeys.label)];\n    const valueC = values.color[utils.getKey(d, dataKeys.color)];\n    const valueLST = values.size_label[utils.getKey(d, dataKeys.size_label)];\n\n    // check if fetching data succeeded\n    if (!valueL && valueL !== 0 || !valueY && valueY !== 0 || !valueX && valueX !== 0 || !valueS && valueS !== 0) {\n      // if entity is missing data it should hide\n      if (!d.hidden) {\n        d.hidden = true;\n        showhide = true;\n      }\n\n      if (showhide) {\n        if (duration) {\n          const opacity = view.style(\"opacity\");\n          view.transition().duration(duration).ease(d3.easeExp)\n            .style(\"opacity\", 0)\n            .on(\"end\", () => {\n              //to avoid transition from null state add class with a delay\n              view.classed(\"vzb-invisible\", d.hidden);\n              view.style(\"opacity\", opacity);\n            });\n        } else {\n          //immediately hide the bubble\n          view.classed(\"vzb-invisible\", d.hidden);\n        }\n      }\n    } else {\n      if (d.hidden || view.classed(\"vzb-invisible\")) {\n        d.hidden = false;\n        showhide = true;\n      }\n\n\n      // if entity has all the data we update the visuals\n      const scaledS = utils.areaToRadius(_this.sScale(valueS));\n\n      view.style(\"fill\", valueC != null ? _this.cScale(valueC) : _this.COLOR_WHITEISH);\n\n      if (duration) {\n        if (showhide) {\n          const opacity = view.style(\"opacity\");\n          view.classed(\"vzb-invisible\", d.hidden);\n          view.style(\"opacity\", 0)\n            .attr(\"cy\", _this.yScale(valueY))\n            .attr(\"cx\", _this.xScale(valueX))\n            .attr(\"r\", scaledS)\n            .transition().duration(duration).ease(d3.easeExp)\n            .style(\"opacity\", opacity);\n        } else {\n          view.transition().duration(duration).ease(d3.easeLinear)\n            .attr(\"cy\", _this.yScale(valueY))\n            .attr(\"cx\", _this.xScale(valueX))\n            .attr(\"r\", scaledS);\n        }\n\n      } else {\n\n        //interrupt the ongoing transition and immediately do the visual updates\n        view.interrupt()\n          .attr(\"cy\", _this.yScale(valueY))\n          .attr(\"cx\", _this.xScale(valueX))\n          .attr(\"r\", scaledS)\n          .transition();\n\n        //show entity if it was hidden\n        if (showhide) view.classed(\"vzb-invisible\", d.hidden);\n      }\n\n      if (this.model.time.record) _this._export.write({\n        type: \"circle\",\n        id: d[KEY],\n        time: this.model.time.value.getUTCFullYear(),\n        fill: valueC != null ? _this.cScale(valueC) : _this.COLOR_WHITEISH,\n        cx: _this.xScale(valueX),\n        cy: _this.yScale(valueY),\n        r: scaledS\n      });\n\n    } // data exists\n    _this._updateLabel(d, index, values, valueX, valueY, valueS, valueC, valueL, valueLST, duration, showhide);\n  },\n\n  _updateLabel(d, index, values, valueX, valueY, valueS, valueC, valueL, valueLST, duration, showhide) {\n    const _this = this;\n    const KEYS = this.KEYS;\n    const KEY = this.KEY;\n    \n    // only for selected markers\n    if (_this.model.marker.isSelected(d)) {\n\n      const cache = {};\n\n      const select = utils.find(_this.model.marker.select, f => utils.getKey(f, KEYS) == d[KEY]);\n\n      const time = _this.model.time.formatDate(_this.time);\n      if (!this.model.ui.chart.trails || select.trailStartTime == time || select.trailStartTime == null) {\n        if (this.model.ui.chart.trails && select.trailStartTime == null) select.trailStartTime = time; // need only when trailStartTime == null\n\n        cache.labelX0 = valueX;\n        cache.labelY0 = valueY;\n        cache.scaledC0 = valueC != null ? _this.cScale(valueC) : _this.COLOR_WHITEISH,\n        cache.scaledS0 = (valueS || valueS === 0) ? utils.areaToRadius(_this.sScale(valueS)) : null;\n      }\n\n      const trailStartTime = _this.model.time.parse(\"\" + select.trailStartTime);\n\n      const labelText = _this._getLabelText(values, this.labelNames, d, select.trailStartTime);\n\n      if (showhide && d.hidden && _this.model.ui.chart.trails && trailStartTime && (trailStartTime < _this.time)) showhide = false;\n      if (d.hidden && !_this.model.ui.chart.trails) showhide = true;\n\n      this._labels.updateLabel(d, index, cache, valueX, valueY, valueS, valueC, labelText, valueLST, duration, showhide);\n\n    }\n  },\n\n  _getLabelText(values, labelNames, d, time) {\n    const value = this.KEYS.map(key => values[labelNames[key]] ? values[labelNames[key]][d[key]] : d[key]).join(\", \");    \n    return value + (time || time === 0 ? \" \" + time : \"\");\n  },\n\n  _setTooltip(tooltipText, x, y, s, c, d) {\n    if (tooltipText) {\n      const labelValues = {};\n      if (d) {\n        const dataKeys = this.dataKeys;\n        const values = this.frame;\n        labelValues.valueY = values.axis_y[utils.getKey(d, dataKeys.axis_y)];\n        labelValues.valueX = values.axis_x[utils.getKey(d, dataKeys.axis_x)];\n        labelValues.valueS = values.size[utils.getKey(d, dataKeys.size)];\n        labelValues.valueC = values.color[utils.getKey(d, dataKeys.color)];\n        labelValues.valueLST = values.size_label[utils.getKey(d, dataKeys.size_label)];\n        labelValues.labelText = this._getLabelText(values, this.labelNames, d, this.model.time.formatDate(this.time));\n      }\n\n      const tooltipCache = {};\n      tooltipCache.labelX0 = this.xScale.invert(x);\n      tooltipCache.labelY0 = this.yScale.invert(y);\n      tooltipCache.scaledS0 = s;\n      tooltipCache.scaledC0 = null;\n\n      this._labels.setTooltip(d, tooltipText, tooltipCache, labelValues);\n    } else {\n      this._labels.setTooltip();\n    }\n  },\n\n  _formatSTitleValues(titleS, titleC) {\n    const _this = this;\n    const unitS = this.strings.unit.S;\n    const unitC = this.strings.unit.C;\n\n    const formatterS = this.model.marker.size.getTickFormatter();\n    const formatterC = this.model.marker.color.getTickFormatter();\n\n    //resolve labels for colors via the color legend\n    if (this.model.marker.color.isDiscrete() && this.model.marker.color.use !== \"constant\" && titleC && this.model.marker.color.getColorlegendMarker()) {\n      titleC = this.model.marker.color.getColorlegendMarker().label.getItems()[titleC] || \"\";\n    }\n\n    return [formatterS(titleS) + \" \" + unitS,\n      titleC || titleC === 0 ? formatterC(titleC) + \" \" + unitC : this.translator(\"hints/nodata\")];\n  },\n\n  _updateSTitle(titleS, titleC) {\n\n    // vertical text about size and color\n    if (this.activeProfile.hideSTitle\n      && this.model.ui.dialogs.sidebar.indexOf(\"colors\") > -1\n      && this.model.ui.dialogs.sidebar.indexOf(\"size\") > -1) {\n      this.sTitleEl.classed(\"vzb-invisible\", true);\n      return;\n    }\n    if (this.sTitleEl.classed(\"vzb-invisible\")) {\n      this.sTitleEl.classed(\"vzb-invisible\", false);\n    }\n    const sTitleContentON = this.model.marker.size.use !== \"constant\";\n    const cTitleContentON = this.model.marker.color.use !== \"constant\";\n    const sTitleText = this.sTitleEl.select(\"text\")\n    // reset font size to remove jumpy measurement\n      .style(\"font-size\", null)\n      .text(\n        (sTitleContentON ? this.translator(\"buttons/size\") + \": \" + (titleS ? titleS : this.strings.title.S) : \"\") +\n        (sTitleContentON && cTitleContentON ? \", \" : \"\") +\n        (cTitleContentON ? this.translator(\"buttons/colors\") + \": \" + (titleC ? titleC : this.strings.title.C) : \"\")\n      );\n    const sTitleWidth = sTitleText.node().getBBox().width;\n    const remainigHeight = this.height - 30;\n    const font = parseInt(sTitleText.style(\"font-size\")) * remainigHeight / sTitleWidth;\n    sTitleText.style(\"font-size\", sTitleWidth > remainigHeight ? font + \"px\" : null);\n  },\n\n  selectDataPoints() {\n    const _this = this;\n    const KEY = this.KEY;\n\n    if (utils.isTouchDevice()) {\n      _this.model.marker.clearHighlighted();\n      _this._labels.showCloseCross(null, false);\n    } else {\n      //hide tooltip\n      _this._setTooltip();\n      _this._setBubbleCrown();\n    }\n\n    _this.someSelected = (_this.model.marker.select.length > 0);\n    _this.nonSelectedOpacityZero = false;\n  },\n\n  _setBubbleCrown(x, y, r, glow, skipInnerFill) {\n    if (x != null) {\n      this.bubbleCrown.classed(\"vzb-hidden\", false);\n      this.bubbleCrown.select(\".vzb-crown\")\n        .attr(\"cx\", x)\n        .attr(\"cy\", y)\n        .attr(\"r\", r)\n        .attr(\"fill\", skipInnerFill ? \"none\" : glow);\n      this.bubbleCrown.selectAll(\".vzb-crown-glow\")\n        .attr(\"cx\", x)\n        .attr(\"cy\", y)\n        .attr(\"r\", r + 10)\n        .attr(\"stroke\", glow);\n\n    } else {\n      this.bubbleCrown.classed(\"vzb-hidden\", true);\n    }\n\n  },\n\n  /*\n   * Shows and hides axis projections\n   */\n  _axisProjections(d) {\n    const _this = this;\n    const TIMEDIM = this.TIMEDIM;\n    const dataKeys = this.dataKeys;\n\n    if (d != null) {\n\n      this.model.marker.getFrame(d[TIMEDIM], values => {\n        const valueY = values.axis_y[utils.getKey(d, dataKeys.axis_y)];\n        const valueX = values.axis_x[utils.getKey(d, dataKeys.axis_x)];\n        const valueS = values.size[utils.getKey(d, dataKeys.size)];\n        const radius = utils.areaToRadius(_this.sScale(valueS));\n\n        if (!valueY && valueY !== 0 || !valueX && valueX !== 0 || !valueS && valueS !== 0) return;\n\n        if (_this.model.ui.chart.whenHovering.showProjectionLineX\n          && _this.xScale(valueX) > 0 && _this.xScale(valueX) < _this.width\n          && (_this.yScale(valueY) + radius) < _this.height) {\n          _this.projectionX\n            .style(\"opacity\", 1)\n            .attr(\"y2\", _this.yScale(valueY) + radius)\n            .attr(\"x1\", _this.xScale(valueX))\n            .attr(\"x2\", _this.xScale(valueX));\n        }\n\n        if (_this.model.ui.chart.whenHovering.showProjectionLineY\n          && _this.yScale(valueY) > 0 && _this.yScale(valueY) < _this.height\n          && (_this.xScale(valueX) - radius) > 0) {\n          _this.projectionY\n            .style(\"opacity\", 1)\n            .attr(\"y1\", _this.yScale(valueY))\n            .attr(\"y2\", _this.yScale(valueY))\n            .attr(\"x1\", _this.xScale(valueX) - radius);\n        }\n\n        if (_this.model.ui.chart.whenHovering.higlightValueX) _this.xAxisEl.call(\n          _this.xAxis.highlightValue(valueX)\n        );\n\n        if (_this.model.ui.chart.whenHovering.higlightValueY) _this.yAxisEl.call(\n          _this.yAxis.highlightValue(valueY)\n        );\n      });\n\n    } else {\n\n      this.projectionX.style(\"opacity\", 0);\n      this.projectionY.style(\"opacity\", 0);\n      this.xAxisEl.call(this.xAxis.highlightValue(\"none\"));\n      this.yAxisEl.call(this.yAxis.highlightValue(\"none\"));\n\n    }\n\n  },\n\n  /*\n   * Highlights all hovered bubbles\n   */\n  highlightDataPoints() {\n    const _this = this;\n    const TIMEDIM = this.TIMEDIM;\n    const dataKeys = this.dataKeys;\n    const KEYS = this.KEYS;\n    const KEY = this.KEY;\n    \n    this.someHighlighted = (this.model.marker.highlight.length > 0);\n\n    this.updateBubbleOpacity();\n\n    if (this.model.marker.highlight.length === 1) {\n      const d = utils.clone(this.model.marker.highlight[0]);\n      d[KEY] = utils.getKey(d, KEYS);\n\n      if (_this.model.ui.chart.lockNonSelected && _this.someSelected && !_this.model.marker.isSelected(d)) {\n        d[TIMEDIM] = _this.model.time.parse(\"\" + _this.model.ui.chart.lockNonSelected);\n      } else {\n        d[TIMEDIM] = _this.model.time.parse(\"\" + d.trailStartTime) || _this.time;\n      }\n\n      _this.model.marker.getFrame(d[TIMEDIM], values => {\n        if (!values) return;\n        const x = _this.xScale(values.axis_x[utils.getKey(d, dataKeys.axis_x)]);\n        const y = _this.yScale(values.axis_y[utils.getKey(d, dataKeys.axis_y)]);\n        const s = utils.areaToRadius(_this.sScale(values.size[utils.getKey(d, dataKeys.size)]));\n        const c = values.color[utils.getKey(d, dataKeys.color)] != null ? _this.cScale(values.color[utils.getKey(d, dataKeys.color)]) : _this.COLOR_WHITEISH;\n        let entityOutOfView = false;\n\n        const titles = _this._formatSTitleValues(values.size[utils.getKey(d, dataKeys.size)], values.color[utils.getKey(d, dataKeys.color)]);\n        _this._updateSTitle(titles[0], titles[1]);\n        if (x + s < 0 || x - s > _this.width || y + s < 0 || y - s > _this.height) {\n          entityOutOfView = true;\n        }\n\n        //show tooltip\n        let text = \"\";\n        let hoverTrail = false;\n        if (_this.model.marker.isSelected(d) && _this.model.ui.chart.trails) {\n          text = _this.model.time.formatDate(_this.time);\n          const selectedData = utils.find(_this.model.marker.select, f => utils.getKey(f, KEYS) == d[KEY]);\n          hoverTrail = text !== selectedData.trailStartTime && !d3.select(d3.event.target).classed(\"bubble-\" + d[KEY]);\n          text = text !== selectedData.trailStartTime && _this.time === d[TIMEDIM] ? text : \"\";\n        } else {\n          text = _this.model.marker.isSelected(d) ? \"\" : _this._getLabelText(values, _this.labelNames, d);\n        }\n\n        _this._labels.highlight(null, false);\n        _this._labels.highlight(d, true);\n        if (_this.model.marker.isSelected(d)) {\n          const skipCrownInnerFill = !d.trailStartTime || d.trailStartTime == _this.model.time.formatDate(_this.time);\n          _this._setBubbleCrown(x, y, s, c, skipCrownInnerFill);\n        }\n\n        if (!entityOutOfView && !hoverTrail) {\n          _this._axisProjections(d);\n        }\n\n        //set tooltip and show axis projections\n        if (text && !entityOutOfView && !hoverTrail) {\n          _this._setTooltip(text, x, y, s + 3, c, d);\n        }\n\n        const selectedData = utils.find(_this.model.marker.select, f => utils.getKey(f, KEYS) == d[KEY]);\n        if (selectedData) {\n          const clonedSelectedData = utils.clone(selectedData);\n          //change opacity to OPACITY_HIGHLT = 1.0;\n          clonedSelectedData.opacity = 1.0;\n          _this._trails.run([\"opacityHandler\"], clonedSelectedData);\n        }\n      });\n    } else {\n      this._axisProjections();\n      this._trails.run([\"opacityHandler\"]);\n      //hide tooltip\n      _this._updateSTitle();\n      this._setTooltip();\n      this._setBubbleCrown();\n      this._labels.highlight(null, false);\n    }\n\n  },\n\n  _blinkSuperHighlighted() {\n    this.entityBubbles\n      .classed(\"vzb-super-highlighted\", d => this.model.marker.isSuperHighlighted(d));\n  },\n\n  updateBubbleOpacity(duration) {\n    const _this = this;\n    //if(!duration)duration = 0;\n\n    const OPACITY_HIGHLT = 1.0;\n    const OPACITY_HIGHLT_DIM = this.model.marker.opacityHighlightDim;\n    const OPACITY_SELECT = 1.0;\n    const OPACITY_REGULAR = this.model.marker.opacityRegular;\n    const OPACITY_SELECT_DIM = this.model.marker.opacitySelectDim;\n\n    this.entityBubbles\n    //.transition().duration(duration)\n      .style(\"opacity\", d => {\n\n        if (_this.someHighlighted) {\n          //highlight or non-highlight\n          if (_this.model.marker.isHighlighted(d)) return OPACITY_HIGHLT;\n        }\n\n        if (_this.someSelected) {\n          //selected or non-selected\n          return _this.model.marker.isSelected(d) ? OPACITY_SELECT : OPACITY_SELECT_DIM;\n        }\n\n        if (_this.someHighlighted) return OPACITY_HIGHLT_DIM;\n\n        return OPACITY_REGULAR;\n      });\n\n\n    const nonSelectedOpacityZero = _this.model.marker.opacitySelectDim < 0.01;\n\n    // when pointer events need update...\n    if (nonSelectedOpacityZero != this.nonSelectedOpacityZero) {\n      this.entityBubbles.style(\"pointer-events\", d => (!_this.someSelected || !nonSelectedOpacityZero || _this.model.marker.isSelected(d)) ?\n        \"visible\" : \"none\");\n    }\n\n    this.nonSelectedOpacityZero = _this.model.marker.opacitySelectDim < 0.01;\n  }\n\n});\n\nexport default BubbleChart;\n\n\n\n// WEBPACK FOOTER //\n// ./src/component.js","const { utils } = Vizabi;\n\nconst PanZoom = Vizabi.Class.extend({\n\n  init(context) {\n    this.context = context;\n\n    this.dragRectangle = d3.drag();\n    this.zoomer = d3.zoom();\n\n    // this.dragLock = false;\n\n    this.dragRectangle\n      .subject(this.dragSubject())\n      .on(\"start\", this.drag().start)\n      .on(\"drag\", this.drag().go)\n      .on(\"end\", this.drag().stop);\n\n    this.zoomer\n      .filter(this.zoomFilter())\n      .scaleExtent([0.0625, +Infinity])\n      .on(\"start\", this.zoom().start)\n      .on(\"zoom\", this.zoom().go)\n      .on(\"end\", this.zoom().stop);\n\n    this.zoomer.ratioX = 1;\n    this.zoomer.ratioY = 1;\n\n    context._zoomedXYMinMax = {\n      axis_x: { zoomedMin: null, zoomedMax: null },\n      axis_y: { zoomedMin: null, zoomedMax: null }\n    };\n  },\n\n  dragSubject() {\n    const _this = this.context;\n    const self = this;\n\n    return function(d) {\n      /*\n       * Do not drag if the Ctrl key, Meta key, or plus cursor mode is\n       * not enabled. Also do not drag if zoom-pinching on touchmove\n       * events.\n       */\n      if (!(d3.event.sourceEvent.ctrlKey || d3.event.sourceEvent.metaKey ||\n        _this.ui.cursorMode === \"plus\") || (_this.ui.cursorMode === \"minus\") ||\n        (d3.event.sourceEvent.type === \"touchmove\" || d3.event.sourceEvent.type === \"touchstart\") &&\n        (d3.event.sourceEvent.touches.length > 1 || d3.event.sourceEvent.targetTouches.length > 1)) {\n        return null;\n      }\n\n      return {\n        x: d3.mouse(this)[0],\n        y: d3.mouse(this)[1]\n      };\n    };\n  },\n\n  drag() {\n    const _this = this.context;\n    const self = this;\n\n    return {\n      start(d, i) {\n        /*\n         * Do not drag if the Ctrl key, Meta key, or plus cursor mode is\n         * not enabled. Also do not drag if zoom-pinching on touchmove\n         * events.\n         */\n        //   if(!(d3.event.sourceEvent.ctrlKey || d3.event.sourceEvent.metaKey ||\n        //          _this.ui.cursorMode === \"plus\") ||\n        //          (d3.event.sourceEvent.type === \"touchmove\" || d3.event.sourceEvent.type === \"touchstart\") &&\n        //          (d3.event.sourceEvent.touches.length > 1 || d3.event.sourceEvent.targetTouches.length > 1)) {\n        //         return;\n        //     }\n\n        // self.dragLock = true;\n        this.origin = {\n          x: d3.mouse(this)[0],\n          y: d3.mouse(this)[1]\n        };\n        _this.zoomRect.classed(\"vzb-invisible\", false);\n      },\n\n      go(d, i) {\n        /*\n         * Cancel drag if drag lock is false, or when zoom-pinching via\n         * touchmove events.\n         */\n        // if (!self.dragLock || (d3.event.sourceEvent.type === \"touchmove\" || d3.event.sourceEvent.type === \"touchstart\") &&\n        //             (d3.event.sourceEvent.touches.length > 1 || d3.event.sourceEvent.targetTouches.length > 1)) {\n        //   self.dragLock = false;\n\n        //   _this.zoomRect\n        //     .attr(\"width\", 0)\n        //     .attr(\"height\", 0)\n        //     .classed(\"vzb-invisible\", true);\n\n        //   return;\n        // }\n\n        const origin = this.origin;\n        const mouse = {\n          x: d3.event.x,\n          y: d3.event.y\n        };\n\n        _this.zoomRect\n          .attr(\"x\", Math.min(mouse.x, origin.x))\n          .attr(\"y\", Math.min(mouse.y, origin.y))\n          .attr(\"width\", Math.abs(mouse.x - origin.x))\n          .attr(\"height\", Math.abs(mouse.y - origin.y));\n      },\n\n      stop(e) {\n        // if (!self.dragLock) return;\n        // self.dragLock = false;\n\n        _this.zoomRect\n          .attr(\"width\", 0)\n          .attr(\"height\", 0)\n          .classed(\"vzb-invisible\", true);\n\n        this.target = {\n          x: d3.mouse(this)[0],\n          y: d3.mouse(this)[1]\n        };\n        if (Math.abs(this.origin.x - this.target.x) < 10 || Math.abs(this.origin.y - this.target.y) < 10) return;\n\n        /*\n         * Only compensate for dragging when the Ctrl key or Meta key\n         * are pressed, or if the cursorMode is not in plus mode.\n         */\n        const compensateDragging = d3.event.sourceEvent.ctrlKey ||\n          d3.event.sourceEvent.metaKey ||\n          _this.ui.cursorMode === \"plus\";\n\n        self._zoomOnRectangle(\n          d3.select(this),\n          this.origin.x,\n          this.origin.y,\n          this.target.x,\n          this.target.y,\n          compensateDragging, 500\n        );\n      }\n    };\n  },\n  zoomFilter() {\n    const _this = this.context;\n    const self = this;\n\n    return function(d) {\n      const event = d3.event;\n\n      if (event.ctrlKey || event.metaKey) return false;\n\n      // Cancel drag lock when zoom-pinching via touchmove events.\n      if ((event.type === \"touchmove\" || event.type === \"touchstart\") &&\n        (event.touches.length > 1 || event.targetTouches.length > 1)) return true;\n\n      if ((event.type === \"wheel\" || event.type === \"mousewheel\") &&\n        _this.ui.zoomOnScrolling) {\n        // if (_this.scrollableAncestor) {\n        //   _this.scrollableAncestor.scrollTop -= (event.deltaY || -event.wheelDelta);\n        // }\n        // d3.event.scale = null;\n        //zoomer.scale(this.savedScale);\n        return true;\n      }\n\n      if ((event.type === \"mousedown\" || event.type === \"touchstart\") &&\n        (_this.ui.cursorMode !== \"plus\") && (_this.ui.cursorMode !== \"minus\") &&\n        (_this.ui.panWithArrow || _this.ui.cursorMode === \"hand\")) return true;\n\n      return false;\n    };\n  },\n  zoom() {\n    const _this = this.context;\n    const zoomer = this.zoomer;\n    const self = this;\n\n    return {\n      start() {\n        //this.savedScale = zoomer.scale;\n        if ((_this.ui.cursorMode !== \"plus\") && (_this.ui.cursorMode !== \"minus\")) {\n          _this.chartSvg.classed(\"vzb-zooming\", true);\n        }\n\n        _this.model._data.marker.clearHighlighted();\n        _this._setTooltip();\n\n      },\n      go() {\n\n        const sourceEvent = d3.event.sourceEvent;\n\n        //if (sourceEvent != null && (sourceEvent.ctrlKey || sourceEvent.metaKey)) return;\n\n        // Cancel drag lock when zoom-pinching via touchmove events.\n        // if (sourceEvent !== null &&\n        //             (sourceEvent.type === \"touchmove\" || sourceEvent.type === \"touchstart\") &&\n        //             (sourceEvent.touches.length > 1 || sourceEvent.targetTouches.length > 1)) {\n        //   self.dragLock = false;\n        // }\n\n        //if (self.dragLock) return;\n\n        //send the event to the page if fully zoomed our or page not scrolled into view\n//\n//                    if(d3.event.scale == 1)\n//\n//                    if(utils.getViewportPosition(_this.element.node()).y < 0 && d3.event.scale > 1) {\n//                        _this.scrollableAncestor.scrollTop += d3.event.sourceEvent.deltaY;\n//                        return;\n//                    }\n        /*\n         * Do not zoom on the chart if the scroll event is a wheel\n         * scroll. Instead, redirect the scroll event to the scrollable\n         * ancestor\n         */\n        // if (sourceEvent != null && (sourceEvent.type === \"wheel\" || sourceEvent.type === \"mousewheel\") &&\n        //             !_this.ui.zoomOnScrolling) {\n        //   if (_this.scrollableAncestor) {\n        //     _this.scrollableAncestor.scrollTop += (sourceEvent.deltaY || -sourceEvent.wheelDelta);\n        //   }\n        //   d3.event.scale = null;\n        //             //zoomer.scale(this.savedScale);\n        //   this.quitZoom = true;\n        //   return;\n        // }\n        // this.quitZoom = false;\n\n        //_this.model._data.marker.clearHighlighted();\n        //_this._setTooltip();\n\n        //var transform = d3.zoomTransform(self.zoomSelection.node())\n        //  .translate(, )\n        //.scale(d3.event.transform.k);\n        let zoom = d3.event.transform.k;\n\n        let pan = [d3.event.transform.x, d3.event.transform.y];//d3.event.translate;\n        let ratioY = zoomer.ratioY;\n        let ratioX = zoomer.ratioX;\n\n        _this.draggingNow = true;\n\n        //value protections and fallbacks\n        if (isNaN(zoom) || zoom == null) zoom = zoomer.scale;\n        if (isNaN(zoom) || zoom == null) zoom = 1;\n\n        //TODO: this is a patch to fix #221. A proper code review of zoom and zoomOnRectangle logic is needed\n        /*\n         * Mouse wheel and touchmove events set the zoom value\n         * independently of axis ratios. If the zoom event was triggered\n         * by a mouse wheel event scrolling down or touchmove event with\n         * more than 1 contact that sets zoom to 1, then set the axis\n         * ratios to 1 as well, which will fully zoom out.\n         */\n        if (zoom === 1 && sourceEvent !== null &&\n          ((sourceEvent.type === \"wheel\" || sourceEvent.type === \"mousewheel\") && (sourceEvent.deltaY || -sourceEvent.wheelDelta) > 0 ||\n          sourceEvent.type === \"touchmove\" && sourceEvent.touches.length > 1)) {\n          zoomer.ratioX = 1;\n          ratioX = 1;\n          zoomer.ratioY = 1;\n          ratioY = 1;\n        }\n\n//                if(isNaN(pan[0]) || isNaN(pan[1]) || pan[0] == null || pan[1] == null) pan = zoomer.translate();\n        if (isNaN(pan[0]) || isNaN(pan[1]) || pan[0] == null || pan[1] == null) pan = [0, 0];\n\n        // limit the zooming, so that it never goes below min value of zoom for any of the axes\n        const minZoomScale = zoomer.scaleExtent()[0];\n        if (zoom * ratioY < minZoomScale) {\n          ratioY = minZoomScale / zoom;\n          zoomer.ratioY = ratioY;\n        }\n        if (zoom * ratioX < minZoomScale) {\n          ratioX = minZoomScale / zoom;\n          zoomer.ratioX = ratioX;\n        }\n\n        const zoomXOut = zoom * ratioX < 1;\n        const zoomYOut = zoom * ratioY < 1;\n\n        //limit the panning, so that we are never outside the possible range\n        if (!zoomXOut) {\n          if (pan[0] > 0) pan[0] = 0;\n          if (pan[0] < (1 - zoom * ratioX) * _this.width) pan[0] = (1 - zoom * ratioX) * _this.width;\n        } else {\n          if (pan[0] < 0) pan[0] = 0;\n          if (pan[0] > (1 - zoom * ratioX) * _this.width) pan[0] = (1 - zoom * ratioX) * _this.width;\n        }\n\n        if (!zoomYOut) {\n          if (pan[1] > 0) pan[1] = 0;\n          if (pan[1] < (1 - zoom * ratioY) * _this.height) pan[1] = (1 - zoom * ratioY) * _this.height;\n        } else {\n          if (pan[1] < 0) pan[1] = 0;\n          if (pan[1] > (1 - zoom * ratioY) * _this.height) pan[1] = (1 - zoom * ratioY) * _this.height;\n        }\n\n        //limit zoom translate\n        self.zoomSelection.property(\"__zoom\", d3.zoomIdentity.translate(pan[0], pan[1]).scale(zoom));\n\n        const xPanOffset = _this.width * zoom * ratioX;\n        const yPanOffset = _this.height * zoom * ratioY;\n\n        const xRange = [0 * zoom * ratioX + pan[0], xPanOffset + pan[0]];\n        const yRange = [yPanOffset + pan[1], 0 * zoom * ratioY + pan[1]];\n\n        const xRangeBumped = _this._rangeBump(xRange);\n        const yRangeBumped = _this._rangeBump(yRange);\n\n        /*\n         * Shift xRange and yRange by the difference between the bumped\n         * ranges, which is scaled by the zoom factor. This accounts for\n         * the range bump, which controls a gutter around the\n         * bubblechart, while correctly zooming.\n         */\n        const xRangeMinOffset = (xRangeBumped[0] - xRange[0]) * zoom * ratioX;\n        const xRangeMaxOffset = (xRangeBumped[1] - xRange[1]) * zoom * ratioX;\n\n        const yRangeMinOffset = (yRangeBumped[0] - yRange[0]) * zoom * ratioY;\n        const yRangeMaxOffset = (yRangeBumped[1] - yRange[1]) * zoom * ratioY;\n\n        xRange[0] += xRangeMinOffset;\n        xRange[1] += xRangeMaxOffset;\n\n        yRange[0] += yRangeMinOffset;\n        yRange[1] += yRangeMaxOffset;\n\n        // Calculate the maximum xRange and yRange available.\n        const xRangeBounds = [0, _this.width];\n        const yRangeBounds = [_this.height, 0];\n\n        const xRangeBoundsBumped = _this._rangeBump(xRangeBounds);\n        const yRangeBoundsBumped = _this._rangeBump(yRangeBounds);\n\n        /*\n         * Set the pan to account for the range bump by subtracting\n         * offsets and preventing panning past the range bump gutter.\n         */\n        if (!zoomXOut) {\n          if (xRange[0] > xRangeBoundsBumped[0]) pan[0] = xRangeBoundsBumped[0] - xRangeMinOffset;\n          if (xRange[1] < xRangeBoundsBumped[1]) pan[0] = xRangeBoundsBumped[1] - xRangeMaxOffset - xPanOffset;\n        } else {\n          if (xRange[0] < xRangeBoundsBumped[0]) pan[0] = xRangeBoundsBumped[0] - xRangeMinOffset;\n          if (xRange[1] > xRangeBoundsBumped[1]) pan[0] = xRangeBoundsBumped[1] - xRangeMaxOffset - xPanOffset;\n        }\n\n        if (!zoomYOut) {\n          if (yRange[0] < yRangeBoundsBumped[0]) pan[1] = yRangeBoundsBumped[0] - yRangeMinOffset - yPanOffset;\n          if (yRange[1] > yRangeBoundsBumped[1]) pan[1] = yRangeBoundsBumped[1] - yRangeMaxOffset;\n        } else {\n          if (yRange[0] > yRangeBoundsBumped[0]) pan[1] = yRangeBoundsBumped[0] - yRangeMinOffset - yPanOffset;\n          if (yRange[1] < yRangeBoundsBumped[1]) pan[1] = yRangeBoundsBumped[1] - yRangeMaxOffset;\n        }\n\n        //zoomer.translate = pan;\n        //self.zoomSelection.property(\"__zoom\", d3.zoomIdentity.translate(pan[0], pan[1]).scale(zoom));\n\n        /*\n         * Clamp the xRange and yRange by the amount that the bounds\n         * that are range bumped.\n         *\n         * Additionally, take the amount clamped on the end of the range\n         * and either subtract or add it to the range's other end. This\n         * prevents visible stretching of the range when only panning.\n         */\n        if (!zoomXOut) {\n          if (xRange[0] > xRangeBoundsBumped[0]) {\n            xRange[1] -= Math.abs(xRange[0] - xRangeBoundsBumped[0]);\n            xRange[0] = xRangeBoundsBumped[0];\n          }\n\n          if (xRange[1] < xRangeBoundsBumped[1]) {\n            xRange[0] += Math.abs(xRange[1] - xRangeBoundsBumped[1]);\n            xRange[1] = xRangeBoundsBumped[1];\n          }\n        } else {\n          if (xRange[0] < xRangeBoundsBumped[0]) {\n            xRange[1] += Math.abs(xRange[0] - xRangeBoundsBumped[0]);\n            xRange[0] = xRangeBoundsBumped[0];\n          }\n\n          if (xRange[1] > xRangeBoundsBumped[1]) {\n            xRange[0] -= Math.abs(xRange[1] - xRangeBoundsBumped[1]);\n            xRange[1] = xRangeBoundsBumped[1];\n          }\n        }\n\n        if (!zoomYOut) {\n          if (yRange[0] < yRangeBoundsBumped[0]) {\n            yRange[1] += Math.abs(yRange[0] - yRangeBoundsBumped[0]);\n            yRange[0] = yRangeBoundsBumped[0];\n          }\n\n          if (yRange[1] > yRangeBoundsBumped[1]) {\n            yRange[0] -= Math.abs(yRange[1] - yRangeBoundsBumped[1]);\n            yRange[1] = yRangeBoundsBumped[1];\n          }\n        } else {\n          if (yRange[0] > yRangeBoundsBumped[0]) {\n            yRange[1] -= Math.abs(yRange[0] - yRangeBoundsBumped[0]);\n            yRange[0] = yRangeBoundsBumped[0];\n          }\n\n          if (yRange[1] < yRangeBoundsBumped[1]) {\n            yRange[0] += Math.abs(yRange[1] - yRangeBoundsBumped[1]);\n            yRange[1] = yRangeBoundsBumped[1];\n          }\n        }\n\n        if (_this.model.marker.axis_x.scaleType === \"ordinal\") {\n          _this.xScale.rangeBands(xRange);\n        } else {\n          _this.xScale.range(xRange);\n        }\n\n        if (_this.model.marker.axis_y.scaleType === \"ordinal\") {\n          _this.yScale.rangeBands(yRange);\n        } else {\n          _this.yScale.range(yRange);\n        }\n\n        const formatter = function(n) {\n          return utils.isDate(n) ? n : +n.toFixed(2);\n        };\n\n        const zoomedXRange = xRangeBoundsBumped;\n        const zoomedYRange = yRangeBoundsBumped;\n\n        /*\n         * Set the zoomed min/max to the correct value depending on if the\n         * min/max values lie within the range bound regions.\n         */\n        /*\n         if(!zoomXOut) {\n         zoomedXRange[0] = xRangeBounds[0] > xRange[0] ? xRangeBounds[0] : xRange[0];\n         zoomedXRange[1] = xRangeBounds[1] < xRange[1] ? xRangeBounds[1] : xRange[1];\n         }\n\n         if(!zoomYOut) {\n         zoomedYRange[0] = yRangeBounds[0] < yRange[0] ? yRangeBounds[0] : yRange[0];\n         zoomedYRange[1] = yRangeBounds[1] > yRange[1] ? yRangeBounds[1] : yRange[1];\n         }\n         */\n\n        _this._zoomedXYMinMax = {\n          axis_x: {\n            zoomedMin: formatter(_this.xScale.invert(zoomedXRange[0])),\n            zoomedMax: formatter(_this.xScale.invert(zoomedXRange[1]))\n          },\n          axis_y: {\n            zoomedMin: formatter(_this.yScale.invert(zoomedYRange[0])),\n            zoomedMax: formatter(_this.yScale.invert(zoomedYRange[1]))\n          }\n        };\n\n\n        if (!zoomer.dontFeedToState) _this.model.marker.set(_this._zoomedXYMinMax, null, false /*avoid storing it in URL*/);\n\n        const optionsY = _this.yAxis.labelerOptions();\n        const optionsX = _this.xAxis.labelerOptions();\n        optionsY.limitMaxTickNumber = zoom * ratioY < 1.5 ? 8 : zoom * ratioY * 8;\n        optionsX.limitMaxTickNumber = zoom * ratioX < 1.5 ? 8 : zoom * ratioX * 8;\n        optionsY.transitionDuration = zoomer.duration;\n        optionsX.transitionDuration = zoomer.duration;\n\n        _this.xAxisEl.call(_this.xAxis.labelerOptions(optionsX));\n        _this.yAxisEl.call(_this.yAxis.labelerOptions(optionsY));\n        _this.redrawDataPoints(zoomer.duration);\n        _this._trails.run(\"resize\", null, zoomer.duration);\n\n        zoomer.duration = 0;\n      },\n\n      stop() {\n        _this.chartSvg.classed(\"vzb-zooming\", false);\n\n        _this.draggingNow = false;\n\n        // if (this.quitZoom) return;\n\n        //Force the update of the URL and history, with the same values\n        if (!zoomer.dontFeedToState) _this.model.marker.set(_this._zoomedXYMinMax, true, true);\n        zoomer.dontFeedToState = null;\n      }\n    };\n  },\n\n  expandCanvas(duration) {\n    const _this = this.context;\n    if (!duration) duration = _this.duration;\n\n    //d3 extent returns min and max of the input array as [min, max]\n    const mmX = d3.extent(utils.values(_this.frame.axis_x));\n    const mmY = d3.extent(utils.values(_this.frame.axis_y));\n\n    //protection agains unreasonable min-max results -- abort function\n    if (!mmX[0] && mmX[0] !== 0 || !mmX[1] && mmX[1] !== 0 || !mmY[0] && mmY[0] !== 0 || !mmY[1] && mmY[1] !== 0) {\n      return utils.warn(\"panZoom.expandCanvas: X or Y min/max are broken. Aborting with no action\");\n    }\n    /*\n     * Use a range bumped scale to correctly accommodate the range bump\n     * gutter.\n     */\n    const suggestedFrame = {\n      x1: _this.xScale(mmX[0]),\n      y1: _this.yScale(mmY[0]),\n      x2: _this.xScale(mmX[1]),\n      y2: _this.yScale(mmY[1])\n    };\n    const xBounds = [0, _this.width];\n    const yBounds = [_this.height, 0];\n\n    // Get the current zoom frame based on the current dimensions.\n    const frame = {\n      x1: xBounds[0],\n      x2: xBounds[1],\n      y1: yBounds[0],\n      y2: yBounds[1]\n    };\n\n    const TOLERANCE = 0.0;\n\n    /*\n     * If there is no current zoom frame, or if any of the suggested frame\n     * points extend outside of the current zoom frame, then expand the\n     * canvas.\n     */\n    if (!_this.isCanvasPreviouslyExpanded ||\n      suggestedFrame.x1 < frame.x1 * (1 - TOLERANCE) || suggestedFrame.x2 > frame.x2 * (1 + TOLERANCE) ||\n      suggestedFrame.y2 < frame.y2 * (1 - TOLERANCE) || suggestedFrame.y1 > frame.y1 * (1 + TOLERANCE)) {\n      /*\n       * If there is already a zoom frame, then clamp the suggested frame\n       * points to only zoom out and expand the canvas.\n       *\n       * If any of x1, x2, y1, or y2 is within the current frame\n       * boundaries, then clamp them to the frame boundaries. If any of\n       * the above values will translate into a data value that is outside\n       * of the possible data range, then clamp them to the frame\n       * coordinate that corresponds to the maximum data value that can\n       * be displayed.\n       */\n      if (_this.isCanvasPreviouslyExpanded) {\n        /*\n         * Calculate bounds and bumped scale for calculating the data boundaries\n         * to which the suggested frame points need to be clamped.\n         */\n        const xBoundsBumped = _this._rangeBump(xBounds);\n        const yBoundsBumped = _this._rangeBump(yBounds);\n\n        if (suggestedFrame.x1 > xBoundsBumped[0]) suggestedFrame.x1 = xBoundsBumped[0];\n        if (suggestedFrame.x2 < xBoundsBumped[1]) suggestedFrame.x2 = xBoundsBumped[1];\n        if (suggestedFrame.y1 < yBoundsBumped[0]) suggestedFrame.y1 = yBoundsBumped[0];\n        if (suggestedFrame.y2 > yBoundsBumped[0]) suggestedFrame.y2 = yBoundsBumped[1];\n      }\n\n      _this.isCanvasPreviouslyExpanded = true;\n      this._zoomOnRectangle(_this.element, suggestedFrame.x1, suggestedFrame.y1,\n        suggestedFrame.x2, suggestedFrame.y2, false, duration);\n    } else {\n      _this.redrawDataPoints(duration);\n    }\n  },\n\n  zoomToMaxMin(zoomedMinX, zoomedMaxX, zoomedMinY, zoomedMaxY, duration, dontFeedToState) {\n    const _this = this.context;\n    let minX = zoomedMinX;\n    let maxX = zoomedMaxX;\n    let minY = zoomedMinY;\n    let maxY = zoomedMaxY;\n\n    const xDomain = _this.xScale.domain();\n    const yDomain = _this.yScale.domain();\n\n    /*\n     * Prevent zoomout if only one of zoom edges set outside domain\n     */\n    if (minX < xDomain[0] && maxX < xDomain[1]) minX = xDomain[0];\n    if (minX > xDomain[0] && maxX > xDomain[1]) maxX = xDomain[1];\n    if (minY < yDomain[0] && maxY < yDomain[1]) minY = yDomain[0];\n    if (minY > yDomain[0] && maxY > yDomain[1]) maxY = yDomain[1];\n\n\n    const xRange = [_this.xScale(minX), _this.xScale(maxX)];\n    const yRange = [_this.yScale(minY), _this.yScale(maxY)];\n\n\n    this._zoomOnRectangle(_this.element, xRange[0], yRange[0], xRange[1], yRange[1], false, duration, dontFeedToState);\n  },\n\n  _zoomOnRectangle(element, zoomedX1, zoomedY1, zoomedX2, zoomedY2, compensateDragging, duration, dontFeedToState) {\n    const _this = this.context;\n    const zoomer = this.zoomer;\n    const transform = d3.zoomTransform(this.zoomSelection.node());\n\n    const x1 = zoomedX1;\n    const y1 = zoomedY1;\n    const x2 = zoomedX2;\n    const y2 = zoomedY2;\n\n    /*\n     * When dragging to draw a rectangle, the translate vector has (x2 - x1)\n     * added to zoomer.translate()[0], and (y2 - 1) added to\n     * zoomer.translate()[1].\n     *\n     * We need to compensate for this addition when\n     * zooming with a rectangle, because zooming with a rectangle will\n     * update the translate vector with new values based on the rectangle\n     * dimensions.\n     */\n    if (compensateDragging) {\n      transform.translate(\n        x1 - x2,\n        y1 - y2\n      );\n      // zoomer.translate([\n      //     zoomer.translate()[0] + x1 - x2,\n      //     zoomer.translate()[1] + y1 - y2\n      // ]);\n    }\n\n    const xRangeBounds = [0, _this.width];\n    const yRangeBounds = [_this.height, 0];\n\n    const xRangeBoundsBumped = _this._rangeBump(xRangeBounds);\n    const yRangeBoundsBumped = _this._rangeBump(yRangeBounds);\n\n    const minZoom = zoomer.scaleExtent()[0];\n    const maxZoom = zoomer.scaleExtent()[1];\n    let zoom, ratioX, ratioY;\n\n    if (x1 == x2 || y1 == y2 || xRangeBoundsBumped[0] == xRangeBoundsBumped[1] || yRangeBoundsBumped[0] == yRangeBoundsBumped[1]) {\n      return utils.warn(\"_zoomOnRectangle(): can not proceed because this may result in infinity zooms\");\n    }\n\n    if (Math.abs(x1 - x2) > Math.abs(y1 - y2)) {\n      zoom = Math.abs(yRangeBoundsBumped[0] - yRangeBoundsBumped[1]) / Math.abs(y1 - y2) * transform.k;\n\n      /*\n       * Clamp the zoom scalar to the maximum zoom allowed before\n       * calculating the next ratioX and ratioY.\n       */\n      if (zoom < minZoom) {\n        zoomer.ratioY *= zoom / transform.k;\n        zoom = minZoom;\n      }\n      if (zoom > maxZoom) zoom = maxZoom;\n\n      ratioX = Math.abs(xRangeBoundsBumped[0] - xRangeBoundsBumped[1]) / Math.abs(x1 - x2) * transform.k / zoom * zoomer.ratioX;\n      ratioY = zoomer.ratioY;\n    } else {\n      zoom = Math.abs(xRangeBoundsBumped[0] - xRangeBoundsBumped[1]) / Math.abs(x1 - x2) * transform.k;\n\n      /*\n       * Clamp the zoom scalar to the maximum zoom allowed before\n       * calculating the next ratioX and ratioY.\n       */\n      if (zoom < minZoom) {\n        zoomer.ratioX *= zoom / transform.k;\n        zoom = minZoom;\n      }\n      if (zoom > maxZoom) zoom = maxZoom;\n\n      ratioY = Math.abs(yRangeBoundsBumped[0] - yRangeBoundsBumped[1]) / Math.abs(y1 - y2) * transform.k / zoom * zoomer.ratioY;\n      ratioX = zoomer.ratioX;\n    }\n\n    const pan = [\n      (transform.x - Math.min(x1, x2)) / transform.k / zoomer.ratioX * zoom * ratioX + (xRangeBoundsBumped[0] - xRangeBounds[0]),\n      (transform.y - Math.min(y1, y2)) / transform.k / zoomer.ratioY * zoom * ratioY + (yRangeBoundsBumped[1] - yRangeBounds[1])\n    ];\n\n    zoomer.dontFeedToState = dontFeedToState;\n    //zoomer.scale(zoom);\n    zoomer.ratioY = ratioY || 1; //NaN defaults to 1\n    zoomer.ratioX = ratioX || 1; //NaN defaults to 1\n    //zoomer.translate(pan);\n    zoomer.duration = duration ? duration : 0;\n\n    //zoomer.event(element);\n    this.zoomSelection.call(zoomer.transform, d3.zoomIdentity.translate(pan[0], pan[1]).scale(zoom));\n  },\n\n  /*\n   * Incrementally zoom in or out and pan the view so that it never looses the point where click happened\n   * this function is a modified d3's own zoom behavior on double click\n   * for the original code see https://github.com/mbostock/d3/blob/master/src/behavior/zoom.js\n   * function dblclicked() and what it refers to\n   */\n  zoomByIncrement(direction, duration) {\n    const _this = this.context;\n    const transform = d3.zoomTransform(this.zoomSelection.node());\n\n    let ratio = transform.k;\n    const pan = [transform.x, transform.y];\n\n    const mouse = d3.mouse(this.zoomSelection.node());\n    let k = Math.log(ratio) / Math.LN2;\n\n    //change factor direction based on the input. default is no direction supplied\n    if (direction == \"plus\" || !direction) k = Math.floor(k) + 1;\n    if (direction == \"minus\") k = Math.ceil(k) - 1;\n\n    //decode panning\n    let locus = [(mouse[0] - pan[0]) / ratio, (mouse[1] - pan[1]) / ratio];\n\n    //recalculate zoom ratio\n    const scaleExtent = this.zoomer.scaleExtent();\n    if (ratio == scaleExtent[0]) {\n      this.zoomer.ratioY = 1;\n      this.zoomer.ratioX = 1;\n    }\n    ratio = Math.max(scaleExtent[0], Math.min(scaleExtent[1], Math.pow(2, k)));\n\n    //recalculate panning\n    locus = [locus[0] * ratio + pan[0], locus[1] * ratio + pan[1]];\n    pan[0] += mouse[0] - locus[0];\n    pan[1] += mouse[1] - locus[1];\n\n    //save changes to the zoom behavior and run the event\n    //this.zoomer.scale(ratio);\n    //this.zoomer.translate([pan[0], pan[1]]);\n    this.zoomer.duration = duration || 0;\n    //this.zoomer.event(_this.element);\n    this.zoomSelection.call(this.zoomer.transform, d3.zoomIdentity.translate(pan[0], pan[1]).scale(ratio));\n\n  },\n\n\n  /*\n   * Reset zoom values without triggering a zoom event.\n   */\n  resetZoomState(element) {\n    //this.zoomer.scaleTo(element, 1);\n    this.zoomer.ratioY = 1;\n    this.zoomer.ratioX = 1;\n    //this.zoomer.translate([0, 0]);\n    (element || this.zoomSelection).property(\"__zoom\", d3.zoomIdentity);\n  },\n\n  reset(element, duration) {\n    const _this = this.context;\n    _this.isCanvasPreviouslyExpanded = false;\n\n    //this.zoomer.scale(1);\n    this.zoomer.ratioY = 1;\n    this.zoomer.ratioX = 1;\n    //this.zoomer.translate([0, 0]);\n    this.zoomer.duration = duration || 0;\n    //this.zoomer.event(element || _this.element);\n    (element || this.zoomSelection).call(this.zoomer.transform, d3.zoomIdentity);\n  },\n\n  rerun(element) {\n    const _this = this.context;\n    //this.zoomer.event(element || _this.element);\n    (element || this.zoomSelection).call(this.zoomer.scaleBy, 1);\n  },\n\n  zoomSelection(element) {\n    this.zoomSelection = element;\n  }\n\n});\n\nexport default PanZoom;\n\n\n// WEBPACK FOOTER //\n// ./src/panzoom.js","\nimport cssEscape from \"css.escape\";\n\nconst { utils } = Vizabi;\n\nconst Trail = Vizabi.Class.extend({\n\n  init(context) {\n    this.context = context;\n    this._isCreated = null;\n    this.actionsQueue = {};\n    this.entityTrails = {};\n    this.trailsData = [];\n    this.trailsInProgress = {};\n    this.activePromises = {};\n    this.trailTransitions = {};\n    this.delayedIterations = {};\n    this.drawingQueue = {};\n  },\n\n  toggle(arg) {\n    const _context = this.context;\n    if (arg) {\n\n      _context._trails.create().then(() => {\n        _context._trails.run([\"findVisible\", \"reveal\", \"opacityHandler\"]);\n      });\n    } else {\n      _context._trails.run(\"remove\");\n      _context.model.marker.select.forEach(d => {\n        delete d.trailStartTime;\n      });\n    }\n  },\n\n  create(selection) {\n    const _context = this.context;\n    const _this = this;\n    const KEYS = _context.KEYS;\n    const KEY = _context.KEY;\n    const dataKeys = _context.dataKeys;\n    const TIMEDIM = _context.TIMEDIM;\n    this._isCreated = new Promise((resolve, reject) => {\n      //quit if the function is called accidentally\n      if (!_context.model.ui.chart.trails) return;\n\n      const timePoints = _context.model.time.getAllSteps();\n\n      //work with marker.select (all selected entities), if no particular selection is specified\n      const promises = [];\n      selection = selection == null ? _context.model.marker.select : [selection];\n      _this._clearActions(selection);\n      _this.trailsData = _context.model.marker.select.map(d => {\n        const r = {\n          status: \"created\",\n          selectedEntityData: d\n        };\n        KEYS.forEach(key => r[key] = d[key]);\n        r[KEY] = utils.getKey(d, KEYS);\n        return r;\n      });\n      _this.trailTransitions = {};\n      const _trails = _context.bubbleContainer.selectAll(\"g.vzb-bc-entity.entity-trail\")\n        .data(_this.trailsData, d => (d[KEY]));\n\n      _trails.exit().remove();\n      _trails.enter()\n        .insert(\"g\", function(d) {\n          return this.querySelector(\".bubble-\" + cssEscape(d[KEY]));\n        })\n        .attr(\"class\", d => \"vzb-bc-entity entity-trail trail-\" + d[KEY])\n        .merge(_trails)\n        .each(function(d, index) {\n          // used for prevent move trail start time forward when we have empty values at end of time range\n          const trail = this;\n          promises.push(new Promise((resolve, reject) => {\n            const trailSegmentData = timePoints.map(m => ({\n              t: m,\n              key: d[KEY]\n            }));\n            const entityTrails = d3.select(trail).selectAll(\"g\")\n              .data(trailSegmentData)\n              .classed(\"vzb-invisible\", true);\n\n            entityTrails.exit().remove();\n\n            _this.entityTrails[d[KEY]] = entityTrails.enter().append(\"g\")\n              .attr(\"class\", \"vzb-bc-trailsegment vzb-invisible\")\n              .on(\"mouseover\", function(segment, index) {\n                if (utils.isTouchDevice()) return;\n\n                const pointer = {};\n                pointer[KEY] = segment.key;\n                pointer[TIMEDIM] = segment.t;\n\n                _context._axisProjections(pointer);\n                _context._labels.highlight(d, true);\n                const text = _context.model.time.formatDate(segment.t);\n                const selectedData = utils.find(_context.model.marker.select, f => utils.getKey(f, KEYS) == d[KEY]);\n                _context.model.marker.getFrame(pointer[TIMEDIM], values => {\n                  const x = _context.xScale(values.axis_x[utils.getKey(d, dataKeys.axis_x)]);\n                  const y = _context.yScale(values.axis_y[utils.getKey(d, dataKeys.axis_y)]);\n                  const s = utils.areaToRadius(_context.sScale(values.size[utils.getKey(d, dataKeys.size)]));\n                  const c = values.color[utils.getKey(d, dataKeys.color)] != null ? _context.cScale(values.color[utils.getKey(d, dataKeys.color)]) : _context.COLOR_WHITEISH;\n                  if (text !== selectedData.trailStartTime) {\n                    _context._setTooltip(text, x, y, s + 3, c);\n                  }\n                  _context._setBubbleCrown(x, y, s, c);\n                  _context.model.marker.getModelObject(\"highlight\").trigger(\"change\", {\n                    \"size\": values.size[utils.getKey(d, dataKeys.size)],\n                    \"color\": values.color[utils.getKey(d, dataKeys.color)]\n                  });\n                });\n                //change opacity to OPACITY_HIGHLT = 1.0;\n                d3.select(this).style(\"opacity\", 1.0);\n              })\n              .on(\"mouseout\", function(segment, index) {\n                if (utils.isTouchDevice()) return;\n                _context._axisProjections();\n                _context._setTooltip();\n                _context._setBubbleCrown();\n                _context._labels.highlight(null, false);\n                _context.model.marker.getModelObject(\"highlight\").trigger(\"change\", null);\n                d3.select(this).style(\"opacity\", _context.model.marker.opacityRegular);\n              })\n              .each(function(segment, index) {\n                const view = d3.select(this);\n                view.append(\"circle\");\n                view.append(\"line\");\n              })\n              .merge(entityTrails);\n            resolve();\n          }));\n        });\n      if (promises.length > 0) {\n        Promise.all(promises).then(segments => {\n          resolve(true);\n        });\n      } else {\n        resolve(true);\n      }\n    });\n    return this._isCreated;\n  },\n\n  /**\n   * add actions for each selected entities\n   * @param selections\n   * @param actions\n   * @private\n   */\n  _addActions(selections, actions) {\n    const _context = this.context;\n    const _this = this;\n    const KEYS = _context.KEYS;\n\n    selections.forEach(d => {\n      const key = utils.getKey(d, KEYS);\n      if (!_this.actionsQueue[key]) _this.actionsQueue[key] = [];\n      _this.actionsQueue[key] = [].concat(_this.actionsQueue[key].filter(value => actions.indexOf(value) == -1), actions);\n    });\n  },\n\n  _clearActions(selections) {\n    const _context = this.context;\n    const _this = this;\n    const KEYS = _context.KEYS;\n    \n    selections.forEach(d => {\n      const key = utils.getKey(d, KEYS);\n      if (!_this.actionsQueue[key]) _this.actionsQueue[key] = [];\n      _this.actionsQueue[key] = [];\n      _this.drawingQueue[key] = {};\n      _this.delayedIterations[key] = {};\n      if (!_this.activePromises[key]) _this.activePromises[key] = [];\n      utils.forEach(_this.activePromises[key], (promise, key) => {\n        if (promise.status === \"pending\") promise.reject();\n      });\n      _this.trailsInProgress[key] = null;\n      _this.activePromises[key] = [];\n    });\n  },\n\n  _getNextAction(key) {\n    return this.actionsQueue[key].shift();\n  },\n\n  run(actions, selection, duration) {\n    const _context = this.context;\n    const _this = this;\n    const KEY = _context.KEY;\n    if (!this._isCreated || _context.model.time.splash) return;\n    if (typeof actions === \"string\") actions = [actions];\n\n    this._isCreated.then(() => {\n      //quit if function is called accidentally\n      if ((!_context.model.ui.chart.trails || !_context.model.marker.select.length) && actions != \"remove\") return;\n\n      if (!duration) duration = 0;\n\n      //work with marker.select (all selected entities), if no particular selection is specified\n      selection = selection == null ? _context.model.marker.select : [selection];\n      for (let i = 0; i < actions.length; i++) {\n        if ([\"resize\", \"recolor\", \"remove\"].indexOf(actions[i]) != -1) {\n          const action = actions.splice(i, 1).pop();\n          --i;\n          _this.trailsData.forEach(d => {\n            const trail = _this.entityTrails[d[KEY]];\n            _context._trails[\"_\" + action](trail, duration, d);\n          });\n        }\n      }\n      if (actions.length == 0) {\n        return;\n      }\n      _this._addActions(selection, actions);\n      _this.trailsData.forEach(d => {\n        if (actions.indexOf(\"findVisible\") != -1) {\n          _this.drawingQueue[d[KEY]] = {};\n          _this.delayedIterations[d[KEY]] = {};\n        }\n        const trail = _this.entityTrails[d[KEY]];\n        //do all the actions over \"trail\"\n        const executeSequential = function(index) { // some function can be async, but we should run next when previous completed\n          const action = _this._getNextAction(d[KEY]);\n          if (action) {\n            _this.trailsInProgress[d[KEY]] = action;\n            const response = _context._trails[\"_\" + action](trail, duration, d);\n            if (response && response instanceof Promise) {\n              response.then(() => {\n                _this.trailsInProgress[d[KEY]] = null;\n                executeSequential(index + 1);\n              }, () => {\n                _this.trailsInProgress[d[KEY]] = null;\n              });\n            } else {\n              _this.trailsInProgress[d[KEY]] = null;\n              executeSequential(index + 1);\n            }\n          }\n        };\n        if (!_this.trailsInProgress[d[KEY]]) {\n          executeSequential(0);\n        }\n      });\n    });\n\n  },\n\n\n  _remove(trail, duration, d) {\n    this.actionsQueue[d[this.context.KEY]] = [];\n    if (trail) { // TODO: in some reason run twice\n      d3.select(this.entityTrails[d[this.context.KEY]].node().parentNode).remove();\n      this.entityTrails[d[this.context.KEY]] = null;\n    }\n  },\n\n  _resize(trail, duration, d) {\n    const _context = this.context;\n    if (_context.model.time.splash) {\n      return;\n    }\n//    this._isCreated.then(function() {\n    let updateLabel = false;\n\n    trail.each(function(segment, index) {\n\n      if (segment.valueY == null || segment.valueX == null || segment.valueS == null) return;\n\n      const view = d3.select(this);\n      if (duration) {\n        view.select(\"circle\")\n          .transition().duration(duration).ease(d3.easeLinear)\n          .attr(\"cy\", _context.yScale(segment.valueY))\n          .attr(\"cx\", _context.xScale(segment.valueX))\n          .attr(\"r\", utils.areaToRadius(_context.sScale(segment.valueS)));\n      } else {\n        view.select(\"circle\").interrupt()\n          .attr(\"cy\", _context.yScale(segment.valueY))\n          .attr(\"cx\", _context.xScale(segment.valueX))\n          .attr(\"r\", utils.areaToRadius(_context.sScale(segment.valueS)))\n          .transition();\n      }\n\n      if (!updateLabel && !segment.transparent) {\n        updateLabel = true;\n        _context._labels.updateLabelOnlyPosition(d, null, { \"scaledS0\": utils.areaToRadius(_context.sScale(segment.valueS)) });\n      }\n\n      if (!segment.next) return;\n      const next = segment.next;\n      if (next == null) return;\n      if (next.valueY == null || next.valueX == null) return;\n\n      const lineLength = Math.sqrt(\n        Math.pow(_context.xScale(segment.valueX) - _context.xScale(next.valueX), 2) +\n        Math.pow(_context.yScale(segment.valueY) - _context.yScale(next.valueY), 2)\n      );\n      if (duration) {\n        view.select(\"line\")\n          .transition().duration(duration).ease(d3.easeLinear)\n          .attr(\"x1\", _context.xScale(next.valueX))\n          .attr(\"y1\", _context.yScale(next.valueY))\n          .attr(\"x2\", _context.xScale(segment.valueX))\n          .attr(\"y2\", _context.yScale(segment.valueY))\n          .attr(\"stroke-dasharray\", lineLength)\n          .attr(\"stroke-dashoffset\", utils.areaToRadius(_context.sScale(segment.valueS)));\n      } else {\n        view.select(\"line\").interrupt()\n          .attr(\"x1\", _context.xScale(next.valueX))\n          .attr(\"y1\", _context.yScale(next.valueY))\n          .attr(\"x2\", _context.xScale(segment.valueX))\n          .attr(\"y2\", _context.yScale(segment.valueY))\n          .attr(\"stroke-dasharray\", lineLength)\n          .attr(\"stroke-dashoffset\", utils.areaToRadius(_context.sScale(segment.valueS)))\n          .transition();\n      }\n    });\n  },\n\n  _recolor(trail, duration, d) {\n    const _context = this.context;\n\n    trail.each(function(segment, index) {\n\n      const view = d3.select(this);\n\n      const strokeColor = _context.model.marker.color.which == \"geo.world_4region\" ?\n        //use predefined shades for color palette for \"geo.world_4region\" (hardcoded)\n        _context.model.marker.color.getColorShade({\n          colorID: segment.valueC,\n          shadeID: \"shade\"\n        })\n        :\n        //otherwise use color of the bubble with a fallback to bubble stroke color (blackish)\n        (segment.valueC != null ? _context.cScale(segment.valueC) : _context.COLOR_BLACKISH);\n\n      view.select(\"circle\")\n      //.transition().duration(duration).ease(d3.easeLinear)\n        .style(\"fill\", segment.valueC != null ? _context.cScale(segment.valueC) : _context.COLOR_WHITEISH);\n      view.select(\"line\")\n      //.transition().duration(duration).ease(d3.easeLinear)\n        .style(\"stroke\", strokeColor);\n    });\n  },\n\n  _opacityHandler(trail, duration, d) {\n    const _context = this.context;\n\n    trail.each(function(segment, index) {\n\n      const view = d3.select(this);\n\n      view\n      //.transition().duration(duration).ease(d3.easeLinear)\n        .style(\"opacity\", d.opacity || _context.model.marker.opacityRegular);\n    });\n  },\n\n\n  _findVisible(trail, duration, d) {\n    const _context = this.context;\n    const _this = this;\n    const KEY = _context.KEY;\n    const dataKeys = _context.dataKeys;\n    return new Promise((resolve, reject) => {\n      new Promise((resolve1, reject1) => {\n        if (!d.limits) {\n          _context.model.marker.getEntityLimits(d[KEY]).then(limits => {\n            d.limits = limits;\n            resolve1();\n          });\n        } else {\n          resolve1();\n        }\n      }).then(() => {\n        if (!d.selectedEntityData.trailStartTime) {\n          d.selectedEntityData.trailStartTime = _context.model.time.formatDate(_context.time);\n        }\n        let trailStartTime = _context.model.time.parse(\"\" + d.selectedEntityData.trailStartTime);\n        if (_context.time - trailStartTime < 0 || d.limits.min - trailStartTime > 0) {\n          if (_context.time - trailStartTime < 0) {\n            // move trail start time with trail label back if need\n            d.selectedEntityData.trailStartTime = _context.model.time.formatDate(d3.max([_context.time, d.limits.min]));\n            trailStartTime = _context.model.time.parse(\"\" + d.selectedEntityData.trailStartTime);\n          } else {\n            // move trail start time with trail label to start time if need\n            d.selectedEntityData.trailStartTime = _context.model.time.formatDate(d.limits.min);\n            trailStartTime = _context.model.time.parse(\"\" + d.selectedEntityData.trailStartTime);\n          }\n          const cache = _context._labels.cached[d[KEY]];\n          const valueS = _context.frame.size[utils.getKey(d, dataKeys.size)];\n          const valueC = _context.frame.color[utils.getKey(d, dataKeys.color)];\n          cache.labelX0 = _context.frame.axis_x[utils.getKey(d, dataKeys.axis_x)];\n          cache.labelY0 = _context.frame.axis_y[utils.getKey(d, dataKeys.axis_y)];\n          cache.scaledS0 = (valueS || valueS === 0) ? utils.areaToRadius(_context.sScale(valueS)) : null;\n          cache.scaledC0 = valueC != null ? _context.cScale(valueC) : _context.COLOR_WHITEISH;\n          _context._updateLabel(d, 0, _context.frame, cache.labelX0, cache.labelY0, valueS, valueC, _context.frame.label[utils.getKey(d, dataKeys.label)], _context.frame.size_label[utils.getKey(d, dataKeys.size_label)], 0, true);\n        }\n        trail.each((segment, index) => {\n          // segment is transparent if it is after current time or before trail StartTime\n          const segmentVisibility = segment.transparent;\n          segment.transparent = d.selectedEntityData.trailStartTime == null || (segment.t - _context.time > 0) || (trailStartTime - segment.t > 0)\n            //no trail segment should be visible if leading bubble is shifted backwards, beyond start time\n            || (d.selectedEntityData.trailStartTime - _context.model.time.formatDate(_context.time) >= 0);\n          // always update nearest 2 points\n          if (segmentVisibility != segment.transparent || Math.abs(_context.model.time.formatDate(segment.t) - _context.model.time.formatDate(_context.time)) < 2) segment.visibilityChanged = true; // segment changed, so need to update it\n          if (segment.transparent) {\n            d3.select(trail._groups[0][index]).classed(\"vzb-invisible\", segment.transparent);\n          }\n        });\n        _this.drawingQueue[d[KEY]] = {};\n        _this.delayedIterations[d[KEY]] = {};\n        resolve();\n      });\n    });\n  },\n\n  _abortAnimation() {\n    const _context = this.context;\n    const _this = this;\n    const KEY = _context.KEY;\n    _this.trailsData.forEach(d => {\n      if (_this.trailTransitions[d[KEY]]) {\n        _this.trailTransitions[d[KEY]].select(\"line\").interrupt().transition();\n      }\n    });\n  },\n\n  _reveal(trail, duration, d) {\n    const _context = this.context;\n    if(_context.model.time.playing) duration = _context.model.time.delay;\n    const _this = this;\n    const KEYS = _context.KEYS;\n    const KEY = _context.KEY;\n    const dataKeys = _context.dataKeys;\n    d.status = \"reveal\";\n    const trailStartTime = _context.model.time.parse(\"\" + d.selectedEntityData.trailStartTime);\n    const generateTrailSegment = function(trail, index, nextIndex, level) {\n      return new Promise((resolve, reject) => {\n        const view = d3.select(trail._groups[0][index]);\n\n        const segment = view.datum();\n\n        //console.log(d[KEY] + \" transparent: \" + segment.transparent + \" vis_changed:\" + segment.visibilityChanged);\n        if (nextIndex - index == 1) {\n          if (segment.transparent) {\n            view.classed(\"vzb-invisible\", segment.transparent);\n            return resolve();\n          } else if (!segment.visibilityChanged) { // pass segment if it is not changed\n            return resolve();\n          }\n        }\n        _context.model.marker.getFrame(segment.t, frame => {\n          if (d.status != \"reveal\") return resolve();\n          if (!frame) return resolve();\n          segment.valueY = frame.axis_y[utils.getKey(d, dataKeys.axis_y)];\n          segment.valueX = frame.axis_x[utils.getKey(d, dataKeys.axis_x)];\n          segment.valueS = frame.size[utils.getKey(d, dataKeys.size)];\n          segment.valueC = frame.color[utils.getKey(d, dataKeys.color)];\n\n          if (segment.valueY == null || segment.valueX == null || segment.valueS == null) {\n            return resolve();\n          }\n\n          // fix label position if it not in correct place\n          if (trailStartTime && trailStartTime.toString() == segment.t.toString()) {\n            const cache = _context._labels.cached[d[KEY]];\n            cache.labelX0 = segment.valueX;\n            cache.labelY0 = segment.valueY;\n            const valueS = segment.valueS;\n            cache.scaledS0 = (valueS || valueS === 0) ? utils.areaToRadius(_context.sScale(valueS)) : null;\n            cache.scaledC0 = segment.valueC != null ? _context.cScale(segment.valueC) : _context.COLOR_WHITEISH;\n            _context._updateLabel(d, index, frame, segment.valueX, segment.valueY, segment.valueS, segment.valueC, frame.label[utils.getKey(d, dataKeys.label)], frame.size_label[utils.getKey(d, dataKeys.size_label)], 0, true);\n          }\n          view.select(\"circle\")\n          //.transition().duration(duration).ease(d3.easeLinear)\n            .attr(\"cy\", _context.yScale(segment.valueY))\n            .attr(\"cx\", _context.xScale(segment.valueX))\n            .attr(\"r\", utils.areaToRadius(_context.sScale(segment.valueS)))\n            .style(\"fill\", segment.valueC != null ? _context.cScale(segment.valueC) : _context.COLOR_WHITEISH);\n\n          view.select(\"line\")\n            .attr(\"x2\", _context.xScale(segment.valueX))\n            .attr(\"y2\", _context.yScale(segment.valueY))\n            .attr(\"x1\", _context.xScale(segment.valueX))\n            .attr(\"y1\", _context.yScale(segment.valueY));\n\n          // last point should have data for line but it is invisible\n          if (_context.time - segment.t > 0) {\n            segment.visibilityChanged = false;\n            view.classed(\"vzb-invisible\", segment.transparent);\n          } else {\n            view.classed(\"vzb-invisible\", true);\n          }\n\n          if (!trail._groups[0][nextIndex] || _context.time.toString() == segment.t.toString()) {\n            return resolve();\n          }\n\n          const next = d3.select(trail._groups[0][nextIndex]);\n          const nextSegment = next.datum();\n          nextSegment.previous = segment;\n          segment.next = nextSegment;\n          let nextTime = nextSegment.t;\n          if (_context.time - nextSegment.t < 0) { // time is not equal start of year\n            segment.visibilityChanged = true; // redraw needed next time because line not have full length\n            nextTime = _context.time;\n          }\n          _context.model.marker.getFrame(nextTime, nextFrame => {\n            if (d.status != \"reveal\") return resolve();\n            if (!nextFrame || segment.valueY == null || segment.valueX == null || segment.valueS == null) {\n              return resolve();\n            }\n\n            if (nextFrame.axis_x[utils.getKey(d, dataKeys.axis_x)] == null || nextFrame.axis_y[utils.getKey(d, dataKeys.axis_y)] == null) {\n              return resolve();\n            }\n\n            nextSegment.valueY = nextFrame.axis_y[utils.getKey(d, dataKeys.axis_y)];\n            nextSegment.valueX = nextFrame.axis_x[utils.getKey(d, dataKeys.axis_x)];\n            nextSegment.valueS = nextFrame.size[utils.getKey(d, dataKeys.size)];\n            nextSegment.valueC = nextFrame.color[utils.getKey(d, dataKeys.color)];\n\n            _this.trailTransitions[d[KEY]] = view;\n            const strokeColor = _context.model.marker.color.which == \"geo.world_4region\" ?\n              //use predefined shades for color palette for \"geo.world_4region\" (hardcoded)\n              _context.model.marker.color.getColorShade({\n                colorID: segment.valueC,\n                shadeID: \"shade\"\n              })\n              :\n              //otherwise use color of the bubble with a fallback to bubble stroke color (blackish)\n              (segment.valueC != null ? _context.cScale(segment.valueC) : _context.COLOR_BLACKISH);\n\n            const lineLength = Math.sqrt(\n              Math.pow(_context.xScale(segment.valueX) - _context.xScale(nextSegment.valueX), 2) +\n              Math.pow(_context.yScale(segment.valueY) - _context.yScale(nextSegment.valueY), 2)\n            );\n            view.select(\"line\")\n              .attr(\"stroke-dasharray\", lineLength)\n              .attr(\"stroke-dashoffset\", utils.areaToRadius(_context.sScale(segment.valueS)))\n              .style(\"stroke\", strokeColor)\n              .transition().duration(duration).ease(d3.easeLinear)\n              .attr(\"x1\", _context.xScale(nextSegment.valueX))\n              .attr(\"y1\", _context.yScale(nextSegment.valueY))\n              .attr(\"x2\", _context.xScale(segment.valueX))\n              .attr(\"y2\", _context.yScale(segment.valueY));\n            if (nextIndex - index > 1) {\n              addNewIntervals(index, nextIndex);\n              return resolve();\n            }\n            return resolve();\n          });\n        });\n      });\n    };\n    const addPointBetween = function(previousIndex, nextIndex, index) {\n      return new Promise((resolve, reject) => {\n        const previous = d3.select(trail._groups[0][previousIndex]);\n        const next = d3.select(trail._groups[0][nextIndex]);\n        const view = d3.select(trail._groups[0][index]);\n        const previousSegment = previous.datum();\n        const nextSegment = next.datum();\n        const segment = view.datum();\n\n        if ((!previousSegment.previous && !previousSegment.next) || (!nextSegment.previous && !nextSegment.next)) {\n          // segment data cleared by create action\n          return resolve();\n        }\n\n        _context.model.marker.getFrame(segment.t, frame => {\n          if (d.status != \"reveal\") return resolve();\n          if (!frame ||\n            (typeof frame.axis_x === \"undefined\") || frame.axis_x[utils.getKey(d, dataKeys.axis_x)] == null ||\n            (typeof frame.axis_y === \"undefined\") || frame.axis_y[utils.getKey(d, dataKeys.axis_y)] == null) {\n            utils.warn(\"Frame for trail missed: \" + segment.t);\n            return resolve();\n          }\n          segment.valueY = frame.axis_y[utils.getKey(d, dataKeys.axis_y)];\n          segment.valueX = frame.axis_x[utils.getKey(d, dataKeys.axis_x)];\n          segment.valueS = frame.size[utils.getKey(d, dataKeys.size)];\n          segment.valueC = frame.color[utils.getKey(d, dataKeys.color)];\n\n          segment.previous = previousSegment;\n          segment.next = nextSegment;\n          previousSegment.next = segment;\n          nextSegment.previous = segment;\n\n          if (segment.valueY == null || segment.valueX == null || segment.valueS == null) {\n            utils.warn(\"Data for trail point missed: \" + segment.t);\n            return resolve();\n          }\n\n          const strokeColor = _context.model.marker.color.which == \"geo.world_4region\" ?\n            //use predefined shades for color palette for \"geo.world_4region\" (hardcoded)\n            _context.model.marker.color.getColorShade({\n              colorID: segment.valueC,\n              shadeID: \"shade\"\n            })\n            :\n            //otherwise use color of the bubble with a fallback to bubble stroke color (blackish)\n            (segment.valueC != null ? _context.cScale(segment.valueC) : _context.COLOR_BLACKISH);\n\n          const firstLineLength = Math.sqrt(\n            Math.pow(_context.xScale(previousSegment.valueX) - _context.xScale(segment.valueX), 2) +\n            Math.pow(_context.yScale(previousSegment.valueY) - _context.yScale(segment.valueX), 2)\n          );\n\n          previous.select(\"line\")\n            .transition().duration(duration).ease(d3.easeLinear)\n            .attr(\"x1\", _context.xScale(segment.valueX))\n            .attr(\"y1\", _context.yScale(segment.valueY))\n            .attr(\"x2\", _context.xScale(previousSegment.valueX))\n            .attr(\"y2\", _context.yScale(previousSegment.valueY))\n            .attr(\"stroke-dasharray\", firstLineLength)\n            .attr(\"stroke-dashoffset\", utils.areaToRadius(_context.sScale(previousSegment.valueS)))\n            .style(\"stroke\", strokeColor);\n\n          view.classed(\"vzb-invisible\", segment.transparent);\n\n          if (!segment.transparent) {\n            view.select(\"circle\")\n            //.transition().duration(duration).ease(d3.easeLinear)\n              .attr(\"cy\", _context.yScale(segment.valueY))\n              .attr(\"cx\", _context.xScale(segment.valueX))\n              .attr(\"r\", utils.areaToRadius(_context.sScale(segment.valueS)))\n              .style(\"fill\", segment.valueC != null ? _context.cScale(segment.valueC) : _context.COLOR_WHITEISH);\n\n            const secondLineLength = Math.sqrt(\n              Math.pow(_context.xScale(segment.valueX) - _context.xScale(nextSegment.valueX), 2) +\n              Math.pow(_context.yScale(segment.valueY) - _context.yScale(nextSegment.valueY), 2)\n            );\n\n            view.select(\"line\")\n              .transition().duration(duration).ease(d3.easeLinear)\n              .attr(\"x1\", _context.xScale(nextSegment.valueX))\n              .attr(\"y1\", _context.yScale(nextSegment.valueY))\n              .attr(\"x2\", _context.xScale(segment.valueX))\n              .attr(\"y2\", _context.yScale(segment.valueY))\n              .attr(\"stroke-dasharray\", secondLineLength)\n              .attr(\"stroke-dashoffset\", utils.areaToRadius(_context.sScale(segment.valueS)))\n              .style(\"stroke\", strokeColor);\n          }\n          addNewIntervals(previousIndex, index, nextIndex);\n          resolve();\n        });\n      });\n    };\n    const addNewIntervals = function(previousIndex, index, nextIndex) {\n      let mediumIndex;\n      if (index - previousIndex > 1) {\n        mediumIndex = getPointBetween(previousIndex, index);\n        _this.delayedIterations[d[KEY]][previousIndex] = {\n          first: previousIndex,\n          next: index,\n          medium: mediumIndex\n        };\n      }\n      if (nextIndex && nextIndex - index > 1) {\n        mediumIndex = getPointBetween(index, nextIndex);\n        _this.delayedIterations[d[KEY]][index] = {\n          first: index,\n          next: nextIndex,\n          medium: mediumIndex\n        };\n      }\n    };\n    const getPointBetween = function(previous, next) {\n      return Math.round(previous + (next - previous) / 2);\n    };\n\n    const _generateKeys = function(d, trail, div) {\n      const response = [];\n      let min = 0, max = 0;\n      const maxValue = d3.min([d.limits.max, _context.time]);\n      const minValue = d3.max([d.limits.min, _context.model.time.parse(\"\" + d.selectedEntityData.trailStartTime)]);\n      utils.forEach(trail._groups[0], (segment, index) => {\n        const data = segment.__data__;\n        if (data.t - minValue == 0) {\n          min = index;\n        } else if (data.t - maxValue == 0) {\n          max = index;\n        } else {\n          if (data.t > minValue && data.t < maxValue) {\n            if (_context.model.time.formatDate(data.t) % div == 0 || (data.next && data.previous)) {\n              response.push(index);\n            }\n          }\n        }\n      });\n      response.unshift(min);\n      if (max > 0) {\n        response.push(max);\n      }\n      return response;\n    };\n\n    const processPoints = function() {\n      return new Promise((resolve, reject) => {\n        const processPoint = function() {\n          const pointIndex = Object.keys(_this.drawingQueue[d[KEY]])[Math.floor(Math.random() * Object.keys(_this.drawingQueue[d[KEY]]).length)];\n          const point = JSON.parse(JSON.stringify(_this.drawingQueue[d[KEY]][pointIndex]));\n          delete _this.drawingQueue[d[KEY]][pointIndex];\n          addPointBetween(point.first, point.next, point.medium).then(() => {\n            if (Object.keys(_this.drawingQueue[d[KEY]]).length > 0) {\n              processPoint();\n            } else {\n              resolve();\n            }\n          });\n        };\n        if (Object.keys(_this.drawingQueue[d[KEY]]).length > 0) {\n          processPoint(_this.drawingQueue[d[KEY]]);\n        } else {\n          resolve();\n        }\n      });\n    };\n\n    return new Promise((resolve, reject) => {\n      /**\n       * iteration for each point from first segment to last\n       * @param trail\n       * @param index\n       */\n      const generateTrails = function(trail, index) {\n        if (index < 0 || index >= trail._groups[0].length) {\n          return resolve();\n        }\n        generateTrailSegment(trail, index, index + 1).then(() => {\n          generateTrails(trail, index + 1);\n        }, () => resolve());\n      };\n\n      /**\n       * recursive iteration for drawing point between points calculated in previous step\n       */\n      const processPointsBetween = function() {\n        processPoints().then(() => {\n          if (Object.keys(_this.delayedIterations[d[KEY]]).length == 0) {\n            return resolve();\n          }\n          _this.drawingQueue[d[KEY]] = _this.delayedIterations[d[KEY]];\n          _this.delayedIterations[d[KEY]] = {};\n          processPointsBetween();\n        }, () => resolve());\n      };\n\n      if (_context.model.marker.framesAreReady()) {\n        generateTrails(trail, 0);\n      } else {\n        _this.delayedIterations[d[KEY]] = {};\n        _this.drawingQueue[d[KEY]] = {};\n        const trailKeys = _generateKeys(d, trail, 50);\n        const segments = [];\n        if (trailKeys.length <= 1) {\n          return resolve();\n        }\n\n        _this.delayedIterations[d[KEY]] = {};\n        for (let i = 0; i < trailKeys.length - 1; i++) {\n          segments.push(generateTrailSegment(trail, trailKeys[i], trailKeys[i + 1], 1));\n        }\n        Promise.all(segments).then(() => {\n          if (Object.keys(_this.delayedIterations[d[KEY]]).length == 0) {\n            resolve();\n          } else {\n            _this.drawingQueue[d[KEY]] = _this.delayedIterations[d[KEY]];\n            _this.delayedIterations[d[KEY]] = {};\n            processPointsBetween();\n          }\n        }, () => {\n          resolve();\n        });\n      }\n    });\n  }\n});\n\nexport default Trail;\n\n\n\n// WEBPACK FOOTER //\n// ./src/trail.js","/*! https://mths.be/cssescape v1.5.1 by @mathias | MIT license */\n;(function(root, factory) {\n\t// https://github.com/umdjs/umd/blob/master/returnExports.js\n\tif (typeof exports == 'object') {\n\t\t// For Node.js.\n\t\tmodule.exports = factory(root);\n\t} else if (typeof define == 'function' && define.amd) {\n\t\t// For AMD. Register as an anonymous module.\n\t\tdefine([], factory.bind(root, root));\n\t} else {\n\t\t// For browser globals (not exposing the function separately).\n\t\tfactory(root);\n\t}\n}(typeof global != 'undefined' ? global : this, function(root) {\n\n\tif (root.CSS && root.CSS.escape) {\n\t\treturn root.CSS.escape;\n\t}\n\n\t// https://drafts.csswg.org/cssom/#serialize-an-identifier\n\tvar cssEscape = function(value) {\n\t\tif (arguments.length == 0) {\n\t\t\tthrow new TypeError('`CSS.escape` requires an argument.');\n\t\t}\n\t\tvar string = String(value);\n\t\tvar length = string.length;\n\t\tvar index = -1;\n\t\tvar codeUnit;\n\t\tvar result = '';\n\t\tvar firstCodeUnit = string.charCodeAt(0);\n\t\twhile (++index < length) {\n\t\t\tcodeUnit = string.charCodeAt(index);\n\t\t\t// Note: there’s no need to special-case astral symbols, surrogate\n\t\t\t// pairs, or lone surrogates.\n\n\t\t\t// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER\n\t\t\t// (U+FFFD).\n\t\t\tif (codeUnit == 0x0000) {\n\t\t\t\tresult += '\\uFFFD';\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\t// If the character is in the range [\\1-\\1F] (U+0001 to U+001F) or is\n\t\t\t\t// U+007F, […]\n\t\t\t\t(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||\n\t\t\t\t// If the character is the first character and is in the range [0-9]\n\t\t\t\t// (U+0030 to U+0039), […]\n\t\t\t\t(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||\n\t\t\t\t// If the character is the second character and is in the range [0-9]\n\t\t\t\t// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]\n\t\t\t\t(\n\t\t\t\t\tindex == 1 &&\n\t\t\t\t\tcodeUnit >= 0x0030 && codeUnit <= 0x0039 &&\n\t\t\t\t\tfirstCodeUnit == 0x002D\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\t// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point\n\t\t\t\tresult += '\\\\' + codeUnit.toString(16) + ' ';\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\t// If the character is the first character and is a `-` (U+002D), and\n\t\t\t\t// there is no second character, […]\n\t\t\t\tindex == 0 &&\n\t\t\t\tlength == 1 &&\n\t\t\t\tcodeUnit == 0x002D\n\t\t\t) {\n\t\t\t\tresult += '\\\\' + string.charAt(index);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If the character is not handled by one of the above rules and is\n\t\t\t// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or\n\t\t\t// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to\n\t\t\t// U+005A), or [a-z] (U+0061 to U+007A), […]\n\t\t\tif (\n\t\t\t\tcodeUnit >= 0x0080 ||\n\t\t\t\tcodeUnit == 0x002D ||\n\t\t\t\tcodeUnit == 0x005F ||\n\t\t\t\tcodeUnit >= 0x0030 && codeUnit <= 0x0039 ||\n\t\t\t\tcodeUnit >= 0x0041 && codeUnit <= 0x005A ||\n\t\t\t\tcodeUnit >= 0x0061 && codeUnit <= 0x007A\n\t\t\t) {\n\t\t\t\t// the character itself\n\t\t\t\tresult += string.charAt(index);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Otherwise, the escaped character.\n\t\t\t// https://drafts.csswg.org/cssom/#escape-a-character\n\t\t\tresult += '\\\\' + string.charAt(index);\n\n\t\t}\n\t\treturn result;\n\t};\n\n\tif (!root.CSS) {\n\t\troot.CSS = {};\n\t}\n\n\troot.CSS.escape = cssEscape;\n\treturn cssEscape;\n\n}));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css.escape/css.escape.js\n// module id = 4\n// module chunks = 0 1","module.exports = \"<!-- Bubble Chart Component -->\\n<div class=\\\"vzb-bubblechart\\\">\\n    <svg class=\\\"vzb-bubblechart-svg vzb-export\\\">\\n        <g class=\\\"vzb-bc-graph\\\">\\n            <g class=\\\"vzb-bc-year\\\"></g>\\n\\n            <svg class=\\\"vzb-bc-axis-x\\\"><g></g></svg>\\n            <svg class=\\\"vzb-bc-axis-y\\\"><g></g></svg>\\n            <line class=\\\"vzb-bc-projection-x\\\"></line>\\n            <line class=\\\"vzb-bc-projection-y\\\"></line>\\n\\n            <svg class=\\\"vzb-bc-bubbles-crop\\\">\\n                <g class=\\\"vzb-zoom-selection\\\"></g>\\n                <line class=\\\"vzb-bc-line-equal-xy vzb-invisible\\\"></line>\\n                <rect class=\\\"vzb-bc-eventarea\\\"></rect>\\n                <g class=\\\"vzb-bc-trails\\\"></g>\\n                <g class=\\\"vzb-bc-bubbles\\\"></g>\\n                <g class=\\\"vzb-bc-lines\\\"></g>\\n                <g class=\\\"vzb-bc-bubble-crown vzb-hidden\\\">\\n                    <circle class=\\\"vzb-crown-glow\\\"></circle>\\n                    <circle class=\\\"vzb-crown\\\"></circle>\\n                </g>\\n            </svg>\\n\\n            <g class=\\\"vzb-bc-axis-y-subtitle\\\"></g>\\n            <g class=\\\"vzb-bc-axis-x-subtitle\\\"></g>\\n            <g class=\\\"vzb-bc-axis-y-title\\\"></g>\\n            <g class=\\\"vzb-bc-axis-x-title\\\"></g>\\n            <g class=\\\"vzb-bc-axis-s-title\\\"></g>\\n            <g class=\\\"vzb-bc-axis-c-title\\\"></g>\\n\\n            <g class=\\\"vzb-bc-axis-y-info vzb-noexport\\\"></g>\\n            <g class=\\\"vzb-bc-axis-x-info vzb-noexport\\\"></g>\\n\\n            <svg class=\\\"vzb-bc-labels-crop\\\">\\n                <g class=\\\"vzb-bc-labels\\\"></g>\\n            </svg>\\n\\n            <g class=\\\"vzb-data-warning vzb-noexport\\\">\\n                <svg></svg>\\n                <text></text>\\n            </g>\\n\\n            <rect class=\\\"vzb-bc-zoom-rect\\\"></rect>\\n        </g>\\n    </svg>\\n    <svg>\\n        <defs>\\n            <filter id=\\\"vzb-glow-filter\\\" x=\\\"-50%\\\" y=\\\"-50%\\\" width=\\\"200%\\\" height=\\\"200%\\\">\\n                <feGaussianBlur in=\\\"SourceGraphic\\\" stdDeviation=\\\"2\\\"></feGaussianBlur>\\n            </filter>\\n        </defs>\\n    </svg>\\n    <!-- This could possibly be another component -->\\n    <div class=\\\"vzb-tooltip vzb-hidden vzb-tooltip-mobile\\\"></div>\\n</div>\\n\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/template.html\n// module id = 6\n// module chunks = 0 1","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 7\n// module chunks = 0 1"],"sourceRoot":""}